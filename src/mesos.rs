// This file is generated. Do not edit
// @generated

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(Clone,Default)]
pub struct FrameworkID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl FrameworkID {
    pub fn new() -> FrameworkID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FrameworkID {
        static mut instance: ::protobuf::lazy::Lazy<FrameworkID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FrameworkID,
        };
        unsafe {
            instance.get(|| {
                FrameworkID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for FrameworkID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<FrameworkID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FrameworkID {
    fn new() -> FrameworkID {
        FrameworkID::new()
    }

    fn descriptor_static(_: ::std::option::Option<FrameworkID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    FrameworkID::has_value,
                    FrameworkID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FrameworkID>(
                    "FrameworkID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FrameworkID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for FrameworkID {
    fn eq(&self, other: &FrameworkID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for FrameworkID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct OfferID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl OfferID {
    pub fn new() -> OfferID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static OfferID {
        static mut instance: ::protobuf::lazy::Lazy<OfferID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OfferID,
        };
        unsafe {
            instance.get(|| {
                OfferID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for OfferID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<OfferID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for OfferID {
    fn new() -> OfferID {
        OfferID::new()
    }

    fn descriptor_static(_: ::std::option::Option<OfferID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    OfferID::has_value,
                    OfferID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OfferID>(
                    "OfferID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for OfferID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for OfferID {
    fn eq(&self, other: &OfferID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for OfferID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SlaveID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SlaveID {
    pub fn new() -> SlaveID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SlaveID {
        static mut instance: ::protobuf::lazy::Lazy<SlaveID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SlaveID,
        };
        unsafe {
            instance.get(|| {
                SlaveID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SlaveID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SlaveID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SlaveID {
    fn new() -> SlaveID {
        SlaveID::new()
    }

    fn descriptor_static(_: ::std::option::Option<SlaveID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    SlaveID::has_value,
                    SlaveID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SlaveID>(
                    "SlaveID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SlaveID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SlaveID {
    fn eq(&self, other: &SlaveID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SlaveID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TaskID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl TaskID {
    pub fn new() -> TaskID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskID {
        static mut instance: ::protobuf::lazy::Lazy<TaskID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskID,
        };
        unsafe {
            instance.get(|| {
                TaskID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TaskID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TaskID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskID {
    fn new() -> TaskID {
        TaskID::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    TaskID::has_value,
                    TaskID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskID>(
                    "TaskID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TaskID {
    fn eq(&self, other: &TaskID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TaskID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ExecutorID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ExecutorID {
    pub fn new() -> ExecutorID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ExecutorID {
        static mut instance: ::protobuf::lazy::Lazy<ExecutorID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecutorID,
        };
        unsafe {
            instance.get(|| {
                ExecutorID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExecutorID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ExecutorID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ExecutorID {
    fn new() -> ExecutorID {
        ExecutorID::new()
    }

    fn descriptor_static(_: ::std::option::Option<ExecutorID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    ExecutorID::has_value,
                    ExecutorID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecutorID>(
                    "ExecutorID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ExecutorID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ExecutorID {
    fn eq(&self, other: &ExecutorID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ExecutorID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ContainerID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ContainerID {
    pub fn new() -> ContainerID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerID {
        static mut instance: ::protobuf::lazy::Lazy<ContainerID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerID,
        };
        unsafe {
            instance.get(|| {
                ContainerID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ContainerID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerID {
    fn new() -> ContainerID {
        ContainerID::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    ContainerID::has_value,
                    ContainerID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerID>(
                    "ContainerID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerID {
    fn eq(&self, other: &ContainerID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Address {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    ip: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Address {
        static mut instance: ::protobuf::lazy::Lazy<Address> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Address,
        };
        unsafe {
            instance.get(|| {
                Address {
                    hostname: ::protobuf::SingularField::none(),
                    ip: ::protobuf::SingularField::none(),
                    port: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string hostname = 1;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string ip = 2;

    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        };
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip<'a>(&'a self) -> &'a str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required int32 port = 3;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port<'a>(&self) -> i32 {
        self.port.unwrap_or(0)
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        if self.port.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.hostname.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.ip.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.ip.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.ip.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.port {
            try!(os.write_int32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Address>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Address {
    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static(_: ::std::option::Option<Address>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    Address::has_hostname,
                    Address::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ip",
                    Address::has_ip,
                    Address::get_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "port",
                    Address::has_port,
                    Address::get_port,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Address>(
                    "Address",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.clear_hostname();
        self.clear_ip();
        self.clear_port();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Address {
    fn eq(&self, other: &Address) -> bool {
        self.hostname == other.hostname &&
        self.ip == other.ip &&
        self.port == other.port &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct URL {
    // message fields
    scheme: ::protobuf::SingularField<::std::string::String>,
    address: ::protobuf::SingularPtrField<Address>,
    path: ::protobuf::SingularField<::std::string::String>,
    query: ::protobuf::RepeatedField<Parameter>,
    fragment: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl URL {
    pub fn new() -> URL {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static URL {
        static mut instance: ::protobuf::lazy::Lazy<URL> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const URL,
        };
        unsafe {
            instance.get(|| {
                URL {
                    scheme: ::protobuf::SingularField::none(),
                    address: ::protobuf::SingularPtrField::none(),
                    path: ::protobuf::SingularField::none(),
                    query: ::protobuf::RepeatedField::new(),
                    fragment: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string scheme = 1;

    pub fn clear_scheme(&mut self) {
        self.scheme.clear();
    }

    pub fn has_scheme(&self) -> bool {
        self.scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheme(&mut self, v: ::std::string::String) {
        self.scheme = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheme<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.scheme.is_none() {
            self.scheme.set_default();
        };
        self.scheme.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheme(&mut self) -> ::std::string::String {
        self.scheme.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_scheme<'a>(&'a self) -> &'a str {
        match self.scheme.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .mesos.Address address = 2;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address<'a>(&'a mut self) -> &'a mut Address {
        if self.address.is_none() {
            self.address.set_default();
        };
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }

    pub fn get_address<'a>(&'a self) -> &'a Address {
        self.address.as_ref().unwrap_or_else(|| Address::default_instance())
    }

    // optional string path = 3;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .mesos.Parameter query = 4;

    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::protobuf::RepeatedField<Parameter>) {
        self.query = v;
    }

    // Mutable pointer to the field.
    pub fn mut_query<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Parameter> {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::protobuf::RepeatedField<Parameter> {
        ::std::mem::replace(&mut self.query, ::protobuf::RepeatedField::new())
    }

    pub fn get_query<'a>(&'a self) -> &'a [Parameter] {
        &self.query
    }

    // optional string fragment = 5;

    pub fn clear_fragment(&mut self) {
        self.fragment.clear();
    }

    pub fn has_fragment(&self) -> bool {
        self.fragment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fragment(&mut self, v: ::std::string::String) {
        self.fragment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fragment<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.fragment.is_none() {
            self.fragment.set_default();
        };
        self.fragment.as_mut().unwrap()
    }

    // Take field
    pub fn take_fragment(&mut self) -> ::std::string::String {
        self.fragment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fragment<'a>(&'a self) -> &'a str {
        match self.fragment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for URL {
    fn is_initialized(&self) -> bool {
        if self.scheme.is_none() {
            return false;
        };
        if self.address.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.scheme.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.address.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.path.set_default();
                    try!(is.read_string_into(tmp))
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.query));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.fragment.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.scheme.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.address.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.query.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.fragment.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.scheme.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.address.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.path.as_ref() {
            try!(os.write_string(3, &v));
        };
        for v in self.query.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.fragment.as_ref() {
            try!(os.write_string(5, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<URL>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for URL {
    fn new() -> URL {
        URL::new()
    }

    fn descriptor_static(_: ::std::option::Option<URL>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "scheme",
                    URL::has_scheme,
                    URL::get_scheme,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "address",
                    URL::has_address,
                    URL::get_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "path",
                    URL::has_path,
                    URL::get_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "query",
                    URL::get_query,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "fragment",
                    URL::has_fragment,
                    URL::get_fragment,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<URL>(
                    "URL",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for URL {
    fn clear(&mut self) {
        self.clear_scheme();
        self.clear_address();
        self.clear_path();
        self.clear_query();
        self.clear_fragment();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for URL {
    fn eq(&self, other: &URL) -> bool {
        self.scheme == other.scheme &&
        self.address == other.address &&
        self.path == other.path &&
        self.query == other.query &&
        self.fragment == other.fragment &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for URL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct FrameworkInfo {
    // message fields
    user: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    id: ::protobuf::SingularPtrField<FrameworkID>,
    failover_timeout: ::std::option::Option<f64>,
    checkpoint: ::std::option::Option<bool>,
    role: ::protobuf::SingularField<::std::string::String>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    principal: ::protobuf::SingularField<::std::string::String>,
    webui_url: ::protobuf::SingularField<::std::string::String>,
    capabilities: ::protobuf::RepeatedField<FrameworkInfo_Capability>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl FrameworkInfo {
    pub fn new() -> FrameworkInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FrameworkInfo {
        static mut instance: ::protobuf::lazy::Lazy<FrameworkInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FrameworkInfo,
        };
        unsafe {
            instance.get(|| {
                FrameworkInfo {
                    user: ::protobuf::SingularField::none(),
                    name: ::protobuf::SingularField::none(),
                    id: ::protobuf::SingularPtrField::none(),
                    failover_timeout: ::std::option::Option::None,
                    checkpoint: ::std::option::Option::None,
                    role: ::protobuf::SingularField::none(),
                    hostname: ::protobuf::SingularField::none(),
                    principal: ::protobuf::SingularField::none(),
                    webui_url: ::protobuf::SingularField::none(),
                    capabilities: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string user = 1;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        };
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user<'a>(&'a self) -> &'a str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.FrameworkID id = 3;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: FrameworkID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut FrameworkID {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> FrameworkID {
        self.id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a FrameworkID {
        self.id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    // optional double failover_timeout = 4;

    pub fn clear_failover_timeout(&mut self) {
        self.failover_timeout = ::std::option::Option::None;
    }

    pub fn has_failover_timeout(&self) -> bool {
        self.failover_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failover_timeout(&mut self, v: f64) {
        self.failover_timeout = ::std::option::Option::Some(v);
    }

    pub fn get_failover_timeout<'a>(&self) -> f64 {
        self.failover_timeout.unwrap_or(0f64)
    }

    // optional bool checkpoint = 5;

    pub fn clear_checkpoint(&mut self) {
        self.checkpoint = ::std::option::Option::None;
    }

    pub fn has_checkpoint(&self) -> bool {
        self.checkpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpoint(&mut self, v: bool) {
        self.checkpoint = ::std::option::Option::Some(v);
    }

    pub fn get_checkpoint<'a>(&self) -> bool {
        self.checkpoint.unwrap_or(false)
    }

    // optional string role = 6;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        };
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role<'a>(&'a self) -> &'a str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "*",
        }
    }

    // optional string hostname = 7;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string principal = 8;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        };
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal<'a>(&'a self) -> &'a str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string webui_url = 9;

    pub fn clear_webui_url(&mut self) {
        self.webui_url.clear();
    }

    pub fn has_webui_url(&self) -> bool {
        self.webui_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webui_url(&mut self, v: ::std::string::String) {
        self.webui_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webui_url<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.webui_url.is_none() {
            self.webui_url.set_default();
        };
        self.webui_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_webui_url(&mut self) -> ::std::string::String {
        self.webui_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_webui_url<'a>(&'a self) -> &'a str {
        match self.webui_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .mesos.FrameworkInfo.Capability capabilities = 10;

    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: ::protobuf::RepeatedField<FrameworkInfo_Capability>) {
        self.capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capabilities<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<FrameworkInfo_Capability> {
        &mut self.capabilities
    }

    // Take field
    pub fn take_capabilities(&mut self) -> ::protobuf::RepeatedField<FrameworkInfo_Capability> {
        ::std::mem::replace(&mut self.capabilities, ::protobuf::RepeatedField::new())
    }

    pub fn get_capabilities<'a>(&'a self) -> &'a [FrameworkInfo_Capability] {
        &self.capabilities
    }
}

impl ::protobuf::Message for FrameworkInfo {
    fn is_initialized(&self) -> bool {
        if self.user.is_none() {
            return false;
        };
        if self.name.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.user.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.id.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.failover_timeout = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.checkpoint = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.role.set_default();
                    try!(is.read_string_into(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.hostname.set_default();
                    try!(is.read_string_into(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.principal.set_default();
                    try!(is.read_string_into(tmp))
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.webui_url.set_default();
                    try!(is.read_string_into(tmp))
                },
                10 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.capabilities));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.user.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.failover_timeout.is_some() {
            my_size += 9;
        };
        if self.checkpoint.is_some() {
            my_size += 2;
        };
        for value in self.role.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in self.principal.iter() {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in self.webui_url.iter() {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in self.capabilities.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.id.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.failover_timeout {
            try!(os.write_double(4, v));
        };
        if let Some(v) = self.checkpoint {
            try!(os.write_bool(5, v));
        };
        if let Some(v) = self.role.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(7, &v));
        };
        if let Some(v) = self.principal.as_ref() {
            try!(os.write_string(8, &v));
        };
        if let Some(v) = self.webui_url.as_ref() {
            try!(os.write_string(9, &v));
        };
        for v in self.capabilities.iter() {
            try!(os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<FrameworkInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FrameworkInfo {
    fn new() -> FrameworkInfo {
        FrameworkInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<FrameworkInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "user",
                    FrameworkInfo::has_user,
                    FrameworkInfo::get_user,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    FrameworkInfo::has_name,
                    FrameworkInfo::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "id",
                    FrameworkInfo::has_id,
                    FrameworkInfo::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "failover_timeout",
                    FrameworkInfo::has_failover_timeout,
                    FrameworkInfo::get_failover_timeout,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "checkpoint",
                    FrameworkInfo::has_checkpoint,
                    FrameworkInfo::get_checkpoint,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "role",
                    FrameworkInfo::has_role,
                    FrameworkInfo::get_role,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    FrameworkInfo::has_hostname,
                    FrameworkInfo::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "principal",
                    FrameworkInfo::has_principal,
                    FrameworkInfo::get_principal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "webui_url",
                    FrameworkInfo::has_webui_url,
                    FrameworkInfo::get_webui_url,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "capabilities",
                    FrameworkInfo::get_capabilities,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FrameworkInfo>(
                    "FrameworkInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FrameworkInfo {
    fn clear(&mut self) {
        self.clear_user();
        self.clear_name();
        self.clear_id();
        self.clear_failover_timeout();
        self.clear_checkpoint();
        self.clear_role();
        self.clear_hostname();
        self.clear_principal();
        self.clear_webui_url();
        self.clear_capabilities();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for FrameworkInfo {
    fn eq(&self, other: &FrameworkInfo) -> bool {
        self.user == other.user &&
        self.name == other.name &&
        self.id == other.id &&
        self.failover_timeout == other.failover_timeout &&
        self.checkpoint == other.checkpoint &&
        self.role == other.role &&
        self.hostname == other.hostname &&
        self.principal == other.principal &&
        self.webui_url == other.webui_url &&
        self.capabilities == other.capabilities &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for FrameworkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct FrameworkInfo_Capability {
    // message fields
    field_type: ::std::option::Option<FrameworkInfo_Capability_Type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl FrameworkInfo_Capability {
    pub fn new() -> FrameworkInfo_Capability {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FrameworkInfo_Capability {
        static mut instance: ::protobuf::lazy::Lazy<FrameworkInfo_Capability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FrameworkInfo_Capability,
        };
        unsafe {
            instance.get(|| {
                FrameworkInfo_Capability {
                    field_type: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.FrameworkInfo.Capability.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: FrameworkInfo_Capability_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> FrameworkInfo_Capability_Type {
        self.field_type.unwrap_or(FrameworkInfo_Capability_Type::REVOCABLE_RESOURCES)
    }
}

impl ::protobuf::Message for FrameworkInfo_Capability {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v as i32));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<FrameworkInfo_Capability>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FrameworkInfo_Capability {
    fn new() -> FrameworkInfo_Capability {
        FrameworkInfo_Capability::new()
    }

    fn descriptor_static(_: ::std::option::Option<FrameworkInfo_Capability>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    FrameworkInfo_Capability::has_field_type,
                    FrameworkInfo_Capability::get_field_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FrameworkInfo_Capability>(
                    "FrameworkInfo_Capability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FrameworkInfo_Capability {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for FrameworkInfo_Capability {
    fn eq(&self, other: &FrameworkInfo_Capability) -> bool {
        self.field_type == other.field_type &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for FrameworkInfo_Capability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FrameworkInfo_Capability_Type {
    REVOCABLE_RESOURCES = 1,
}

impl ::protobuf::ProtobufEnum for FrameworkInfo_Capability_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FrameworkInfo_Capability_Type> {
        match value {
            1 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::REVOCABLE_RESOURCES),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<FrameworkInfo_Capability_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FrameworkInfo_Capability_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FrameworkInfo_Capability_Type {
}

#[derive(Clone,Default)]
pub struct HealthCheck {
    // message fields
    http: ::protobuf::SingularPtrField<HealthCheck_HTTP>,
    delay_seconds: ::std::option::Option<f64>,
    interval_seconds: ::std::option::Option<f64>,
    timeout_seconds: ::std::option::Option<f64>,
    consecutive_failures: ::std::option::Option<u32>,
    grace_period_seconds: ::std::option::Option<f64>,
    command: ::protobuf::SingularPtrField<CommandInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl HealthCheck {
    pub fn new() -> HealthCheck {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HealthCheck {
        static mut instance: ::protobuf::lazy::Lazy<HealthCheck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HealthCheck,
        };
        unsafe {
            instance.get(|| {
                HealthCheck {
                    http: ::protobuf::SingularPtrField::none(),
                    delay_seconds: ::std::option::Option::None,
                    interval_seconds: ::std::option::Option::None,
                    timeout_seconds: ::std::option::Option::None,
                    consecutive_failures: ::std::option::Option::None,
                    grace_period_seconds: ::std::option::Option::None,
                    command: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.HealthCheck.HTTP http = 1;

    pub fn clear_http(&mut self) {
        self.http.clear();
    }

    pub fn has_http(&self) -> bool {
        self.http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: HealthCheck_HTTP) {
        self.http = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http<'a>(&'a mut self) -> &'a mut HealthCheck_HTTP {
        if self.http.is_none() {
            self.http.set_default();
        };
        self.http.as_mut().unwrap()
    }

    // Take field
    pub fn take_http(&mut self) -> HealthCheck_HTTP {
        self.http.take().unwrap_or_else(|| HealthCheck_HTTP::new())
    }

    pub fn get_http<'a>(&'a self) -> &'a HealthCheck_HTTP {
        self.http.as_ref().unwrap_or_else(|| HealthCheck_HTTP::default_instance())
    }

    // optional double delay_seconds = 2;

    pub fn clear_delay_seconds(&mut self) {
        self.delay_seconds = ::std::option::Option::None;
    }

    pub fn has_delay_seconds(&self) -> bool {
        self.delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_seconds(&mut self, v: f64) {
        self.delay_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_delay_seconds<'a>(&self) -> f64 {
        self.delay_seconds.unwrap_or(15f64)
    }

    // optional double interval_seconds = 3;

    pub fn clear_interval_seconds(&mut self) {
        self.interval_seconds = ::std::option::Option::None;
    }

    pub fn has_interval_seconds(&self) -> bool {
        self.interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval_seconds(&mut self, v: f64) {
        self.interval_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_interval_seconds<'a>(&self) -> f64 {
        self.interval_seconds.unwrap_or(10f64)
    }

    // optional double timeout_seconds = 4;

    pub fn clear_timeout_seconds(&mut self) {
        self.timeout_seconds = ::std::option::Option::None;
    }

    pub fn has_timeout_seconds(&self) -> bool {
        self.timeout_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_seconds(&mut self, v: f64) {
        self.timeout_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_timeout_seconds<'a>(&self) -> f64 {
        self.timeout_seconds.unwrap_or(20f64)
    }

    // optional uint32 consecutive_failures = 5;

    pub fn clear_consecutive_failures(&mut self) {
        self.consecutive_failures = ::std::option::Option::None;
    }

    pub fn has_consecutive_failures(&self) -> bool {
        self.consecutive_failures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consecutive_failures(&mut self, v: u32) {
        self.consecutive_failures = ::std::option::Option::Some(v);
    }

    pub fn get_consecutive_failures<'a>(&self) -> u32 {
        self.consecutive_failures.unwrap_or(3u32)
    }

    // optional double grace_period_seconds = 6;

    pub fn clear_grace_period_seconds(&mut self) {
        self.grace_period_seconds = ::std::option::Option::None;
    }

    pub fn has_grace_period_seconds(&self) -> bool {
        self.grace_period_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grace_period_seconds(&mut self, v: f64) {
        self.grace_period_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_grace_period_seconds<'a>(&self) -> f64 {
        self.grace_period_seconds.unwrap_or(10f64)
    }

    // optional .mesos.CommandInfo command = 7;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command<'a>(&'a mut self) -> &'a mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        };
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command<'a>(&'a self) -> &'a CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }
}

impl ::protobuf::Message for HealthCheck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.http.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.delay_seconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.interval_seconds = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.timeout_seconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.consecutive_failures = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.grace_period_seconds = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.command.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.http.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.delay_seconds.is_some() {
            my_size += 9;
        };
        if self.interval_seconds.is_some() {
            my_size += 9;
        };
        if self.timeout_seconds.is_some() {
            my_size += 9;
        };
        for value in self.consecutive_failures.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.grace_period_seconds.is_some() {
            my_size += 9;
        };
        for value in self.command.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.http.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.delay_seconds {
            try!(os.write_double(2, v));
        };
        if let Some(v) = self.interval_seconds {
            try!(os.write_double(3, v));
        };
        if let Some(v) = self.timeout_seconds {
            try!(os.write_double(4, v));
        };
        if let Some(v) = self.consecutive_failures {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.grace_period_seconds {
            try!(os.write_double(6, v));
        };
        if let Some(v) = self.command.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<HealthCheck>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HealthCheck {
    fn new() -> HealthCheck {
        HealthCheck::new()
    }

    fn descriptor_static(_: ::std::option::Option<HealthCheck>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "http",
                    HealthCheck::has_http,
                    HealthCheck::get_http,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "delay_seconds",
                    HealthCheck::has_delay_seconds,
                    HealthCheck::get_delay_seconds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "interval_seconds",
                    HealthCheck::has_interval_seconds,
                    HealthCheck::get_interval_seconds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "timeout_seconds",
                    HealthCheck::has_timeout_seconds,
                    HealthCheck::get_timeout_seconds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "consecutive_failures",
                    HealthCheck::has_consecutive_failures,
                    HealthCheck::get_consecutive_failures,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "grace_period_seconds",
                    HealthCheck::has_grace_period_seconds,
                    HealthCheck::get_grace_period_seconds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "command",
                    HealthCheck::has_command,
                    HealthCheck::get_command,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HealthCheck>(
                    "HealthCheck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HealthCheck {
    fn clear(&mut self) {
        self.clear_http();
        self.clear_delay_seconds();
        self.clear_interval_seconds();
        self.clear_timeout_seconds();
        self.clear_consecutive_failures();
        self.clear_grace_period_seconds();
        self.clear_command();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for HealthCheck {
    fn eq(&self, other: &HealthCheck) -> bool {
        self.http == other.http &&
        self.delay_seconds == other.delay_seconds &&
        self.interval_seconds == other.interval_seconds &&
        self.timeout_seconds == other.timeout_seconds &&
        self.consecutive_failures == other.consecutive_failures &&
        self.grace_period_seconds == other.grace_period_seconds &&
        self.command == other.command &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for HealthCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct HealthCheck_HTTP {
    // message fields
    port: ::std::option::Option<u32>,
    path: ::protobuf::SingularField<::std::string::String>,
    statuses: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl HealthCheck_HTTP {
    pub fn new() -> HealthCheck_HTTP {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HealthCheck_HTTP {
        static mut instance: ::protobuf::lazy::Lazy<HealthCheck_HTTP> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HealthCheck_HTTP,
        };
        unsafe {
            instance.get(|| {
                HealthCheck_HTTP {
                    port: ::std::option::Option::None,
                    path: ::protobuf::SingularField::none(),
                    statuses: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint32 port = 1;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port<'a>(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "/",
        }
    }

    // repeated uint32 statuses = 4;

    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::std::vec::Vec<u32>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.statuses, ::std::vec::Vec::new())
    }

    pub fn get_statuses<'a>(&'a self) -> &'a [u32] {
        &self.statuses
    }
}

impl ::protobuf::Message for HealthCheck_HTTP {
    fn is_initialized(&self) -> bool {
        if self.port.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.path.set_default();
                    try!(is.read_string_into(tmp))
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.statuses));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.statuses.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.port {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.path.as_ref() {
            try!(os.write_string(2, &v));
        };
        for v in self.statuses.iter() {
            try!(os.write_uint32(4, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<HealthCheck_HTTP>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HealthCheck_HTTP {
    fn new() -> HealthCheck_HTTP {
        HealthCheck_HTTP::new()
    }

    fn descriptor_static(_: ::std::option::Option<HealthCheck_HTTP>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "port",
                    HealthCheck_HTTP::has_port,
                    HealthCheck_HTTP::get_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "path",
                    HealthCheck_HTTP::has_path,
                    HealthCheck_HTTP::get_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "statuses",
                    HealthCheck_HTTP::get_statuses,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HealthCheck_HTTP>(
                    "HealthCheck_HTTP",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HealthCheck_HTTP {
    fn clear(&mut self) {
        self.clear_port();
        self.clear_path();
        self.clear_statuses();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for HealthCheck_HTTP {
    fn eq(&self, other: &HealthCheck_HTTP) -> bool {
        self.port == other.port &&
        self.path == other.path &&
        self.statuses == other.statuses &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for HealthCheck_HTTP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CommandInfo {
    // message fields
    container: ::protobuf::SingularPtrField<CommandInfo_ContainerInfo>,
    uris: ::protobuf::RepeatedField<CommandInfo_URI>,
    environment: ::protobuf::SingularPtrField<Environment>,
    shell: ::std::option::Option<bool>,
    value: ::protobuf::SingularField<::std::string::String>,
    arguments: ::protobuf::RepeatedField<::std::string::String>,
    user: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CommandInfo {
    pub fn new() -> CommandInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CommandInfo {
        static mut instance: ::protobuf::lazy::Lazy<CommandInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandInfo,
        };
        unsafe {
            instance.get(|| {
                CommandInfo {
                    container: ::protobuf::SingularPtrField::none(),
                    uris: ::protobuf::RepeatedField::new(),
                    environment: ::protobuf::SingularPtrField::none(),
                    shell: ::std::option::Option::None,
                    value: ::protobuf::SingularField::none(),
                    arguments: ::protobuf::RepeatedField::new(),
                    user: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.CommandInfo.ContainerInfo container = 4;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: CommandInfo_ContainerInfo) {
        self.container = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container<'a>(&'a mut self) -> &'a mut CommandInfo_ContainerInfo {
        if self.container.is_none() {
            self.container.set_default();
        };
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> CommandInfo_ContainerInfo {
        self.container.take().unwrap_or_else(|| CommandInfo_ContainerInfo::new())
    }

    pub fn get_container<'a>(&'a self) -> &'a CommandInfo_ContainerInfo {
        self.container.as_ref().unwrap_or_else(|| CommandInfo_ContainerInfo::default_instance())
    }

    // repeated .mesos.CommandInfo.URI uris = 1;

    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: ::protobuf::RepeatedField<CommandInfo_URI>) {
        self.uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uris<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CommandInfo_URI> {
        &mut self.uris
    }

    // Take field
    pub fn take_uris(&mut self) -> ::protobuf::RepeatedField<CommandInfo_URI> {
        ::std::mem::replace(&mut self.uris, ::protobuf::RepeatedField::new())
    }

    pub fn get_uris<'a>(&'a self) -> &'a [CommandInfo_URI] {
        &self.uris
    }

    // optional .mesos.Environment environment = 2;

    pub fn clear_environment(&mut self) {
        self.environment.clear();
    }

    pub fn has_environment(&self) -> bool {
        self.environment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: Environment) {
        self.environment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_environment<'a>(&'a mut self) -> &'a mut Environment {
        if self.environment.is_none() {
            self.environment.set_default();
        };
        self.environment.as_mut().unwrap()
    }

    // Take field
    pub fn take_environment(&mut self) -> Environment {
        self.environment.take().unwrap_or_else(|| Environment::new())
    }

    pub fn get_environment<'a>(&'a self) -> &'a Environment {
        self.environment.as_ref().unwrap_or_else(|| Environment::default_instance())
    }

    // optional bool shell = 6;

    pub fn clear_shell(&mut self) {
        self.shell = ::std::option::Option::None;
    }

    pub fn has_shell(&self) -> bool {
        self.shell.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shell(&mut self, v: bool) {
        self.shell = ::std::option::Option::Some(v);
    }

    pub fn get_shell<'a>(&self) -> bool {
        self.shell.unwrap_or(true)
    }

    // optional string value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string arguments = 7;

    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }

    pub fn get_arguments<'a>(&'a self) -> &'a [::std::string::String] {
        &self.arguments
    }

    // optional string user = 5;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        };
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user<'a>(&'a self) -> &'a str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CommandInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.container.set_default();
                    try!(is.merge_message(tmp))
                },
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.uris));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.environment.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.shell = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.arguments));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.user.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.container.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.uris.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.environment.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.shell.is_some() {
            my_size += 2;
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.arguments.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in self.user.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.container.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.uris.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.environment.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.shell {
            try!(os.write_bool(6, v));
        };
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(3, &v));
        };
        for v in self.arguments.iter() {
            try!(os.write_string(7, &v));
        };
        if let Some(v) = self.user.as_ref() {
            try!(os.write_string(5, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CommandInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CommandInfo {
    fn new() -> CommandInfo {
        CommandInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CommandInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "container",
                    CommandInfo::has_container,
                    CommandInfo::get_container,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "uris",
                    CommandInfo::get_uris,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "environment",
                    CommandInfo::has_environment,
                    CommandInfo::get_environment,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "shell",
                    CommandInfo::has_shell,
                    CommandInfo::get_shell,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    CommandInfo::has_value,
                    CommandInfo::get_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "arguments",
                    CommandInfo::get_arguments,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "user",
                    CommandInfo::has_user,
                    CommandInfo::get_user,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandInfo>(
                    "CommandInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CommandInfo {
    fn clear(&mut self) {
        self.clear_container();
        self.clear_uris();
        self.clear_environment();
        self.clear_shell();
        self.clear_value();
        self.clear_arguments();
        self.clear_user();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CommandInfo {
    fn eq(&self, other: &CommandInfo) -> bool {
        self.container == other.container &&
        self.uris == other.uris &&
        self.environment == other.environment &&
        self.shell == other.shell &&
        self.value == other.value &&
        self.arguments == other.arguments &&
        self.user == other.user &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CommandInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CommandInfo_URI {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    executable: ::std::option::Option<bool>,
    extract: ::std::option::Option<bool>,
    cache: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CommandInfo_URI {
    pub fn new() -> CommandInfo_URI {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CommandInfo_URI {
        static mut instance: ::protobuf::lazy::Lazy<CommandInfo_URI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandInfo_URI,
        };
        unsafe {
            instance.get(|| {
                CommandInfo_URI {
                    value: ::protobuf::SingularField::none(),
                    executable: ::std::option::Option::None,
                    extract: ::std::option::Option::None,
                    cache: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool executable = 2;

    pub fn clear_executable(&mut self) {
        self.executable = ::std::option::Option::None;
    }

    pub fn has_executable(&self) -> bool {
        self.executable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executable(&mut self, v: bool) {
        self.executable = ::std::option::Option::Some(v);
    }

    pub fn get_executable<'a>(&self) -> bool {
        self.executable.unwrap_or(false)
    }

    // optional bool extract = 3;

    pub fn clear_extract(&mut self) {
        self.extract = ::std::option::Option::None;
    }

    pub fn has_extract(&self) -> bool {
        self.extract.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extract(&mut self, v: bool) {
        self.extract = ::std::option::Option::Some(v);
    }

    pub fn get_extract<'a>(&self) -> bool {
        self.extract.unwrap_or(true)
    }

    // optional bool cache = 4;

    pub fn clear_cache(&mut self) {
        self.cache = ::std::option::Option::None;
    }

    pub fn has_cache(&self) -> bool {
        self.cache.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache(&mut self, v: bool) {
        self.cache = ::std::option::Option::Some(v);
    }

    pub fn get_cache<'a>(&self) -> bool {
        self.cache.unwrap_or(false)
    }
}

impl ::protobuf::Message for CommandInfo_URI {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.executable = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.extract = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.cache = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.executable.is_some() {
            my_size += 2;
        };
        if self.extract.is_some() {
            my_size += 2;
        };
        if self.cache.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.executable {
            try!(os.write_bool(2, v));
        };
        if let Some(v) = self.extract {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.cache {
            try!(os.write_bool(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CommandInfo_URI>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CommandInfo_URI {
    fn new() -> CommandInfo_URI {
        CommandInfo_URI::new()
    }

    fn descriptor_static(_: ::std::option::Option<CommandInfo_URI>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    CommandInfo_URI::has_value,
                    CommandInfo_URI::get_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "executable",
                    CommandInfo_URI::has_executable,
                    CommandInfo_URI::get_executable,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "extract",
                    CommandInfo_URI::has_extract,
                    CommandInfo_URI::get_extract,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "cache",
                    CommandInfo_URI::has_cache,
                    CommandInfo_URI::get_cache,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandInfo_URI>(
                    "CommandInfo_URI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CommandInfo_URI {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_executable();
        self.clear_extract();
        self.clear_cache();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CommandInfo_URI {
    fn eq(&self, other: &CommandInfo_URI) -> bool {
        self.value == other.value &&
        self.executable == other.executable &&
        self.extract == other.extract &&
        self.cache == other.cache &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CommandInfo_URI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CommandInfo_ContainerInfo {
    // message fields
    image: ::protobuf::SingularField<::std::string::String>,
    options: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl CommandInfo_ContainerInfo {
    pub fn new() -> CommandInfo_ContainerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CommandInfo_ContainerInfo {
        static mut instance: ::protobuf::lazy::Lazy<CommandInfo_ContainerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandInfo_ContainerInfo,
        };
        unsafe {
            instance.get(|| {
                CommandInfo_ContainerInfo {
                    image: ::protobuf::SingularField::none(),
                    options: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string image = 1;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        };
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_image<'a>(&'a self) -> &'a str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string options = 2;

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }

    pub fn get_options<'a>(&'a self) -> &'a [::std::string::String] {
        &self.options
    }
}

impl ::protobuf::Message for CommandInfo_ContainerInfo {
    fn is_initialized(&self) -> bool {
        if self.image.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.image.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.options));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.image.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.options.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.image.as_ref() {
            try!(os.write_string(1, &v));
        };
        for v in self.options.iter() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CommandInfo_ContainerInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CommandInfo_ContainerInfo {
    fn new() -> CommandInfo_ContainerInfo {
        CommandInfo_ContainerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CommandInfo_ContainerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "image",
                    CommandInfo_ContainerInfo::has_image,
                    CommandInfo_ContainerInfo::get_image,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "options",
                    CommandInfo_ContainerInfo::get_options,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandInfo_ContainerInfo>(
                    "CommandInfo_ContainerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CommandInfo_ContainerInfo {
    fn clear(&mut self) {
        self.clear_image();
        self.clear_options();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CommandInfo_ContainerInfo {
    fn eq(&self, other: &CommandInfo_ContainerInfo) -> bool {
        self.image == other.image &&
        self.options == other.options &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CommandInfo_ContainerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ExecutorInfo {
    // message fields
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    command: ::protobuf::SingularPtrField<CommandInfo>,
    container: ::protobuf::SingularPtrField<ContainerInfo>,
    resources: ::protobuf::RepeatedField<Resource>,
    name: ::protobuf::SingularField<::std::string::String>,
    source: ::protobuf::SingularField<::std::string::String>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    discovery: ::protobuf::SingularPtrField<DiscoveryInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ExecutorInfo {
    pub fn new() -> ExecutorInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ExecutorInfo {
        static mut instance: ::protobuf::lazy::Lazy<ExecutorInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecutorInfo,
        };
        unsafe {
            instance.get(|| {
                ExecutorInfo {
                    executor_id: ::protobuf::SingularPtrField::none(),
                    framework_id: ::protobuf::SingularPtrField::none(),
                    command: ::protobuf::SingularPtrField::none(),
                    container: ::protobuf::SingularPtrField::none(),
                    resources: ::protobuf::RepeatedField::new(),
                    name: ::protobuf::SingularField::none(),
                    source: ::protobuf::SingularField::none(),
                    data: ::protobuf::SingularField::none(),
                    discovery: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.ExecutorID executor_id = 1;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id<'a>(&'a mut self) -> &'a mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        };
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id<'a>(&'a self) -> &'a ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    // optional .mesos.FrameworkID framework_id = 8;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id<'a>(&'a mut self) -> &'a mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        };
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id<'a>(&'a self) -> &'a FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    // required .mesos.CommandInfo command = 7;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command<'a>(&'a mut self) -> &'a mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        };
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command<'a>(&'a self) -> &'a CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }

    // optional .mesos.ContainerInfo container = 11;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ContainerInfo) {
        self.container = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container<'a>(&'a mut self) -> &'a mut ContainerInfo {
        if self.container.is_none() {
            self.container.set_default();
        };
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ContainerInfo {
        self.container.take().unwrap_or_else(|| ContainerInfo::new())
    }

    pub fn get_container<'a>(&'a self) -> &'a ContainerInfo {
        self.container.as_ref().unwrap_or_else(|| ContainerInfo::default_instance())
    }

    // repeated .mesos.Resource resources = 5;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }

    // optional string name = 9;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string source = 10;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.source.is_none() {
            self.source.set_default();
        };
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_source<'a>(&'a self) -> &'a str {
        match self.source.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes data = 4;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data<'a>(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .mesos.DiscoveryInfo discovery = 12;

    pub fn clear_discovery(&mut self) {
        self.discovery.clear();
    }

    pub fn has_discovery(&self) -> bool {
        self.discovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discovery(&mut self, v: DiscoveryInfo) {
        self.discovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovery<'a>(&'a mut self) -> &'a mut DiscoveryInfo {
        if self.discovery.is_none() {
            self.discovery.set_default();
        };
        self.discovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_discovery(&mut self) -> DiscoveryInfo {
        self.discovery.take().unwrap_or_else(|| DiscoveryInfo::new())
    }

    pub fn get_discovery<'a>(&'a self) -> &'a DiscoveryInfo {
        self.discovery.as_ref().unwrap_or_else(|| DiscoveryInfo::default_instance())
    }
}

impl ::protobuf::Message for ExecutorInfo {
    fn is_initialized(&self) -> bool {
        if self.executor_id.is_none() {
            return false;
        };
        if self.command.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.executor_id.set_default();
                    try!(is.merge_message(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.framework_id.set_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.command.set_default();
                    try!(is.merge_message(tmp))
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.container.set_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.source.set_default();
                    try!(is.read_string_into(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.data.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.discovery.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.executor_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.framework_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.command.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.container.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in self.source.iter() {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in self.discovery.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.executor_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.framework_id.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.command.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.container.as_ref() {
            try!(os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(9, &v));
        };
        if let Some(v) = self.source.as_ref() {
            try!(os.write_string(10, &v));
        };
        if let Some(v) = self.data.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        if let Some(v) = self.discovery.as_ref() {
            try!(os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ExecutorInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ExecutorInfo {
    fn new() -> ExecutorInfo {
        ExecutorInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ExecutorInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor_id",
                    ExecutorInfo::has_executor_id,
                    ExecutorInfo::get_executor_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "framework_id",
                    ExecutorInfo::has_framework_id,
                    ExecutorInfo::get_framework_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "command",
                    ExecutorInfo::has_command,
                    ExecutorInfo::get_command,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "container",
                    ExecutorInfo::has_container,
                    ExecutorInfo::get_container,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    ExecutorInfo::get_resources,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    ExecutorInfo::has_name,
                    ExecutorInfo::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "source",
                    ExecutorInfo::has_source,
                    ExecutorInfo::get_source,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "data",
                    ExecutorInfo::has_data,
                    ExecutorInfo::get_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "discovery",
                    ExecutorInfo::has_discovery,
                    ExecutorInfo::get_discovery,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecutorInfo>(
                    "ExecutorInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ExecutorInfo {
    fn clear(&mut self) {
        self.clear_executor_id();
        self.clear_framework_id();
        self.clear_command();
        self.clear_container();
        self.clear_resources();
        self.clear_name();
        self.clear_source();
        self.clear_data();
        self.clear_discovery();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ExecutorInfo {
    fn eq(&self, other: &ExecutorInfo) -> bool {
        self.executor_id == other.executor_id &&
        self.framework_id == other.framework_id &&
        self.command == other.command &&
        self.container == other.container &&
        self.resources == other.resources &&
        self.name == other.name &&
        self.source == other.source &&
        self.data == other.data &&
        self.discovery == other.discovery &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ExecutorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct MasterInfo {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    ip: ::std::option::Option<u32>,
    port: ::std::option::Option<u32>,
    pid: ::protobuf::SingularField<::std::string::String>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    address: ::protobuf::SingularPtrField<Address>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl MasterInfo {
    pub fn new() -> MasterInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MasterInfo {
        static mut instance: ::protobuf::lazy::Lazy<MasterInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MasterInfo,
        };
        unsafe {
            instance.get(|| {
                MasterInfo {
                    id: ::protobuf::SingularField::none(),
                    ip: ::std::option::Option::None,
                    port: ::std::option::Option::None,
                    pid: ::protobuf::SingularField::none(),
                    hostname: ::protobuf::SingularField::none(),
                    version: ::protobuf::SingularField::none(),
                    address: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint32 ip = 2;

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    pub fn get_ip<'a>(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    // required uint32 port = 3;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port<'a>(&self) -> u32 {
        self.port.unwrap_or(5050u32)
    }

    // optional string pid = 4;

    pub fn clear_pid(&mut self) {
        self.pid.clear();
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: ::std::string::String) {
        self.pid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pid<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.pid.is_none() {
            self.pid.set_default();
        };
        self.pid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pid(&mut self) -> ::std::string::String {
        self.pid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pid<'a>(&'a self) -> &'a str {
        match self.pid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string hostname = 5;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string version = 6;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        };
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_version<'a>(&'a self) -> &'a str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.Address address = 7;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address<'a>(&'a mut self) -> &'a mut Address {
        if self.address.is_none() {
            self.address.set_default();
        };
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }

    pub fn get_address<'a>(&'a self) -> &'a Address {
        self.address.as_ref().unwrap_or_else(|| Address::default_instance())
    }
}

impl ::protobuf::Message for MasterInfo {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        if self.ip.is_none() {
            return false;
        };
        if self.port.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.id.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.pid.set_default();
                    try!(is.read_string_into(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.hostname.set_default();
                    try!(is.read_string_into(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.version.set_default();
                    try!(is.read_string_into(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.address.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.ip.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.pid.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.version.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.address.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.ip {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.port {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.pid.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(5, &v));
        };
        if let Some(v) = self.version.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.address.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<MasterInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MasterInfo {
    fn new() -> MasterInfo {
        MasterInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<MasterInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "id",
                    MasterInfo::has_id,
                    MasterInfo::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "ip",
                    MasterInfo::has_ip,
                    MasterInfo::get_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "port",
                    MasterInfo::has_port,
                    MasterInfo::get_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "pid",
                    MasterInfo::has_pid,
                    MasterInfo::get_pid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    MasterInfo::has_hostname,
                    MasterInfo::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "version",
                    MasterInfo::has_version,
                    MasterInfo::get_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "address",
                    MasterInfo::has_address,
                    MasterInfo::get_address,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MasterInfo>(
                    "MasterInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MasterInfo {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_ip();
        self.clear_port();
        self.clear_pid();
        self.clear_hostname();
        self.clear_version();
        self.clear_address();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for MasterInfo {
    fn eq(&self, other: &MasterInfo) -> bool {
        self.id == other.id &&
        self.ip == other.ip &&
        self.port == other.port &&
        self.pid == other.pid &&
        self.hostname == other.hostname &&
        self.version == other.version &&
        self.address == other.address &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for MasterInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SlaveInfo {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    resources: ::protobuf::RepeatedField<Resource>,
    attributes: ::protobuf::RepeatedField<Attribute>,
    id: ::protobuf::SingularPtrField<SlaveID>,
    checkpoint: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl SlaveInfo {
    pub fn new() -> SlaveInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SlaveInfo {
        static mut instance: ::protobuf::lazy::Lazy<SlaveInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SlaveInfo,
        };
        unsafe {
            instance.get(|| {
                SlaveInfo {
                    hostname: ::protobuf::SingularField::none(),
                    port: ::std::option::Option::None,
                    resources: ::protobuf::RepeatedField::new(),
                    attributes: ::protobuf::RepeatedField::new(),
                    id: ::protobuf::SingularPtrField::none(),
                    checkpoint: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string hostname = 1;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 port = 8;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port<'a>(&self) -> i32 {
        self.port.unwrap_or(5051i32)
    }

    // repeated .mesos.Resource resources = 3;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }

    // repeated .mesos.Attribute attributes = 5;

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<Attribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Attribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<Attribute> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    pub fn get_attributes<'a>(&'a self) -> &'a [Attribute] {
        &self.attributes
    }

    // optional .mesos.SlaveID id = 6;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: SlaveID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut SlaveID {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> SlaveID {
        self.id.take().unwrap_or_else(|| SlaveID::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a SlaveID {
        self.id.as_ref().unwrap_or_else(|| SlaveID::default_instance())
    }

    // optional bool checkpoint = 7;

    pub fn clear_checkpoint(&mut self) {
        self.checkpoint = ::std::option::Option::None;
    }

    pub fn has_checkpoint(&self) -> bool {
        self.checkpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpoint(&mut self, v: bool) {
        self.checkpoint = ::std::option::Option::Some(v);
    }

    pub fn get_checkpoint<'a>(&self) -> bool {
        self.checkpoint.unwrap_or(false)
    }
}

impl ::protobuf::Message for SlaveInfo {
    fn is_initialized(&self) -> bool {
        if self.hostname.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.hostname.set_default();
                    try!(is.read_string_into(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.id.set_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.checkpoint = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.attributes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.checkpoint.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.port {
            try!(os.write_int32(8, v));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.attributes.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.id.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.checkpoint {
            try!(os.write_bool(7, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SlaveInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SlaveInfo {
    fn new() -> SlaveInfo {
        SlaveInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<SlaveInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    SlaveInfo::has_hostname,
                    SlaveInfo::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "port",
                    SlaveInfo::has_port,
                    SlaveInfo::get_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    SlaveInfo::get_resources,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "attributes",
                    SlaveInfo::get_attributes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "id",
                    SlaveInfo::has_id,
                    SlaveInfo::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "checkpoint",
                    SlaveInfo::has_checkpoint,
                    SlaveInfo::get_checkpoint,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SlaveInfo>(
                    "SlaveInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SlaveInfo {
    fn clear(&mut self) {
        self.clear_hostname();
        self.clear_port();
        self.clear_resources();
        self.clear_attributes();
        self.clear_id();
        self.clear_checkpoint();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SlaveInfo {
    fn eq(&self, other: &SlaveInfo) -> bool {
        self.hostname == other.hostname &&
        self.port == other.port &&
        self.resources == other.resources &&
        self.attributes == other.attributes &&
        self.id == other.id &&
        self.checkpoint == other.checkpoint &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SlaveInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value {
    // message fields
    field_type: ::std::option::Option<Value_Type>,
    scalar: ::protobuf::SingularPtrField<Value_Scalar>,
    ranges: ::protobuf::SingularPtrField<Value_Ranges>,
    set: ::protobuf::SingularPtrField<Value_Set>,
    text: ::protobuf::SingularPtrField<Value_Text>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Value {
    pub fn new() -> Value {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value {
        static mut instance: ::protobuf::lazy::Lazy<Value> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value,
        };
        unsafe {
            instance.get(|| {
                Value {
                    field_type: ::std::option::Option::None,
                    scalar: ::protobuf::SingularPtrField::none(),
                    ranges: ::protobuf::SingularPtrField::none(),
                    set: ::protobuf::SingularPtrField::none(),
                    text: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.Value.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Value_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Value_Type {
        self.field_type.unwrap_or(Value_Type::SCALAR)
    }

    // optional .mesos.Value.Scalar scalar = 2;

    pub fn clear_scalar(&mut self) {
        self.scalar.clear();
    }

    pub fn has_scalar(&self) -> bool {
        self.scalar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scalar(&mut self, v: Value_Scalar) {
        self.scalar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scalar<'a>(&'a mut self) -> &'a mut Value_Scalar {
        if self.scalar.is_none() {
            self.scalar.set_default();
        };
        self.scalar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scalar(&mut self) -> Value_Scalar {
        self.scalar.take().unwrap_or_else(|| Value_Scalar::new())
    }

    pub fn get_scalar<'a>(&'a self) -> &'a Value_Scalar {
        self.scalar.as_ref().unwrap_or_else(|| Value_Scalar::default_instance())
    }

    // optional .mesos.Value.Ranges ranges = 3;

    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    pub fn has_ranges(&self) -> bool {
        self.ranges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: Value_Ranges) {
        self.ranges = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranges<'a>(&'a mut self) -> &'a mut Value_Ranges {
        if self.ranges.is_none() {
            self.ranges.set_default();
        };
        self.ranges.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranges(&mut self) -> Value_Ranges {
        self.ranges.take().unwrap_or_else(|| Value_Ranges::new())
    }

    pub fn get_ranges<'a>(&'a self) -> &'a Value_Ranges {
        self.ranges.as_ref().unwrap_or_else(|| Value_Ranges::default_instance())
    }

    // optional .mesos.Value.Set set = 4;

    pub fn clear_set(&mut self) {
        self.set.clear();
    }

    pub fn has_set(&self) -> bool {
        self.set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: Value_Set) {
        self.set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set<'a>(&'a mut self) -> &'a mut Value_Set {
        if self.set.is_none() {
            self.set.set_default();
        };
        self.set.as_mut().unwrap()
    }

    // Take field
    pub fn take_set(&mut self) -> Value_Set {
        self.set.take().unwrap_or_else(|| Value_Set::new())
    }

    pub fn get_set<'a>(&'a self) -> &'a Value_Set {
        self.set.as_ref().unwrap_or_else(|| Value_Set::default_instance())
    }

    // optional .mesos.Value.Text text = 5;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: Value_Text) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text<'a>(&'a mut self) -> &'a mut Value_Text {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> Value_Text {
        self.text.take().unwrap_or_else(|| Value_Text::new())
    }

    pub fn get_text<'a>(&'a self) -> &'a Value_Text {
        self.text.as_ref().unwrap_or_else(|| Value_Text::default_instance())
    }
}

impl ::protobuf::Message for Value {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.scalar.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.ranges.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.set.set_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.text.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.scalar.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.ranges.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.set.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.text.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v as i32));
        };
        if let Some(v) = self.scalar.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.ranges.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.set.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.text.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value {
    fn new() -> Value {
        Value::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    Value::has_field_type,
                    Value::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "scalar",
                    Value::has_scalar,
                    Value::get_scalar,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "ranges",
                    Value::has_ranges,
                    Value::get_ranges,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "set",
                    Value::has_set,
                    Value::get_set,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "text",
                    Value::has_text,
                    Value::get_text,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value>(
                    "Value",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_scalar();
        self.clear_ranges();
        self.clear_set();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value {
    fn eq(&self, other: &Value) -> bool {
        self.field_type == other.field_type &&
        self.scalar == other.scalar &&
        self.ranges == other.ranges &&
        self.set == other.set &&
        self.text == other.text &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value_Scalar {
    // message fields
    value: ::std::option::Option<f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Value_Scalar {
    pub fn new() -> Value_Scalar {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Scalar {
        static mut instance: ::protobuf::lazy::Lazy<Value_Scalar> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Scalar,
        };
        unsafe {
            instance.get(|| {
                Value_Scalar {
                    value: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required double value = 1;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value<'a>(&self) -> f64 {
        self.value.unwrap_or(0.)
    }
}

impl ::protobuf::Message for Value_Scalar {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value {
            try!(os.write_double(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value_Scalar>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Scalar {
    fn new() -> Value_Scalar {
        Value_Scalar::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Scalar>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "value",
                    Value_Scalar::has_value,
                    Value_Scalar::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Scalar>(
                    "Value_Scalar",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Scalar {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value_Scalar {
    fn eq(&self, other: &Value_Scalar) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value_Scalar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value_Range {
    // message fields
    begin: ::std::option::Option<u64>,
    end: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Value_Range {
    pub fn new() -> Value_Range {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Range {
        static mut instance: ::protobuf::lazy::Lazy<Value_Range> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Range,
        };
        unsafe {
            instance.get(|| {
                Value_Range {
                    begin: ::std::option::Option::None,
                    end: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint64 begin = 1;

    pub fn clear_begin(&mut self) {
        self.begin = ::std::option::Option::None;
    }

    pub fn has_begin(&self) -> bool {
        self.begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: u64) {
        self.begin = ::std::option::Option::Some(v);
    }

    pub fn get_begin<'a>(&self) -> u64 {
        self.begin.unwrap_or(0)
    }

    // required uint64 end = 2;

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: u64) {
        self.end = ::std::option::Option::Some(v);
    }

    pub fn get_end<'a>(&self) -> u64 {
        self.end.unwrap_or(0)
    }
}

impl ::protobuf::Message for Value_Range {
    fn is_initialized(&self) -> bool {
        if self.begin.is_none() {
            return false;
        };
        if self.end.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.begin = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.begin.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.end.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.begin {
            try!(os.write_uint64(1, v));
        };
        if let Some(v) = self.end {
            try!(os.write_uint64(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value_Range>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Range {
    fn new() -> Value_Range {
        Value_Range::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Range>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "begin",
                    Value_Range::has_begin,
                    Value_Range::get_begin,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "end",
                    Value_Range::has_end,
                    Value_Range::get_end,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Range>(
                    "Value_Range",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Range {
    fn clear(&mut self) {
        self.clear_begin();
        self.clear_end();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value_Range {
    fn eq(&self, other: &Value_Range) -> bool {
        self.begin == other.begin &&
        self.end == other.end &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value_Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value_Ranges {
    // message fields
    range: ::protobuf::RepeatedField<Value_Range>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Value_Ranges {
    pub fn new() -> Value_Ranges {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Ranges {
        static mut instance: ::protobuf::lazy::Lazy<Value_Ranges> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Ranges,
        };
        unsafe {
            instance.get(|| {
                Value_Ranges {
                    range: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.Value.Range range = 1;

    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: ::protobuf::RepeatedField<Value_Range>) {
        self.range = v;
    }

    // Mutable pointer to the field.
    pub fn mut_range<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Value_Range> {
        &mut self.range
    }

    // Take field
    pub fn take_range(&mut self) -> ::protobuf::RepeatedField<Value_Range> {
        ::std::mem::replace(&mut self.range, ::protobuf::RepeatedField::new())
    }

    pub fn get_range<'a>(&'a self) -> &'a [Value_Range] {
        &self.range
    }
}

impl ::protobuf::Message for Value_Ranges {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.range));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.range.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.range.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value_Ranges>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Ranges {
    fn new() -> Value_Ranges {
        Value_Ranges::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Ranges>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "range",
                    Value_Ranges::get_range,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Ranges>(
                    "Value_Ranges",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Ranges {
    fn clear(&mut self) {
        self.clear_range();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value_Ranges {
    fn eq(&self, other: &Value_Ranges) -> bool {
        self.range == other.range &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value_Ranges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value_Set {
    // message fields
    item: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Value_Set {
    pub fn new() -> Value_Set {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Set {
        static mut instance: ::protobuf::lazy::Lazy<Value_Set> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Set,
        };
        unsafe {
            instance.get(|| {
                Value_Set {
                    item: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated string item = 1;

    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.item = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.item
    }

    // Take field
    pub fn take_item(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.item, ::protobuf::RepeatedField::new())
    }

    pub fn get_item<'a>(&'a self) -> &'a [::std::string::String] {
        &self.item
    }
}

impl ::protobuf::Message for Value_Set {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.item));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.item.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.item.iter() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value_Set>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Set {
    fn new() -> Value_Set {
        Value_Set::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Set>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "item",
                    Value_Set::get_item,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Set>(
                    "Value_Set",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Set {
    fn clear(&mut self) {
        self.clear_item();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value_Set {
    fn eq(&self, other: &Value_Set) -> bool {
        self.item == other.item &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value_Set {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value_Text {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Value_Text {
    pub fn new() -> Value_Text {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Text {
        static mut instance: ::protobuf::lazy::Lazy<Value_Text> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Text,
        };
        unsafe {
            instance.get(|| {
                Value_Text {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Value_Text {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value_Text>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Text {
    fn new() -> Value_Text {
        Value_Text::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Text>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    Value_Text::has_value,
                    Value_Text::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Text>(
                    "Value_Text",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Text {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value_Text {
    fn eq(&self, other: &Value_Text) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value_Text {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Value_Type {
    SCALAR = 0,
    RANGES = 1,
    SET = 2,
    TEXT = 3,
}

impl ::protobuf::ProtobufEnum for Value_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Value_Type> {
        match value {
            0 => ::std::option::Option::Some(Value_Type::SCALAR),
            1 => ::std::option::Option::Some(Value_Type::RANGES),
            2 => ::std::option::Option::Some(Value_Type::SET),
            3 => ::std::option::Option::Some(Value_Type::TEXT),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<Value_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Value_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Value_Type {
}

#[derive(Clone,Default)]
pub struct Attribute {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<Value_Type>,
    scalar: ::protobuf::SingularPtrField<Value_Scalar>,
    ranges: ::protobuf::SingularPtrField<Value_Ranges>,
    set: ::protobuf::SingularPtrField<Value_Set>,
    text: ::protobuf::SingularPtrField<Value_Text>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Attribute {
    pub fn new() -> Attribute {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Attribute {
        static mut instance: ::protobuf::lazy::Lazy<Attribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attribute,
        };
        unsafe {
            instance.get(|| {
                Attribute {
                    name: ::protobuf::SingularField::none(),
                    field_type: ::std::option::Option::None,
                    scalar: ::protobuf::SingularPtrField::none(),
                    ranges: ::protobuf::SingularPtrField::none(),
                    set: ::protobuf::SingularPtrField::none(),
                    text: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .mesos.Value.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Value_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Value_Type {
        self.field_type.unwrap_or(Value_Type::SCALAR)
    }

    // optional .mesos.Value.Scalar scalar = 3;

    pub fn clear_scalar(&mut self) {
        self.scalar.clear();
    }

    pub fn has_scalar(&self) -> bool {
        self.scalar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scalar(&mut self, v: Value_Scalar) {
        self.scalar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scalar<'a>(&'a mut self) -> &'a mut Value_Scalar {
        if self.scalar.is_none() {
            self.scalar.set_default();
        };
        self.scalar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scalar(&mut self) -> Value_Scalar {
        self.scalar.take().unwrap_or_else(|| Value_Scalar::new())
    }

    pub fn get_scalar<'a>(&'a self) -> &'a Value_Scalar {
        self.scalar.as_ref().unwrap_or_else(|| Value_Scalar::default_instance())
    }

    // optional .mesos.Value.Ranges ranges = 4;

    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    pub fn has_ranges(&self) -> bool {
        self.ranges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: Value_Ranges) {
        self.ranges = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranges<'a>(&'a mut self) -> &'a mut Value_Ranges {
        if self.ranges.is_none() {
            self.ranges.set_default();
        };
        self.ranges.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranges(&mut self) -> Value_Ranges {
        self.ranges.take().unwrap_or_else(|| Value_Ranges::new())
    }

    pub fn get_ranges<'a>(&'a self) -> &'a Value_Ranges {
        self.ranges.as_ref().unwrap_or_else(|| Value_Ranges::default_instance())
    }

    // optional .mesos.Value.Set set = 6;

    pub fn clear_set(&mut self) {
        self.set.clear();
    }

    pub fn has_set(&self) -> bool {
        self.set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: Value_Set) {
        self.set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set<'a>(&'a mut self) -> &'a mut Value_Set {
        if self.set.is_none() {
            self.set.set_default();
        };
        self.set.as_mut().unwrap()
    }

    // Take field
    pub fn take_set(&mut self) -> Value_Set {
        self.set.take().unwrap_or_else(|| Value_Set::new())
    }

    pub fn get_set<'a>(&'a self) -> &'a Value_Set {
        self.set.as_ref().unwrap_or_else(|| Value_Set::default_instance())
    }

    // optional .mesos.Value.Text text = 5;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: Value_Text) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text<'a>(&'a mut self) -> &'a mut Value_Text {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> Value_Text {
        self.text.take().unwrap_or_else(|| Value_Text::new())
    }

    pub fn get_text<'a>(&'a self) -> &'a Value_Text {
        self.text.as_ref().unwrap_or_else(|| Value_Text::default_instance())
    }
}

impl ::protobuf::Message for Attribute {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.scalar.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.ranges.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.set.set_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.text.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in self.scalar.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.ranges.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.set.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.text.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.field_type {
            try!(os.write_enum(2, v as i32));
        };
        if let Some(v) = self.scalar.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.ranges.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.set.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.text.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Attribute>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Attribute {
    fn new() -> Attribute {
        Attribute::new()
    }

    fn descriptor_static(_: ::std::option::Option<Attribute>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Attribute::has_name,
                    Attribute::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    Attribute::has_field_type,
                    Attribute::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "scalar",
                    Attribute::has_scalar,
                    Attribute::get_scalar,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "ranges",
                    Attribute::has_ranges,
                    Attribute::get_ranges,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "set",
                    Attribute::has_set,
                    Attribute::get_set,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "text",
                    Attribute::has_text,
                    Attribute::get_text,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Attribute>(
                    "Attribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Attribute {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_field_type();
        self.clear_scalar();
        self.clear_ranges();
        self.clear_set();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Attribute {
    fn eq(&self, other: &Attribute) -> bool {
        self.name == other.name &&
        self.field_type == other.field_type &&
        self.scalar == other.scalar &&
        self.ranges == other.ranges &&
        self.set == other.set &&
        self.text == other.text &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Attribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<Value_Type>,
    scalar: ::protobuf::SingularPtrField<Value_Scalar>,
    ranges: ::protobuf::SingularPtrField<Value_Ranges>,
    set: ::protobuf::SingularPtrField<Value_Set>,
    role: ::protobuf::SingularField<::std::string::String>,
    reservation: ::protobuf::SingularPtrField<Resource_ReservationInfo>,
    disk: ::protobuf::SingularPtrField<Resource_DiskInfo>,
    revocable: ::protobuf::SingularPtrField<Resource_RevocableInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Resource {
    pub fn new() -> Resource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource {
        static mut instance: ::protobuf::lazy::Lazy<Resource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource,
        };
        unsafe {
            instance.get(|| {
                Resource {
                    name: ::protobuf::SingularField::none(),
                    field_type: ::std::option::Option::None,
                    scalar: ::protobuf::SingularPtrField::none(),
                    ranges: ::protobuf::SingularPtrField::none(),
                    set: ::protobuf::SingularPtrField::none(),
                    role: ::protobuf::SingularField::none(),
                    reservation: ::protobuf::SingularPtrField::none(),
                    disk: ::protobuf::SingularPtrField::none(),
                    revocable: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .mesos.Value.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Value_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Value_Type {
        self.field_type.unwrap_or(Value_Type::SCALAR)
    }

    // optional .mesos.Value.Scalar scalar = 3;

    pub fn clear_scalar(&mut self) {
        self.scalar.clear();
    }

    pub fn has_scalar(&self) -> bool {
        self.scalar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scalar(&mut self, v: Value_Scalar) {
        self.scalar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scalar<'a>(&'a mut self) -> &'a mut Value_Scalar {
        if self.scalar.is_none() {
            self.scalar.set_default();
        };
        self.scalar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scalar(&mut self) -> Value_Scalar {
        self.scalar.take().unwrap_or_else(|| Value_Scalar::new())
    }

    pub fn get_scalar<'a>(&'a self) -> &'a Value_Scalar {
        self.scalar.as_ref().unwrap_or_else(|| Value_Scalar::default_instance())
    }

    // optional .mesos.Value.Ranges ranges = 4;

    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    pub fn has_ranges(&self) -> bool {
        self.ranges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: Value_Ranges) {
        self.ranges = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranges<'a>(&'a mut self) -> &'a mut Value_Ranges {
        if self.ranges.is_none() {
            self.ranges.set_default();
        };
        self.ranges.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranges(&mut self) -> Value_Ranges {
        self.ranges.take().unwrap_or_else(|| Value_Ranges::new())
    }

    pub fn get_ranges<'a>(&'a self) -> &'a Value_Ranges {
        self.ranges.as_ref().unwrap_or_else(|| Value_Ranges::default_instance())
    }

    // optional .mesos.Value.Set set = 5;

    pub fn clear_set(&mut self) {
        self.set.clear();
    }

    pub fn has_set(&self) -> bool {
        self.set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: Value_Set) {
        self.set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set<'a>(&'a mut self) -> &'a mut Value_Set {
        if self.set.is_none() {
            self.set.set_default();
        };
        self.set.as_mut().unwrap()
    }

    // Take field
    pub fn take_set(&mut self) -> Value_Set {
        self.set.take().unwrap_or_else(|| Value_Set::new())
    }

    pub fn get_set<'a>(&'a self) -> &'a Value_Set {
        self.set.as_ref().unwrap_or_else(|| Value_Set::default_instance())
    }

    // optional string role = 6;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        };
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role<'a>(&'a self) -> &'a str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "*",
        }
    }

    // optional .mesos.Resource.ReservationInfo reservation = 8;

    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: Resource_ReservationInfo) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation<'a>(&'a mut self) -> &'a mut Resource_ReservationInfo {
        if self.reservation.is_none() {
            self.reservation.set_default();
        };
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> Resource_ReservationInfo {
        self.reservation.take().unwrap_or_else(|| Resource_ReservationInfo::new())
    }

    pub fn get_reservation<'a>(&'a self) -> &'a Resource_ReservationInfo {
        self.reservation.as_ref().unwrap_or_else(|| Resource_ReservationInfo::default_instance())
    }

    // optional .mesos.Resource.DiskInfo disk = 7;

    pub fn clear_disk(&mut self) {
        self.disk.clear();
    }

    pub fn has_disk(&self) -> bool {
        self.disk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disk(&mut self, v: Resource_DiskInfo) {
        self.disk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disk<'a>(&'a mut self) -> &'a mut Resource_DiskInfo {
        if self.disk.is_none() {
            self.disk.set_default();
        };
        self.disk.as_mut().unwrap()
    }

    // Take field
    pub fn take_disk(&mut self) -> Resource_DiskInfo {
        self.disk.take().unwrap_or_else(|| Resource_DiskInfo::new())
    }

    pub fn get_disk<'a>(&'a self) -> &'a Resource_DiskInfo {
        self.disk.as_ref().unwrap_or_else(|| Resource_DiskInfo::default_instance())
    }

    // optional .mesos.Resource.RevocableInfo revocable = 9;

    pub fn clear_revocable(&mut self) {
        self.revocable.clear();
    }

    pub fn has_revocable(&self) -> bool {
        self.revocable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revocable(&mut self, v: Resource_RevocableInfo) {
        self.revocable = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revocable<'a>(&'a mut self) -> &'a mut Resource_RevocableInfo {
        if self.revocable.is_none() {
            self.revocable.set_default();
        };
        self.revocable.as_mut().unwrap()
    }

    // Take field
    pub fn take_revocable(&mut self) -> Resource_RevocableInfo {
        self.revocable.take().unwrap_or_else(|| Resource_RevocableInfo::new())
    }

    pub fn get_revocable<'a>(&'a self) -> &'a Resource_RevocableInfo {
        self.revocable.as_ref().unwrap_or_else(|| Resource_RevocableInfo::default_instance())
    }
}

impl ::protobuf::Message for Resource {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.scalar.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.ranges.set_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.set.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.role.set_default();
                    try!(is.read_string_into(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.reservation.set_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.disk.set_default();
                    try!(is.merge_message(tmp))
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.revocable.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in self.scalar.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.ranges.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.set.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.role.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.reservation.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.disk.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.revocable.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.field_type {
            try!(os.write_enum(2, v as i32));
        };
        if let Some(v) = self.scalar.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.ranges.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.set.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.role.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.reservation.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.disk.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.revocable.as_ref() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource {
    fn new() -> Resource {
        Resource::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Resource::has_name,
                    Resource::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    Resource::has_field_type,
                    Resource::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "scalar",
                    Resource::has_scalar,
                    Resource::get_scalar,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "ranges",
                    Resource::has_ranges,
                    Resource::get_ranges,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "set",
                    Resource::has_set,
                    Resource::get_set,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "role",
                    Resource::has_role,
                    Resource::get_role,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "reservation",
                    Resource::has_reservation,
                    Resource::get_reservation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "disk",
                    Resource::has_disk,
                    Resource::get_disk,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "revocable",
                    Resource::has_revocable,
                    Resource::get_revocable,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource>(
                    "Resource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_field_type();
        self.clear_scalar();
        self.clear_ranges();
        self.clear_set();
        self.clear_role();
        self.clear_reservation();
        self.clear_disk();
        self.clear_revocable();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource {
    fn eq(&self, other: &Resource) -> bool {
        self.name == other.name &&
        self.field_type == other.field_type &&
        self.scalar == other.scalar &&
        self.ranges == other.ranges &&
        self.set == other.set &&
        self.role == other.role &&
        self.reservation == other.reservation &&
        self.disk == other.disk &&
        self.revocable == other.revocable &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource_ReservationInfo {
    // message fields
    principal: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Resource_ReservationInfo {
    pub fn new() -> Resource_ReservationInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_ReservationInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_ReservationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_ReservationInfo,
        };
        unsafe {
            instance.get(|| {
                Resource_ReservationInfo {
                    principal: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string principal = 1;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        };
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal<'a>(&'a self) -> &'a str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Resource_ReservationInfo {
    fn is_initialized(&self) -> bool {
        if self.principal.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.principal.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.principal.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.principal.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_ReservationInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_ReservationInfo {
    fn new() -> Resource_ReservationInfo {
        Resource_ReservationInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_ReservationInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "principal",
                    Resource_ReservationInfo::has_principal,
                    Resource_ReservationInfo::get_principal,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_ReservationInfo>(
                    "Resource_ReservationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_ReservationInfo {
    fn clear(&mut self) {
        self.clear_principal();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_ReservationInfo {
    fn eq(&self, other: &Resource_ReservationInfo) -> bool {
        self.principal == other.principal &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_ReservationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource_DiskInfo {
    // message fields
    persistence: ::protobuf::SingularPtrField<Resource_DiskInfo_Persistence>,
    volume: ::protobuf::SingularPtrField<Volume>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Resource_DiskInfo {
    pub fn new() -> Resource_DiskInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo,
        };
        unsafe {
            instance.get(|| {
                Resource_DiskInfo {
                    persistence: ::protobuf::SingularPtrField::none(),
                    volume: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;

    pub fn clear_persistence(&mut self) {
        self.persistence.clear();
    }

    pub fn has_persistence(&self) -> bool {
        self.persistence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistence(&mut self, v: Resource_DiskInfo_Persistence) {
        self.persistence = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistence<'a>(&'a mut self) -> &'a mut Resource_DiskInfo_Persistence {
        if self.persistence.is_none() {
            self.persistence.set_default();
        };
        self.persistence.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistence(&mut self) -> Resource_DiskInfo_Persistence {
        self.persistence.take().unwrap_or_else(|| Resource_DiskInfo_Persistence::new())
    }

    pub fn get_persistence<'a>(&'a self) -> &'a Resource_DiskInfo_Persistence {
        self.persistence.as_ref().unwrap_or_else(|| Resource_DiskInfo_Persistence::default_instance())
    }

    // optional .mesos.Volume volume = 2;

    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: Volume) {
        self.volume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume<'a>(&'a mut self) -> &'a mut Volume {
        if self.volume.is_none() {
            self.volume.set_default();
        };
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> Volume {
        self.volume.take().unwrap_or_else(|| Volume::new())
    }

    pub fn get_volume<'a>(&'a self) -> &'a Volume {
        self.volume.as_ref().unwrap_or_else(|| Volume::default_instance())
    }
}

impl ::protobuf::Message for Resource_DiskInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.persistence.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.volume.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.persistence.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.volume.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.persistence.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.volume.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_DiskInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo {
    fn new() -> Resource_DiskInfo {
        Resource_DiskInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "persistence",
                    Resource_DiskInfo::has_persistence,
                    Resource_DiskInfo::get_persistence,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "volume",
                    Resource_DiskInfo::has_volume,
                    Resource_DiskInfo::get_volume,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo>(
                    "Resource_DiskInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo {
    fn clear(&mut self) {
        self.clear_persistence();
        self.clear_volume();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_DiskInfo {
    fn eq(&self, other: &Resource_DiskInfo) -> bool {
        self.persistence == other.persistence &&
        self.volume == other.volume &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource_DiskInfo_Persistence {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Resource_DiskInfo_Persistence {
    pub fn new() -> Resource_DiskInfo_Persistence {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo_Persistence {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo_Persistence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo_Persistence,
        };
        unsafe {
            instance.get(|| {
                Resource_DiskInfo_Persistence {
                    id: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Resource_DiskInfo_Persistence {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.id.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_DiskInfo_Persistence>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo_Persistence {
    fn new() -> Resource_DiskInfo_Persistence {
        Resource_DiskInfo_Persistence::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo_Persistence>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "id",
                    Resource_DiskInfo_Persistence::has_id,
                    Resource_DiskInfo_Persistence::get_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo_Persistence>(
                    "Resource_DiskInfo_Persistence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo_Persistence {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_DiskInfo_Persistence {
    fn eq(&self, other: &Resource_DiskInfo_Persistence) -> bool {
        self.id == other.id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo_Persistence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource_RevocableInfo {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Resource_RevocableInfo {
    pub fn new() -> Resource_RevocableInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_RevocableInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_RevocableInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_RevocableInfo,
        };
        unsafe {
            instance.get(|| {
                Resource_RevocableInfo {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for Resource_RevocableInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_RevocableInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_RevocableInfo {
    fn new() -> Resource_RevocableInfo {
        Resource_RevocableInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_RevocableInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Resource_RevocableInfo>(
                    "Resource_RevocableInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_RevocableInfo {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_RevocableInfo {
    fn eq(&self, other: &Resource_RevocableInfo) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_RevocableInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TrafficControlStatistics {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    backlog: ::std::option::Option<u64>,
    bytes: ::std::option::Option<u64>,
    drops: ::std::option::Option<u64>,
    overlimits: ::std::option::Option<u64>,
    packets: ::std::option::Option<u64>,
    qlen: ::std::option::Option<u64>,
    ratebps: ::std::option::Option<u64>,
    ratepps: ::std::option::Option<u64>,
    requeues: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl TrafficControlStatistics {
    pub fn new() -> TrafficControlStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TrafficControlStatistics {
        static mut instance: ::protobuf::lazy::Lazy<TrafficControlStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TrafficControlStatistics,
        };
        unsafe {
            instance.get(|| {
                TrafficControlStatistics {
                    id: ::protobuf::SingularField::none(),
                    backlog: ::std::option::Option::None,
                    bytes: ::std::option::Option::None,
                    drops: ::std::option::Option::None,
                    overlimits: ::std::option::Option::None,
                    packets: ::std::option::Option::None,
                    qlen: ::std::option::Option::None,
                    ratebps: ::std::option::Option::None,
                    ratepps: ::std::option::Option::None,
                    requeues: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint64 backlog = 2;

    pub fn clear_backlog(&mut self) {
        self.backlog = ::std::option::Option::None;
    }

    pub fn has_backlog(&self) -> bool {
        self.backlog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backlog(&mut self, v: u64) {
        self.backlog = ::std::option::Option::Some(v);
    }

    pub fn get_backlog<'a>(&self) -> u64 {
        self.backlog.unwrap_or(0)
    }

    // optional uint64 bytes = 3;

    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = ::std::option::Option::Some(v);
    }

    pub fn get_bytes<'a>(&self) -> u64 {
        self.bytes.unwrap_or(0)
    }

    // optional uint64 drops = 4;

    pub fn clear_drops(&mut self) {
        self.drops = ::std::option::Option::None;
    }

    pub fn has_drops(&self) -> bool {
        self.drops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drops(&mut self, v: u64) {
        self.drops = ::std::option::Option::Some(v);
    }

    pub fn get_drops<'a>(&self) -> u64 {
        self.drops.unwrap_or(0)
    }

    // optional uint64 overlimits = 5;

    pub fn clear_overlimits(&mut self) {
        self.overlimits = ::std::option::Option::None;
    }

    pub fn has_overlimits(&self) -> bool {
        self.overlimits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlimits(&mut self, v: u64) {
        self.overlimits = ::std::option::Option::Some(v);
    }

    pub fn get_overlimits<'a>(&self) -> u64 {
        self.overlimits.unwrap_or(0)
    }

    // optional uint64 packets = 6;

    pub fn clear_packets(&mut self) {
        self.packets = ::std::option::Option::None;
    }

    pub fn has_packets(&self) -> bool {
        self.packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: u64) {
        self.packets = ::std::option::Option::Some(v);
    }

    pub fn get_packets<'a>(&self) -> u64 {
        self.packets.unwrap_or(0)
    }

    // optional uint64 qlen = 7;

    pub fn clear_qlen(&mut self) {
        self.qlen = ::std::option::Option::None;
    }

    pub fn has_qlen(&self) -> bool {
        self.qlen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qlen(&mut self, v: u64) {
        self.qlen = ::std::option::Option::Some(v);
    }

    pub fn get_qlen<'a>(&self) -> u64 {
        self.qlen.unwrap_or(0)
    }

    // optional uint64 ratebps = 8;

    pub fn clear_ratebps(&mut self) {
        self.ratebps = ::std::option::Option::None;
    }

    pub fn has_ratebps(&self) -> bool {
        self.ratebps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ratebps(&mut self, v: u64) {
        self.ratebps = ::std::option::Option::Some(v);
    }

    pub fn get_ratebps<'a>(&self) -> u64 {
        self.ratebps.unwrap_or(0)
    }

    // optional uint64 ratepps = 9;

    pub fn clear_ratepps(&mut self) {
        self.ratepps = ::std::option::Option::None;
    }

    pub fn has_ratepps(&self) -> bool {
        self.ratepps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ratepps(&mut self, v: u64) {
        self.ratepps = ::std::option::Option::Some(v);
    }

    pub fn get_ratepps<'a>(&self) -> u64 {
        self.ratepps.unwrap_or(0)
    }

    // optional uint64 requeues = 10;

    pub fn clear_requeues(&mut self) {
        self.requeues = ::std::option::Option::None;
    }

    pub fn has_requeues(&self) -> bool {
        self.requeues.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requeues(&mut self, v: u64) {
        self.requeues = ::std::option::Option::Some(v);
    }

    pub fn get_requeues<'a>(&self) -> u64 {
        self.requeues.unwrap_or(0)
    }
}

impl ::protobuf::Message for TrafficControlStatistics {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.id.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.backlog = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bytes = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.drops = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.overlimits = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.packets = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.qlen = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.ratebps = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.ratepps = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.requeues = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.backlog.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.drops.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.overlimits.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.packets.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.qlen.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ratebps.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ratepps.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.requeues.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.backlog {
            try!(os.write_uint64(2, v));
        };
        if let Some(v) = self.bytes {
            try!(os.write_uint64(3, v));
        };
        if let Some(v) = self.drops {
            try!(os.write_uint64(4, v));
        };
        if let Some(v) = self.overlimits {
            try!(os.write_uint64(5, v));
        };
        if let Some(v) = self.packets {
            try!(os.write_uint64(6, v));
        };
        if let Some(v) = self.qlen {
            try!(os.write_uint64(7, v));
        };
        if let Some(v) = self.ratebps {
            try!(os.write_uint64(8, v));
        };
        if let Some(v) = self.ratepps {
            try!(os.write_uint64(9, v));
        };
        if let Some(v) = self.requeues {
            try!(os.write_uint64(10, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TrafficControlStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TrafficControlStatistics {
    fn new() -> TrafficControlStatistics {
        TrafficControlStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<TrafficControlStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "id",
                    TrafficControlStatistics::has_id,
                    TrafficControlStatistics::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "backlog",
                    TrafficControlStatistics::has_backlog,
                    TrafficControlStatistics::get_backlog,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bytes",
                    TrafficControlStatistics::has_bytes,
                    TrafficControlStatistics::get_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "drops",
                    TrafficControlStatistics::has_drops,
                    TrafficControlStatistics::get_drops,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "overlimits",
                    TrafficControlStatistics::has_overlimits,
                    TrafficControlStatistics::get_overlimits,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "packets",
                    TrafficControlStatistics::has_packets,
                    TrafficControlStatistics::get_packets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "qlen",
                    TrafficControlStatistics::has_qlen,
                    TrafficControlStatistics::get_qlen,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "ratebps",
                    TrafficControlStatistics::has_ratebps,
                    TrafficControlStatistics::get_ratebps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "ratepps",
                    TrafficControlStatistics::has_ratepps,
                    TrafficControlStatistics::get_ratepps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "requeues",
                    TrafficControlStatistics::has_requeues,
                    TrafficControlStatistics::get_requeues,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TrafficControlStatistics>(
                    "TrafficControlStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TrafficControlStatistics {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_backlog();
        self.clear_bytes();
        self.clear_drops();
        self.clear_overlimits();
        self.clear_packets();
        self.clear_qlen();
        self.clear_ratebps();
        self.clear_ratepps();
        self.clear_requeues();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TrafficControlStatistics {
    fn eq(&self, other: &TrafficControlStatistics) -> bool {
        self.id == other.id &&
        self.backlog == other.backlog &&
        self.bytes == other.bytes &&
        self.drops == other.drops &&
        self.overlimits == other.overlimits &&
        self.packets == other.packets &&
        self.qlen == other.qlen &&
        self.ratebps == other.ratebps &&
        self.ratepps == other.ratepps &&
        self.requeues == other.requeues &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TrafficControlStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ResourceStatistics {
    // message fields
    timestamp: ::std::option::Option<f64>,
    processes: ::std::option::Option<u32>,
    threads: ::std::option::Option<u32>,
    cpus_user_time_secs: ::std::option::Option<f64>,
    cpus_system_time_secs: ::std::option::Option<f64>,
    cpus_limit: ::std::option::Option<f64>,
    cpus_nr_periods: ::std::option::Option<u32>,
    cpus_nr_throttled: ::std::option::Option<u32>,
    cpus_throttled_time_secs: ::std::option::Option<f64>,
    mem_total_bytes: ::std::option::Option<u64>,
    mem_total_memsw_bytes: ::std::option::Option<u64>,
    mem_limit_bytes: ::std::option::Option<u64>,
    mem_soft_limit_bytes: ::std::option::Option<u64>,
    mem_file_bytes: ::std::option::Option<u64>,
    mem_anon_bytes: ::std::option::Option<u64>,
    mem_cache_bytes: ::std::option::Option<u64>,
    mem_rss_bytes: ::std::option::Option<u64>,
    mem_mapped_file_bytes: ::std::option::Option<u64>,
    mem_swap_bytes: ::std::option::Option<u64>,
    mem_low_pressure_counter: ::std::option::Option<u64>,
    mem_medium_pressure_counter: ::std::option::Option<u64>,
    mem_critical_pressure_counter: ::std::option::Option<u64>,
    disk_limit_bytes: ::std::option::Option<u64>,
    disk_used_bytes: ::std::option::Option<u64>,
    perf: ::protobuf::SingularPtrField<PerfStatistics>,
    net_rx_packets: ::std::option::Option<u64>,
    net_rx_bytes: ::std::option::Option<u64>,
    net_rx_errors: ::std::option::Option<u64>,
    net_rx_dropped: ::std::option::Option<u64>,
    net_tx_packets: ::std::option::Option<u64>,
    net_tx_bytes: ::std::option::Option<u64>,
    net_tx_errors: ::std::option::Option<u64>,
    net_tx_dropped: ::std::option::Option<u64>,
    net_tcp_rtt_microsecs_p50: ::std::option::Option<f64>,
    net_tcp_rtt_microsecs_p90: ::std::option::Option<f64>,
    net_tcp_rtt_microsecs_p95: ::std::option::Option<f64>,
    net_tcp_rtt_microsecs_p99: ::std::option::Option<f64>,
    net_tcp_active_connections: ::std::option::Option<f64>,
    net_tcp_time_wait_connections: ::std::option::Option<f64>,
    net_traffic_control_statistics: ::protobuf::RepeatedField<TrafficControlStatistics>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ResourceStatistics {
    pub fn new() -> ResourceStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceStatistics {
        static mut instance: ::protobuf::lazy::Lazy<ResourceStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceStatistics,
        };
        unsafe {
            instance.get(|| {
                ResourceStatistics {
                    timestamp: ::std::option::Option::None,
                    processes: ::std::option::Option::None,
                    threads: ::std::option::Option::None,
                    cpus_user_time_secs: ::std::option::Option::None,
                    cpus_system_time_secs: ::std::option::Option::None,
                    cpus_limit: ::std::option::Option::None,
                    cpus_nr_periods: ::std::option::Option::None,
                    cpus_nr_throttled: ::std::option::Option::None,
                    cpus_throttled_time_secs: ::std::option::Option::None,
                    mem_total_bytes: ::std::option::Option::None,
                    mem_total_memsw_bytes: ::std::option::Option::None,
                    mem_limit_bytes: ::std::option::Option::None,
                    mem_soft_limit_bytes: ::std::option::Option::None,
                    mem_file_bytes: ::std::option::Option::None,
                    mem_anon_bytes: ::std::option::Option::None,
                    mem_cache_bytes: ::std::option::Option::None,
                    mem_rss_bytes: ::std::option::Option::None,
                    mem_mapped_file_bytes: ::std::option::Option::None,
                    mem_swap_bytes: ::std::option::Option::None,
                    mem_low_pressure_counter: ::std::option::Option::None,
                    mem_medium_pressure_counter: ::std::option::Option::None,
                    mem_critical_pressure_counter: ::std::option::Option::None,
                    disk_limit_bytes: ::std::option::Option::None,
                    disk_used_bytes: ::std::option::Option::None,
                    perf: ::protobuf::SingularPtrField::none(),
                    net_rx_packets: ::std::option::Option::None,
                    net_rx_bytes: ::std::option::Option::None,
                    net_rx_errors: ::std::option::Option::None,
                    net_rx_dropped: ::std::option::Option::None,
                    net_tx_packets: ::std::option::Option::None,
                    net_tx_bytes: ::std::option::Option::None,
                    net_tx_errors: ::std::option::Option::None,
                    net_tx_dropped: ::std::option::Option::None,
                    net_tcp_rtt_microsecs_p50: ::std::option::Option::None,
                    net_tcp_rtt_microsecs_p90: ::std::option::Option::None,
                    net_tcp_rtt_microsecs_p95: ::std::option::Option::None,
                    net_tcp_rtt_microsecs_p99: ::std::option::Option::None,
                    net_tcp_active_connections: ::std::option::Option::None,
                    net_tcp_time_wait_connections: ::std::option::Option::None,
                    net_traffic_control_statistics: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required double timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp<'a>(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    // optional uint32 processes = 30;

    pub fn clear_processes(&mut self) {
        self.processes = ::std::option::Option::None;
    }

    pub fn has_processes(&self) -> bool {
        self.processes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_processes(&mut self, v: u32) {
        self.processes = ::std::option::Option::Some(v);
    }

    pub fn get_processes<'a>(&self) -> u32 {
        self.processes.unwrap_or(0)
    }

    // optional uint32 threads = 31;

    pub fn clear_threads(&mut self) {
        self.threads = ::std::option::Option::None;
    }

    pub fn has_threads(&self) -> bool {
        self.threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threads(&mut self, v: u32) {
        self.threads = ::std::option::Option::Some(v);
    }

    pub fn get_threads<'a>(&self) -> u32 {
        self.threads.unwrap_or(0)
    }

    // optional double cpus_user_time_secs = 2;

    pub fn clear_cpus_user_time_secs(&mut self) {
        self.cpus_user_time_secs = ::std::option::Option::None;
    }

    pub fn has_cpus_user_time_secs(&self) -> bool {
        self.cpus_user_time_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_user_time_secs(&mut self, v: f64) {
        self.cpus_user_time_secs = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_user_time_secs<'a>(&self) -> f64 {
        self.cpus_user_time_secs.unwrap_or(0.)
    }

    // optional double cpus_system_time_secs = 3;

    pub fn clear_cpus_system_time_secs(&mut self) {
        self.cpus_system_time_secs = ::std::option::Option::None;
    }

    pub fn has_cpus_system_time_secs(&self) -> bool {
        self.cpus_system_time_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_system_time_secs(&mut self, v: f64) {
        self.cpus_system_time_secs = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_system_time_secs<'a>(&self) -> f64 {
        self.cpus_system_time_secs.unwrap_or(0.)
    }

    // optional double cpus_limit = 4;

    pub fn clear_cpus_limit(&mut self) {
        self.cpus_limit = ::std::option::Option::None;
    }

    pub fn has_cpus_limit(&self) -> bool {
        self.cpus_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_limit(&mut self, v: f64) {
        self.cpus_limit = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_limit<'a>(&self) -> f64 {
        self.cpus_limit.unwrap_or(0.)
    }

    // optional uint32 cpus_nr_periods = 7;

    pub fn clear_cpus_nr_periods(&mut self) {
        self.cpus_nr_periods = ::std::option::Option::None;
    }

    pub fn has_cpus_nr_periods(&self) -> bool {
        self.cpus_nr_periods.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_nr_periods(&mut self, v: u32) {
        self.cpus_nr_periods = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_nr_periods<'a>(&self) -> u32 {
        self.cpus_nr_periods.unwrap_or(0)
    }

    // optional uint32 cpus_nr_throttled = 8;

    pub fn clear_cpus_nr_throttled(&mut self) {
        self.cpus_nr_throttled = ::std::option::Option::None;
    }

    pub fn has_cpus_nr_throttled(&self) -> bool {
        self.cpus_nr_throttled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_nr_throttled(&mut self, v: u32) {
        self.cpus_nr_throttled = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_nr_throttled<'a>(&self) -> u32 {
        self.cpus_nr_throttled.unwrap_or(0)
    }

    // optional double cpus_throttled_time_secs = 9;

    pub fn clear_cpus_throttled_time_secs(&mut self) {
        self.cpus_throttled_time_secs = ::std::option::Option::None;
    }

    pub fn has_cpus_throttled_time_secs(&self) -> bool {
        self.cpus_throttled_time_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_throttled_time_secs(&mut self, v: f64) {
        self.cpus_throttled_time_secs = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_throttled_time_secs<'a>(&self) -> f64 {
        self.cpus_throttled_time_secs.unwrap_or(0.)
    }

    // optional uint64 mem_total_bytes = 36;

    pub fn clear_mem_total_bytes(&mut self) {
        self.mem_total_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_total_bytes(&self) -> bool {
        self.mem_total_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_total_bytes(&mut self, v: u64) {
        self.mem_total_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_total_bytes<'a>(&self) -> u64 {
        self.mem_total_bytes.unwrap_or(0)
    }

    // optional uint64 mem_total_memsw_bytes = 37;

    pub fn clear_mem_total_memsw_bytes(&mut self) {
        self.mem_total_memsw_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_total_memsw_bytes(&self) -> bool {
        self.mem_total_memsw_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_total_memsw_bytes(&mut self, v: u64) {
        self.mem_total_memsw_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_total_memsw_bytes<'a>(&self) -> u64 {
        self.mem_total_memsw_bytes.unwrap_or(0)
    }

    // optional uint64 mem_limit_bytes = 6;

    pub fn clear_mem_limit_bytes(&mut self) {
        self.mem_limit_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_limit_bytes(&self) -> bool {
        self.mem_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_limit_bytes(&mut self, v: u64) {
        self.mem_limit_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_limit_bytes<'a>(&self) -> u64 {
        self.mem_limit_bytes.unwrap_or(0)
    }

    // optional uint64 mem_soft_limit_bytes = 38;

    pub fn clear_mem_soft_limit_bytes(&mut self) {
        self.mem_soft_limit_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_soft_limit_bytes(&self) -> bool {
        self.mem_soft_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_soft_limit_bytes(&mut self, v: u64) {
        self.mem_soft_limit_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_soft_limit_bytes<'a>(&self) -> u64 {
        self.mem_soft_limit_bytes.unwrap_or(0)
    }

    // optional uint64 mem_file_bytes = 10;

    pub fn clear_mem_file_bytes(&mut self) {
        self.mem_file_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_file_bytes(&self) -> bool {
        self.mem_file_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_file_bytes(&mut self, v: u64) {
        self.mem_file_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_file_bytes<'a>(&self) -> u64 {
        self.mem_file_bytes.unwrap_or(0)
    }

    // optional uint64 mem_anon_bytes = 11;

    pub fn clear_mem_anon_bytes(&mut self) {
        self.mem_anon_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_anon_bytes(&self) -> bool {
        self.mem_anon_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_anon_bytes(&mut self, v: u64) {
        self.mem_anon_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_anon_bytes<'a>(&self) -> u64 {
        self.mem_anon_bytes.unwrap_or(0)
    }

    // optional uint64 mem_cache_bytes = 39;

    pub fn clear_mem_cache_bytes(&mut self) {
        self.mem_cache_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_cache_bytes(&self) -> bool {
        self.mem_cache_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_cache_bytes(&mut self, v: u64) {
        self.mem_cache_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_cache_bytes<'a>(&self) -> u64 {
        self.mem_cache_bytes.unwrap_or(0)
    }

    // optional uint64 mem_rss_bytes = 5;

    pub fn clear_mem_rss_bytes(&mut self) {
        self.mem_rss_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_rss_bytes(&self) -> bool {
        self.mem_rss_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_rss_bytes(&mut self, v: u64) {
        self.mem_rss_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_rss_bytes<'a>(&self) -> u64 {
        self.mem_rss_bytes.unwrap_or(0)
    }

    // optional uint64 mem_mapped_file_bytes = 12;

    pub fn clear_mem_mapped_file_bytes(&mut self) {
        self.mem_mapped_file_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_mapped_file_bytes(&self) -> bool {
        self.mem_mapped_file_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_mapped_file_bytes(&mut self, v: u64) {
        self.mem_mapped_file_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_mapped_file_bytes<'a>(&self) -> u64 {
        self.mem_mapped_file_bytes.unwrap_or(0)
    }

    // optional uint64 mem_swap_bytes = 40;

    pub fn clear_mem_swap_bytes(&mut self) {
        self.mem_swap_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_swap_bytes(&self) -> bool {
        self.mem_swap_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_swap_bytes(&mut self, v: u64) {
        self.mem_swap_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_swap_bytes<'a>(&self) -> u64 {
        self.mem_swap_bytes.unwrap_or(0)
    }

    // optional uint64 mem_low_pressure_counter = 32;

    pub fn clear_mem_low_pressure_counter(&mut self) {
        self.mem_low_pressure_counter = ::std::option::Option::None;
    }

    pub fn has_mem_low_pressure_counter(&self) -> bool {
        self.mem_low_pressure_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_low_pressure_counter(&mut self, v: u64) {
        self.mem_low_pressure_counter = ::std::option::Option::Some(v);
    }

    pub fn get_mem_low_pressure_counter<'a>(&self) -> u64 {
        self.mem_low_pressure_counter.unwrap_or(0)
    }

    // optional uint64 mem_medium_pressure_counter = 33;

    pub fn clear_mem_medium_pressure_counter(&mut self) {
        self.mem_medium_pressure_counter = ::std::option::Option::None;
    }

    pub fn has_mem_medium_pressure_counter(&self) -> bool {
        self.mem_medium_pressure_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_medium_pressure_counter(&mut self, v: u64) {
        self.mem_medium_pressure_counter = ::std::option::Option::Some(v);
    }

    pub fn get_mem_medium_pressure_counter<'a>(&self) -> u64 {
        self.mem_medium_pressure_counter.unwrap_or(0)
    }

    // optional uint64 mem_critical_pressure_counter = 34;

    pub fn clear_mem_critical_pressure_counter(&mut self) {
        self.mem_critical_pressure_counter = ::std::option::Option::None;
    }

    pub fn has_mem_critical_pressure_counter(&self) -> bool {
        self.mem_critical_pressure_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_critical_pressure_counter(&mut self, v: u64) {
        self.mem_critical_pressure_counter = ::std::option::Option::Some(v);
    }

    pub fn get_mem_critical_pressure_counter<'a>(&self) -> u64 {
        self.mem_critical_pressure_counter.unwrap_or(0)
    }

    // optional uint64 disk_limit_bytes = 26;

    pub fn clear_disk_limit_bytes(&mut self) {
        self.disk_limit_bytes = ::std::option::Option::None;
    }

    pub fn has_disk_limit_bytes(&self) -> bool {
        self.disk_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disk_limit_bytes(&mut self, v: u64) {
        self.disk_limit_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_disk_limit_bytes<'a>(&self) -> u64 {
        self.disk_limit_bytes.unwrap_or(0)
    }

    // optional uint64 disk_used_bytes = 27;

    pub fn clear_disk_used_bytes(&mut self) {
        self.disk_used_bytes = ::std::option::Option::None;
    }

    pub fn has_disk_used_bytes(&self) -> bool {
        self.disk_used_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disk_used_bytes(&mut self, v: u64) {
        self.disk_used_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_disk_used_bytes<'a>(&self) -> u64 {
        self.disk_used_bytes.unwrap_or(0)
    }

    // optional .mesos.PerfStatistics perf = 13;

    pub fn clear_perf(&mut self) {
        self.perf.clear();
    }

    pub fn has_perf(&self) -> bool {
        self.perf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf(&mut self, v: PerfStatistics) {
        self.perf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_perf<'a>(&'a mut self) -> &'a mut PerfStatistics {
        if self.perf.is_none() {
            self.perf.set_default();
        };
        self.perf.as_mut().unwrap()
    }

    // Take field
    pub fn take_perf(&mut self) -> PerfStatistics {
        self.perf.take().unwrap_or_else(|| PerfStatistics::new())
    }

    pub fn get_perf<'a>(&'a self) -> &'a PerfStatistics {
        self.perf.as_ref().unwrap_or_else(|| PerfStatistics::default_instance())
    }

    // optional uint64 net_rx_packets = 14;

    pub fn clear_net_rx_packets(&mut self) {
        self.net_rx_packets = ::std::option::Option::None;
    }

    pub fn has_net_rx_packets(&self) -> bool {
        self.net_rx_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_packets(&mut self, v: u64) {
        self.net_rx_packets = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_packets<'a>(&self) -> u64 {
        self.net_rx_packets.unwrap_or(0)
    }

    // optional uint64 net_rx_bytes = 15;

    pub fn clear_net_rx_bytes(&mut self) {
        self.net_rx_bytes = ::std::option::Option::None;
    }

    pub fn has_net_rx_bytes(&self) -> bool {
        self.net_rx_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_bytes(&mut self, v: u64) {
        self.net_rx_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_bytes<'a>(&self) -> u64 {
        self.net_rx_bytes.unwrap_or(0)
    }

    // optional uint64 net_rx_errors = 16;

    pub fn clear_net_rx_errors(&mut self) {
        self.net_rx_errors = ::std::option::Option::None;
    }

    pub fn has_net_rx_errors(&self) -> bool {
        self.net_rx_errors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_errors(&mut self, v: u64) {
        self.net_rx_errors = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_errors<'a>(&self) -> u64 {
        self.net_rx_errors.unwrap_or(0)
    }

    // optional uint64 net_rx_dropped = 17;

    pub fn clear_net_rx_dropped(&mut self) {
        self.net_rx_dropped = ::std::option::Option::None;
    }

    pub fn has_net_rx_dropped(&self) -> bool {
        self.net_rx_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_dropped(&mut self, v: u64) {
        self.net_rx_dropped = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_dropped<'a>(&self) -> u64 {
        self.net_rx_dropped.unwrap_or(0)
    }

    // optional uint64 net_tx_packets = 18;

    pub fn clear_net_tx_packets(&mut self) {
        self.net_tx_packets = ::std::option::Option::None;
    }

    pub fn has_net_tx_packets(&self) -> bool {
        self.net_tx_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_packets(&mut self, v: u64) {
        self.net_tx_packets = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_packets<'a>(&self) -> u64 {
        self.net_tx_packets.unwrap_or(0)
    }

    // optional uint64 net_tx_bytes = 19;

    pub fn clear_net_tx_bytes(&mut self) {
        self.net_tx_bytes = ::std::option::Option::None;
    }

    pub fn has_net_tx_bytes(&self) -> bool {
        self.net_tx_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_bytes(&mut self, v: u64) {
        self.net_tx_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_bytes<'a>(&self) -> u64 {
        self.net_tx_bytes.unwrap_or(0)
    }

    // optional uint64 net_tx_errors = 20;

    pub fn clear_net_tx_errors(&mut self) {
        self.net_tx_errors = ::std::option::Option::None;
    }

    pub fn has_net_tx_errors(&self) -> bool {
        self.net_tx_errors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_errors(&mut self, v: u64) {
        self.net_tx_errors = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_errors<'a>(&self) -> u64 {
        self.net_tx_errors.unwrap_or(0)
    }

    // optional uint64 net_tx_dropped = 21;

    pub fn clear_net_tx_dropped(&mut self) {
        self.net_tx_dropped = ::std::option::Option::None;
    }

    pub fn has_net_tx_dropped(&self) -> bool {
        self.net_tx_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_dropped(&mut self, v: u64) {
        self.net_tx_dropped = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_dropped<'a>(&self) -> u64 {
        self.net_tx_dropped.unwrap_or(0)
    }

    // optional double net_tcp_rtt_microsecs_p50 = 22;

    pub fn clear_net_tcp_rtt_microsecs_p50(&mut self) {
        self.net_tcp_rtt_microsecs_p50 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p50(&self) -> bool {
        self.net_tcp_rtt_microsecs_p50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p50(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p50 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p50<'a>(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p50.unwrap_or(0.)
    }

    // optional double net_tcp_rtt_microsecs_p90 = 23;

    pub fn clear_net_tcp_rtt_microsecs_p90(&mut self) {
        self.net_tcp_rtt_microsecs_p90 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p90(&self) -> bool {
        self.net_tcp_rtt_microsecs_p90.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p90(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p90 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p90<'a>(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p90.unwrap_or(0.)
    }

    // optional double net_tcp_rtt_microsecs_p95 = 24;

    pub fn clear_net_tcp_rtt_microsecs_p95(&mut self) {
        self.net_tcp_rtt_microsecs_p95 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p95(&self) -> bool {
        self.net_tcp_rtt_microsecs_p95.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p95(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p95 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p95<'a>(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p95.unwrap_or(0.)
    }

    // optional double net_tcp_rtt_microsecs_p99 = 25;

    pub fn clear_net_tcp_rtt_microsecs_p99(&mut self) {
        self.net_tcp_rtt_microsecs_p99 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p99(&self) -> bool {
        self.net_tcp_rtt_microsecs_p99.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p99(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p99 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p99<'a>(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p99.unwrap_or(0.)
    }

    // optional double net_tcp_active_connections = 28;

    pub fn clear_net_tcp_active_connections(&mut self) {
        self.net_tcp_active_connections = ::std::option::Option::None;
    }

    pub fn has_net_tcp_active_connections(&self) -> bool {
        self.net_tcp_active_connections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_active_connections(&mut self, v: f64) {
        self.net_tcp_active_connections = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_active_connections<'a>(&self) -> f64 {
        self.net_tcp_active_connections.unwrap_or(0.)
    }

    // optional double net_tcp_time_wait_connections = 29;

    pub fn clear_net_tcp_time_wait_connections(&mut self) {
        self.net_tcp_time_wait_connections = ::std::option::Option::None;
    }

    pub fn has_net_tcp_time_wait_connections(&self) -> bool {
        self.net_tcp_time_wait_connections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_time_wait_connections(&mut self, v: f64) {
        self.net_tcp_time_wait_connections = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_time_wait_connections<'a>(&self) -> f64 {
        self.net_tcp_time_wait_connections.unwrap_or(0.)
    }

    // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;

    pub fn clear_net_traffic_control_statistics(&mut self) {
        self.net_traffic_control_statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_net_traffic_control_statistics(&mut self, v: ::protobuf::RepeatedField<TrafficControlStatistics>) {
        self.net_traffic_control_statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_net_traffic_control_statistics<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<TrafficControlStatistics> {
        &mut self.net_traffic_control_statistics
    }

    // Take field
    pub fn take_net_traffic_control_statistics(&mut self) -> ::protobuf::RepeatedField<TrafficControlStatistics> {
        ::std::mem::replace(&mut self.net_traffic_control_statistics, ::protobuf::RepeatedField::new())
    }

    pub fn get_net_traffic_control_statistics<'a>(&'a self) -> &'a [TrafficControlStatistics] {
        &self.net_traffic_control_statistics
    }
}

impl ::protobuf::Message for ResourceStatistics {
    fn is_initialized(&self) -> bool {
        if self.timestamp.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.processes = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.threads = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.cpus_user_time_secs = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.cpus_system_time_secs = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.cpus_limit = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cpus_nr_periods = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cpus_nr_throttled = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.cpus_throttled_time_secs = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_total_bytes = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_total_memsw_bytes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_limit_bytes = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_soft_limit_bytes = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_file_bytes = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_anon_bytes = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_cache_bytes = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_rss_bytes = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_mapped_file_bytes = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_swap_bytes = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_low_pressure_counter = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_medium_pressure_counter = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_critical_pressure_counter = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.disk_limit_bytes = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.disk_used_bytes = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.perf.set_default();
                    try!(is.merge_message(tmp))
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_rx_packets = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_rx_bytes = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_rx_errors = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_rx_dropped = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_tx_packets = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_tx_bytes = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_tx_errors = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_tx_dropped = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_rtt_microsecs_p50 = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_rtt_microsecs_p90 = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_rtt_microsecs_p95 = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_rtt_microsecs_p99 = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_active_connections = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_time_wait_connections = ::std::option::Option::Some(tmp);
                },
                35 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.net_traffic_control_statistics));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp.is_some() {
            my_size += 9;
        };
        for value in self.processes.iter() {
            my_size += ::protobuf::rt::value_size(30, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.threads.iter() {
            my_size += ::protobuf::rt::value_size(31, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.cpus_user_time_secs.is_some() {
            my_size += 9;
        };
        if self.cpus_system_time_secs.is_some() {
            my_size += 9;
        };
        if self.cpus_limit.is_some() {
            my_size += 9;
        };
        for value in self.cpus_nr_periods.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cpus_nr_throttled.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.cpus_throttled_time_secs.is_some() {
            my_size += 9;
        };
        for value in self.mem_total_bytes.iter() {
            my_size += ::protobuf::rt::value_size(36, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_total_memsw_bytes.iter() {
            my_size += ::protobuf::rt::value_size(37, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_limit_bytes.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_soft_limit_bytes.iter() {
            my_size += ::protobuf::rt::value_size(38, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_file_bytes.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_anon_bytes.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_cache_bytes.iter() {
            my_size += ::protobuf::rt::value_size(39, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_rss_bytes.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_mapped_file_bytes.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_swap_bytes.iter() {
            my_size += ::protobuf::rt::value_size(40, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_low_pressure_counter.iter() {
            my_size += ::protobuf::rt::value_size(32, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_medium_pressure_counter.iter() {
            my_size += ::protobuf::rt::value_size(33, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_critical_pressure_counter.iter() {
            my_size += ::protobuf::rt::value_size(34, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.disk_limit_bytes.iter() {
            my_size += ::protobuf::rt::value_size(26, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.disk_used_bytes.iter() {
            my_size += ::protobuf::rt::value_size(27, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.perf.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.net_rx_packets.iter() {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_rx_bytes.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_rx_errors.iter() {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_rx_dropped.iter() {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_tx_packets.iter() {
            my_size += ::protobuf::rt::value_size(18, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_tx_bytes.iter() {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_tx_errors.iter() {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_tx_dropped.iter() {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.net_tcp_rtt_microsecs_p50.is_some() {
            my_size += 10;
        };
        if self.net_tcp_rtt_microsecs_p90.is_some() {
            my_size += 10;
        };
        if self.net_tcp_rtt_microsecs_p95.is_some() {
            my_size += 10;
        };
        if self.net_tcp_rtt_microsecs_p99.is_some() {
            my_size += 10;
        };
        if self.net_tcp_active_connections.is_some() {
            my_size += 10;
        };
        if self.net_tcp_time_wait_connections.is_some() {
            my_size += 10;
        };
        for value in self.net_traffic_control_statistics.iter() {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            try!(os.write_double(1, v));
        };
        if let Some(v) = self.processes {
            try!(os.write_uint32(30, v));
        };
        if let Some(v) = self.threads {
            try!(os.write_uint32(31, v));
        };
        if let Some(v) = self.cpus_user_time_secs {
            try!(os.write_double(2, v));
        };
        if let Some(v) = self.cpus_system_time_secs {
            try!(os.write_double(3, v));
        };
        if let Some(v) = self.cpus_limit {
            try!(os.write_double(4, v));
        };
        if let Some(v) = self.cpus_nr_periods {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.cpus_nr_throttled {
            try!(os.write_uint32(8, v));
        };
        if let Some(v) = self.cpus_throttled_time_secs {
            try!(os.write_double(9, v));
        };
        if let Some(v) = self.mem_total_bytes {
            try!(os.write_uint64(36, v));
        };
        if let Some(v) = self.mem_total_memsw_bytes {
            try!(os.write_uint64(37, v));
        };
        if let Some(v) = self.mem_limit_bytes {
            try!(os.write_uint64(6, v));
        };
        if let Some(v) = self.mem_soft_limit_bytes {
            try!(os.write_uint64(38, v));
        };
        if let Some(v) = self.mem_file_bytes {
            try!(os.write_uint64(10, v));
        };
        if let Some(v) = self.mem_anon_bytes {
            try!(os.write_uint64(11, v));
        };
        if let Some(v) = self.mem_cache_bytes {
            try!(os.write_uint64(39, v));
        };
        if let Some(v) = self.mem_rss_bytes {
            try!(os.write_uint64(5, v));
        };
        if let Some(v) = self.mem_mapped_file_bytes {
            try!(os.write_uint64(12, v));
        };
        if let Some(v) = self.mem_swap_bytes {
            try!(os.write_uint64(40, v));
        };
        if let Some(v) = self.mem_low_pressure_counter {
            try!(os.write_uint64(32, v));
        };
        if let Some(v) = self.mem_medium_pressure_counter {
            try!(os.write_uint64(33, v));
        };
        if let Some(v) = self.mem_critical_pressure_counter {
            try!(os.write_uint64(34, v));
        };
        if let Some(v) = self.disk_limit_bytes {
            try!(os.write_uint64(26, v));
        };
        if let Some(v) = self.disk_used_bytes {
            try!(os.write_uint64(27, v));
        };
        if let Some(v) = self.perf.as_ref() {
            try!(os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.net_rx_packets {
            try!(os.write_uint64(14, v));
        };
        if let Some(v) = self.net_rx_bytes {
            try!(os.write_uint64(15, v));
        };
        if let Some(v) = self.net_rx_errors {
            try!(os.write_uint64(16, v));
        };
        if let Some(v) = self.net_rx_dropped {
            try!(os.write_uint64(17, v));
        };
        if let Some(v) = self.net_tx_packets {
            try!(os.write_uint64(18, v));
        };
        if let Some(v) = self.net_tx_bytes {
            try!(os.write_uint64(19, v));
        };
        if let Some(v) = self.net_tx_errors {
            try!(os.write_uint64(20, v));
        };
        if let Some(v) = self.net_tx_dropped {
            try!(os.write_uint64(21, v));
        };
        if let Some(v) = self.net_tcp_rtt_microsecs_p50 {
            try!(os.write_double(22, v));
        };
        if let Some(v) = self.net_tcp_rtt_microsecs_p90 {
            try!(os.write_double(23, v));
        };
        if let Some(v) = self.net_tcp_rtt_microsecs_p95 {
            try!(os.write_double(24, v));
        };
        if let Some(v) = self.net_tcp_rtt_microsecs_p99 {
            try!(os.write_double(25, v));
        };
        if let Some(v) = self.net_tcp_active_connections {
            try!(os.write_double(28, v));
        };
        if let Some(v) = self.net_tcp_time_wait_connections {
            try!(os.write_double(29, v));
        };
        for v in self.net_traffic_control_statistics.iter() {
            try!(os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ResourceStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceStatistics {
    fn new() -> ResourceStatistics {
        ResourceStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "timestamp",
                    ResourceStatistics::has_timestamp,
                    ResourceStatistics::get_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "processes",
                    ResourceStatistics::has_processes,
                    ResourceStatistics::get_processes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "threads",
                    ResourceStatistics::has_threads,
                    ResourceStatistics::get_threads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "cpus_user_time_secs",
                    ResourceStatistics::has_cpus_user_time_secs,
                    ResourceStatistics::get_cpus_user_time_secs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "cpus_system_time_secs",
                    ResourceStatistics::has_cpus_system_time_secs,
                    ResourceStatistics::get_cpus_system_time_secs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "cpus_limit",
                    ResourceStatistics::has_cpus_limit,
                    ResourceStatistics::get_cpus_limit,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cpus_nr_periods",
                    ResourceStatistics::has_cpus_nr_periods,
                    ResourceStatistics::get_cpus_nr_periods,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cpus_nr_throttled",
                    ResourceStatistics::has_cpus_nr_throttled,
                    ResourceStatistics::get_cpus_nr_throttled,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "cpus_throttled_time_secs",
                    ResourceStatistics::has_cpus_throttled_time_secs,
                    ResourceStatistics::get_cpus_throttled_time_secs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_total_bytes",
                    ResourceStatistics::has_mem_total_bytes,
                    ResourceStatistics::get_mem_total_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_total_memsw_bytes",
                    ResourceStatistics::has_mem_total_memsw_bytes,
                    ResourceStatistics::get_mem_total_memsw_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_limit_bytes",
                    ResourceStatistics::has_mem_limit_bytes,
                    ResourceStatistics::get_mem_limit_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_soft_limit_bytes",
                    ResourceStatistics::has_mem_soft_limit_bytes,
                    ResourceStatistics::get_mem_soft_limit_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_file_bytes",
                    ResourceStatistics::has_mem_file_bytes,
                    ResourceStatistics::get_mem_file_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_anon_bytes",
                    ResourceStatistics::has_mem_anon_bytes,
                    ResourceStatistics::get_mem_anon_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_cache_bytes",
                    ResourceStatistics::has_mem_cache_bytes,
                    ResourceStatistics::get_mem_cache_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_rss_bytes",
                    ResourceStatistics::has_mem_rss_bytes,
                    ResourceStatistics::get_mem_rss_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_mapped_file_bytes",
                    ResourceStatistics::has_mem_mapped_file_bytes,
                    ResourceStatistics::get_mem_mapped_file_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_swap_bytes",
                    ResourceStatistics::has_mem_swap_bytes,
                    ResourceStatistics::get_mem_swap_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_low_pressure_counter",
                    ResourceStatistics::has_mem_low_pressure_counter,
                    ResourceStatistics::get_mem_low_pressure_counter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_medium_pressure_counter",
                    ResourceStatistics::has_mem_medium_pressure_counter,
                    ResourceStatistics::get_mem_medium_pressure_counter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_critical_pressure_counter",
                    ResourceStatistics::has_mem_critical_pressure_counter,
                    ResourceStatistics::get_mem_critical_pressure_counter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "disk_limit_bytes",
                    ResourceStatistics::has_disk_limit_bytes,
                    ResourceStatistics::get_disk_limit_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "disk_used_bytes",
                    ResourceStatistics::has_disk_used_bytes,
                    ResourceStatistics::get_disk_used_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "perf",
                    ResourceStatistics::has_perf,
                    ResourceStatistics::get_perf,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_rx_packets",
                    ResourceStatistics::has_net_rx_packets,
                    ResourceStatistics::get_net_rx_packets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_rx_bytes",
                    ResourceStatistics::has_net_rx_bytes,
                    ResourceStatistics::get_net_rx_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_rx_errors",
                    ResourceStatistics::has_net_rx_errors,
                    ResourceStatistics::get_net_rx_errors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_rx_dropped",
                    ResourceStatistics::has_net_rx_dropped,
                    ResourceStatistics::get_net_rx_dropped,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_tx_packets",
                    ResourceStatistics::has_net_tx_packets,
                    ResourceStatistics::get_net_tx_packets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_tx_bytes",
                    ResourceStatistics::has_net_tx_bytes,
                    ResourceStatistics::get_net_tx_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_tx_errors",
                    ResourceStatistics::has_net_tx_errors,
                    ResourceStatistics::get_net_tx_errors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_tx_dropped",
                    ResourceStatistics::has_net_tx_dropped,
                    ResourceStatistics::get_net_tx_dropped,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_rtt_microsecs_p50",
                    ResourceStatistics::has_net_tcp_rtt_microsecs_p50,
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p50,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_rtt_microsecs_p90",
                    ResourceStatistics::has_net_tcp_rtt_microsecs_p90,
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p90,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_rtt_microsecs_p95",
                    ResourceStatistics::has_net_tcp_rtt_microsecs_p95,
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p95,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_rtt_microsecs_p99",
                    ResourceStatistics::has_net_tcp_rtt_microsecs_p99,
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p99,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_active_connections",
                    ResourceStatistics::has_net_tcp_active_connections,
                    ResourceStatistics::get_net_tcp_active_connections,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_time_wait_connections",
                    ResourceStatistics::has_net_tcp_time_wait_connections,
                    ResourceStatistics::get_net_tcp_time_wait_connections,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "net_traffic_control_statistics",
                    ResourceStatistics::get_net_traffic_control_statistics,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceStatistics>(
                    "ResourceStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceStatistics {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_processes();
        self.clear_threads();
        self.clear_cpus_user_time_secs();
        self.clear_cpus_system_time_secs();
        self.clear_cpus_limit();
        self.clear_cpus_nr_periods();
        self.clear_cpus_nr_throttled();
        self.clear_cpus_throttled_time_secs();
        self.clear_mem_total_bytes();
        self.clear_mem_total_memsw_bytes();
        self.clear_mem_limit_bytes();
        self.clear_mem_soft_limit_bytes();
        self.clear_mem_file_bytes();
        self.clear_mem_anon_bytes();
        self.clear_mem_cache_bytes();
        self.clear_mem_rss_bytes();
        self.clear_mem_mapped_file_bytes();
        self.clear_mem_swap_bytes();
        self.clear_mem_low_pressure_counter();
        self.clear_mem_medium_pressure_counter();
        self.clear_mem_critical_pressure_counter();
        self.clear_disk_limit_bytes();
        self.clear_disk_used_bytes();
        self.clear_perf();
        self.clear_net_rx_packets();
        self.clear_net_rx_bytes();
        self.clear_net_rx_errors();
        self.clear_net_rx_dropped();
        self.clear_net_tx_packets();
        self.clear_net_tx_bytes();
        self.clear_net_tx_errors();
        self.clear_net_tx_dropped();
        self.clear_net_tcp_rtt_microsecs_p50();
        self.clear_net_tcp_rtt_microsecs_p90();
        self.clear_net_tcp_rtt_microsecs_p95();
        self.clear_net_tcp_rtt_microsecs_p99();
        self.clear_net_tcp_active_connections();
        self.clear_net_tcp_time_wait_connections();
        self.clear_net_traffic_control_statistics();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ResourceStatistics {
    fn eq(&self, other: &ResourceStatistics) -> bool {
        self.timestamp == other.timestamp &&
        self.processes == other.processes &&
        self.threads == other.threads &&
        self.cpus_user_time_secs == other.cpus_user_time_secs &&
        self.cpus_system_time_secs == other.cpus_system_time_secs &&
        self.cpus_limit == other.cpus_limit &&
        self.cpus_nr_periods == other.cpus_nr_periods &&
        self.cpus_nr_throttled == other.cpus_nr_throttled &&
        self.cpus_throttled_time_secs == other.cpus_throttled_time_secs &&
        self.mem_total_bytes == other.mem_total_bytes &&
        self.mem_total_memsw_bytes == other.mem_total_memsw_bytes &&
        self.mem_limit_bytes == other.mem_limit_bytes &&
        self.mem_soft_limit_bytes == other.mem_soft_limit_bytes &&
        self.mem_file_bytes == other.mem_file_bytes &&
        self.mem_anon_bytes == other.mem_anon_bytes &&
        self.mem_cache_bytes == other.mem_cache_bytes &&
        self.mem_rss_bytes == other.mem_rss_bytes &&
        self.mem_mapped_file_bytes == other.mem_mapped_file_bytes &&
        self.mem_swap_bytes == other.mem_swap_bytes &&
        self.mem_low_pressure_counter == other.mem_low_pressure_counter &&
        self.mem_medium_pressure_counter == other.mem_medium_pressure_counter &&
        self.mem_critical_pressure_counter == other.mem_critical_pressure_counter &&
        self.disk_limit_bytes == other.disk_limit_bytes &&
        self.disk_used_bytes == other.disk_used_bytes &&
        self.perf == other.perf &&
        self.net_rx_packets == other.net_rx_packets &&
        self.net_rx_bytes == other.net_rx_bytes &&
        self.net_rx_errors == other.net_rx_errors &&
        self.net_rx_dropped == other.net_rx_dropped &&
        self.net_tx_packets == other.net_tx_packets &&
        self.net_tx_bytes == other.net_tx_bytes &&
        self.net_tx_errors == other.net_tx_errors &&
        self.net_tx_dropped == other.net_tx_dropped &&
        self.net_tcp_rtt_microsecs_p50 == other.net_tcp_rtt_microsecs_p50 &&
        self.net_tcp_rtt_microsecs_p90 == other.net_tcp_rtt_microsecs_p90 &&
        self.net_tcp_rtt_microsecs_p95 == other.net_tcp_rtt_microsecs_p95 &&
        self.net_tcp_rtt_microsecs_p99 == other.net_tcp_rtt_microsecs_p99 &&
        self.net_tcp_active_connections == other.net_tcp_active_connections &&
        self.net_tcp_time_wait_connections == other.net_tcp_time_wait_connections &&
        self.net_traffic_control_statistics == other.net_traffic_control_statistics &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ResourceStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ResourceUsage {
    // message fields
    executors: ::protobuf::RepeatedField<ResourceUsage_Executor>,
    total: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ResourceUsage {
    pub fn new() -> ResourceUsage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceUsage {
        static mut instance: ::protobuf::lazy::Lazy<ResourceUsage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceUsage,
        };
        unsafe {
            instance.get(|| {
                ResourceUsage {
                    executors: ::protobuf::RepeatedField::new(),
                    total: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.ResourceUsage.Executor executors = 1;

    pub fn clear_executors(&mut self) {
        self.executors.clear();
    }

    // Param is passed by value, moved
    pub fn set_executors(&mut self, v: ::protobuf::RepeatedField<ResourceUsage_Executor>) {
        self.executors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_executors<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ResourceUsage_Executor> {
        &mut self.executors
    }

    // Take field
    pub fn take_executors(&mut self) -> ::protobuf::RepeatedField<ResourceUsage_Executor> {
        ::std::mem::replace(&mut self.executors, ::protobuf::RepeatedField::new())
    }

    pub fn get_executors<'a>(&'a self) -> &'a [ResourceUsage_Executor] {
        &self.executors
    }

    // repeated .mesos.Resource total = 2;

    pub fn clear_total(&mut self) {
        self.total.clear();
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.total = v;
    }

    // Mutable pointer to the field.
    pub fn mut_total<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.total
    }

    // Take field
    pub fn take_total(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.total, ::protobuf::RepeatedField::new())
    }

    pub fn get_total<'a>(&'a self) -> &'a [Resource] {
        &self.total
    }
}

impl ::protobuf::Message for ResourceUsage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.executors));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.total));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.executors.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.total.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.executors.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.total.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ResourceUsage>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceUsage {
    fn new() -> ResourceUsage {
        ResourceUsage::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceUsage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "executors",
                    ResourceUsage::get_executors,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "total",
                    ResourceUsage::get_total,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceUsage>(
                    "ResourceUsage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceUsage {
    fn clear(&mut self) {
        self.clear_executors();
        self.clear_total();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ResourceUsage {
    fn eq(&self, other: &ResourceUsage) -> bool {
        self.executors == other.executors &&
        self.total == other.total &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ResourceUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ResourceUsage_Executor {
    // message fields
    executor_info: ::protobuf::SingularPtrField<ExecutorInfo>,
    allocated: ::protobuf::RepeatedField<Resource>,
    statistics: ::protobuf::SingularPtrField<ResourceStatistics>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ResourceUsage_Executor {
    pub fn new() -> ResourceUsage_Executor {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceUsage_Executor {
        static mut instance: ::protobuf::lazy::Lazy<ResourceUsage_Executor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceUsage_Executor,
        };
        unsafe {
            instance.get(|| {
                ResourceUsage_Executor {
                    executor_info: ::protobuf::SingularPtrField::none(),
                    allocated: ::protobuf::RepeatedField::new(),
                    statistics: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.ExecutorInfo executor_info = 1;

    pub fn clear_executor_info(&mut self) {
        self.executor_info.clear();
    }

    pub fn has_executor_info(&self) -> bool {
        self.executor_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_info(&mut self, v: ExecutorInfo) {
        self.executor_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_info<'a>(&'a mut self) -> &'a mut ExecutorInfo {
        if self.executor_info.is_none() {
            self.executor_info.set_default();
        };
        self.executor_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_info(&mut self) -> ExecutorInfo {
        self.executor_info.take().unwrap_or_else(|| ExecutorInfo::new())
    }

    pub fn get_executor_info<'a>(&'a self) -> &'a ExecutorInfo {
        self.executor_info.as_ref().unwrap_or_else(|| ExecutorInfo::default_instance())
    }

    // repeated .mesos.Resource allocated = 2;

    pub fn clear_allocated(&mut self) {
        self.allocated.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocated(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.allocated = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allocated<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.allocated
    }

    // Take field
    pub fn take_allocated(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.allocated, ::protobuf::RepeatedField::new())
    }

    pub fn get_allocated<'a>(&'a self) -> &'a [Resource] {
        &self.allocated
    }

    // optional .mesos.ResourceStatistics statistics = 3;

    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    pub fn has_statistics(&self) -> bool {
        self.statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: ResourceStatistics) {
        self.statistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statistics<'a>(&'a mut self) -> &'a mut ResourceStatistics {
        if self.statistics.is_none() {
            self.statistics.set_default();
        };
        self.statistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_statistics(&mut self) -> ResourceStatistics {
        self.statistics.take().unwrap_or_else(|| ResourceStatistics::new())
    }

    pub fn get_statistics<'a>(&'a self) -> &'a ResourceStatistics {
        self.statistics.as_ref().unwrap_or_else(|| ResourceStatistics::default_instance())
    }
}

impl ::protobuf::Message for ResourceUsage_Executor {
    fn is_initialized(&self) -> bool {
        if self.executor_info.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.executor_info.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allocated));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.statistics.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.executor_info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.allocated.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.statistics.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.executor_info.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.allocated.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.statistics.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ResourceUsage_Executor>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceUsage_Executor {
    fn new() -> ResourceUsage_Executor {
        ResourceUsage_Executor::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceUsage_Executor>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor_info",
                    ResourceUsage_Executor::has_executor_info,
                    ResourceUsage_Executor::get_executor_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "allocated",
                    ResourceUsage_Executor::get_allocated,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "statistics",
                    ResourceUsage_Executor::has_statistics,
                    ResourceUsage_Executor::get_statistics,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceUsage_Executor>(
                    "ResourceUsage_Executor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceUsage_Executor {
    fn clear(&mut self) {
        self.clear_executor_info();
        self.clear_allocated();
        self.clear_statistics();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ResourceUsage_Executor {
    fn eq(&self, other: &ResourceUsage_Executor) -> bool {
        self.executor_info == other.executor_info &&
        self.allocated == other.allocated &&
        self.statistics == other.statistics &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ResourceUsage_Executor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct PerfStatistics {
    // message fields
    timestamp: ::std::option::Option<f64>,
    duration: ::std::option::Option<f64>,
    cycles: ::std::option::Option<u64>,
    stalled_cycles_frontend: ::std::option::Option<u64>,
    stalled_cycles_backend: ::std::option::Option<u64>,
    instructions: ::std::option::Option<u64>,
    cache_references: ::std::option::Option<u64>,
    cache_misses: ::std::option::Option<u64>,
    branches: ::std::option::Option<u64>,
    branch_misses: ::std::option::Option<u64>,
    bus_cycles: ::std::option::Option<u64>,
    ref_cycles: ::std::option::Option<u64>,
    cpu_clock: ::std::option::Option<f64>,
    task_clock: ::std::option::Option<f64>,
    page_faults: ::std::option::Option<u64>,
    minor_faults: ::std::option::Option<u64>,
    major_faults: ::std::option::Option<u64>,
    context_switches: ::std::option::Option<u64>,
    cpu_migrations: ::std::option::Option<u64>,
    alignment_faults: ::std::option::Option<u64>,
    emulation_faults: ::std::option::Option<u64>,
    l1_dcache_loads: ::std::option::Option<u64>,
    l1_dcache_load_misses: ::std::option::Option<u64>,
    l1_dcache_stores: ::std::option::Option<u64>,
    l1_dcache_store_misses: ::std::option::Option<u64>,
    l1_dcache_prefetches: ::std::option::Option<u64>,
    l1_dcache_prefetch_misses: ::std::option::Option<u64>,
    l1_icache_loads: ::std::option::Option<u64>,
    l1_icache_load_misses: ::std::option::Option<u64>,
    l1_icache_prefetches: ::std::option::Option<u64>,
    l1_icache_prefetch_misses: ::std::option::Option<u64>,
    llc_loads: ::std::option::Option<u64>,
    llc_load_misses: ::std::option::Option<u64>,
    llc_stores: ::std::option::Option<u64>,
    llc_store_misses: ::std::option::Option<u64>,
    llc_prefetches: ::std::option::Option<u64>,
    llc_prefetch_misses: ::std::option::Option<u64>,
    dtlb_loads: ::std::option::Option<u64>,
    dtlb_load_misses: ::std::option::Option<u64>,
    dtlb_stores: ::std::option::Option<u64>,
    dtlb_store_misses: ::std::option::Option<u64>,
    dtlb_prefetches: ::std::option::Option<u64>,
    dtlb_prefetch_misses: ::std::option::Option<u64>,
    itlb_loads: ::std::option::Option<u64>,
    itlb_load_misses: ::std::option::Option<u64>,
    branch_loads: ::std::option::Option<u64>,
    branch_load_misses: ::std::option::Option<u64>,
    node_loads: ::std::option::Option<u64>,
    node_load_misses: ::std::option::Option<u64>,
    node_stores: ::std::option::Option<u64>,
    node_store_misses: ::std::option::Option<u64>,
    node_prefetches: ::std::option::Option<u64>,
    node_prefetch_misses: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl PerfStatistics {
    pub fn new() -> PerfStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PerfStatistics {
        static mut instance: ::protobuf::lazy::Lazy<PerfStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PerfStatistics,
        };
        unsafe {
            instance.get(|| {
                PerfStatistics {
                    timestamp: ::std::option::Option::None,
                    duration: ::std::option::Option::None,
                    cycles: ::std::option::Option::None,
                    stalled_cycles_frontend: ::std::option::Option::None,
                    stalled_cycles_backend: ::std::option::Option::None,
                    instructions: ::std::option::Option::None,
                    cache_references: ::std::option::Option::None,
                    cache_misses: ::std::option::Option::None,
                    branches: ::std::option::Option::None,
                    branch_misses: ::std::option::Option::None,
                    bus_cycles: ::std::option::Option::None,
                    ref_cycles: ::std::option::Option::None,
                    cpu_clock: ::std::option::Option::None,
                    task_clock: ::std::option::Option::None,
                    page_faults: ::std::option::Option::None,
                    minor_faults: ::std::option::Option::None,
                    major_faults: ::std::option::Option::None,
                    context_switches: ::std::option::Option::None,
                    cpu_migrations: ::std::option::Option::None,
                    alignment_faults: ::std::option::Option::None,
                    emulation_faults: ::std::option::Option::None,
                    l1_dcache_loads: ::std::option::Option::None,
                    l1_dcache_load_misses: ::std::option::Option::None,
                    l1_dcache_stores: ::std::option::Option::None,
                    l1_dcache_store_misses: ::std::option::Option::None,
                    l1_dcache_prefetches: ::std::option::Option::None,
                    l1_dcache_prefetch_misses: ::std::option::Option::None,
                    l1_icache_loads: ::std::option::Option::None,
                    l1_icache_load_misses: ::std::option::Option::None,
                    l1_icache_prefetches: ::std::option::Option::None,
                    l1_icache_prefetch_misses: ::std::option::Option::None,
                    llc_loads: ::std::option::Option::None,
                    llc_load_misses: ::std::option::Option::None,
                    llc_stores: ::std::option::Option::None,
                    llc_store_misses: ::std::option::Option::None,
                    llc_prefetches: ::std::option::Option::None,
                    llc_prefetch_misses: ::std::option::Option::None,
                    dtlb_loads: ::std::option::Option::None,
                    dtlb_load_misses: ::std::option::Option::None,
                    dtlb_stores: ::std::option::Option::None,
                    dtlb_store_misses: ::std::option::Option::None,
                    dtlb_prefetches: ::std::option::Option::None,
                    dtlb_prefetch_misses: ::std::option::Option::None,
                    itlb_loads: ::std::option::Option::None,
                    itlb_load_misses: ::std::option::Option::None,
                    branch_loads: ::std::option::Option::None,
                    branch_load_misses: ::std::option::Option::None,
                    node_loads: ::std::option::Option::None,
                    node_load_misses: ::std::option::Option::None,
                    node_stores: ::std::option::Option::None,
                    node_store_misses: ::std::option::Option::None,
                    node_prefetches: ::std::option::Option::None,
                    node_prefetch_misses: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required double timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp<'a>(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    // required double duration = 2;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f64) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration<'a>(&self) -> f64 {
        self.duration.unwrap_or(0.)
    }

    // optional uint64 cycles = 3;

    pub fn clear_cycles(&mut self) {
        self.cycles = ::std::option::Option::None;
    }

    pub fn has_cycles(&self) -> bool {
        self.cycles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycles(&mut self, v: u64) {
        self.cycles = ::std::option::Option::Some(v);
    }

    pub fn get_cycles<'a>(&self) -> u64 {
        self.cycles.unwrap_or(0)
    }

    // optional uint64 stalled_cycles_frontend = 4;

    pub fn clear_stalled_cycles_frontend(&mut self) {
        self.stalled_cycles_frontend = ::std::option::Option::None;
    }

    pub fn has_stalled_cycles_frontend(&self) -> bool {
        self.stalled_cycles_frontend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stalled_cycles_frontend(&mut self, v: u64) {
        self.stalled_cycles_frontend = ::std::option::Option::Some(v);
    }

    pub fn get_stalled_cycles_frontend<'a>(&self) -> u64 {
        self.stalled_cycles_frontend.unwrap_or(0)
    }

    // optional uint64 stalled_cycles_backend = 5;

    pub fn clear_stalled_cycles_backend(&mut self) {
        self.stalled_cycles_backend = ::std::option::Option::None;
    }

    pub fn has_stalled_cycles_backend(&self) -> bool {
        self.stalled_cycles_backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stalled_cycles_backend(&mut self, v: u64) {
        self.stalled_cycles_backend = ::std::option::Option::Some(v);
    }

    pub fn get_stalled_cycles_backend<'a>(&self) -> u64 {
        self.stalled_cycles_backend.unwrap_or(0)
    }

    // optional uint64 instructions = 6;

    pub fn clear_instructions(&mut self) {
        self.instructions = ::std::option::Option::None;
    }

    pub fn has_instructions(&self) -> bool {
        self.instructions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instructions(&mut self, v: u64) {
        self.instructions = ::std::option::Option::Some(v);
    }

    pub fn get_instructions<'a>(&self) -> u64 {
        self.instructions.unwrap_or(0)
    }

    // optional uint64 cache_references = 7;

    pub fn clear_cache_references(&mut self) {
        self.cache_references = ::std::option::Option::None;
    }

    pub fn has_cache_references(&self) -> bool {
        self.cache_references.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_references(&mut self, v: u64) {
        self.cache_references = ::std::option::Option::Some(v);
    }

    pub fn get_cache_references<'a>(&self) -> u64 {
        self.cache_references.unwrap_or(0)
    }

    // optional uint64 cache_misses = 8;

    pub fn clear_cache_misses(&mut self) {
        self.cache_misses = ::std::option::Option::None;
    }

    pub fn has_cache_misses(&self) -> bool {
        self.cache_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_misses(&mut self, v: u64) {
        self.cache_misses = ::std::option::Option::Some(v);
    }

    pub fn get_cache_misses<'a>(&self) -> u64 {
        self.cache_misses.unwrap_or(0)
    }

    // optional uint64 branches = 9;

    pub fn clear_branches(&mut self) {
        self.branches = ::std::option::Option::None;
    }

    pub fn has_branches(&self) -> bool {
        self.branches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branches(&mut self, v: u64) {
        self.branches = ::std::option::Option::Some(v);
    }

    pub fn get_branches<'a>(&self) -> u64 {
        self.branches.unwrap_or(0)
    }

    // optional uint64 branch_misses = 10;

    pub fn clear_branch_misses(&mut self) {
        self.branch_misses = ::std::option::Option::None;
    }

    pub fn has_branch_misses(&self) -> bool {
        self.branch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_misses(&mut self, v: u64) {
        self.branch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_branch_misses<'a>(&self) -> u64 {
        self.branch_misses.unwrap_or(0)
    }

    // optional uint64 bus_cycles = 11;

    pub fn clear_bus_cycles(&mut self) {
        self.bus_cycles = ::std::option::Option::None;
    }

    pub fn has_bus_cycles(&self) -> bool {
        self.bus_cycles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bus_cycles(&mut self, v: u64) {
        self.bus_cycles = ::std::option::Option::Some(v);
    }

    pub fn get_bus_cycles<'a>(&self) -> u64 {
        self.bus_cycles.unwrap_or(0)
    }

    // optional uint64 ref_cycles = 12;

    pub fn clear_ref_cycles(&mut self) {
        self.ref_cycles = ::std::option::Option::None;
    }

    pub fn has_ref_cycles(&self) -> bool {
        self.ref_cycles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ref_cycles(&mut self, v: u64) {
        self.ref_cycles = ::std::option::Option::Some(v);
    }

    pub fn get_ref_cycles<'a>(&self) -> u64 {
        self.ref_cycles.unwrap_or(0)
    }

    // optional double cpu_clock = 13;

    pub fn clear_cpu_clock(&mut self) {
        self.cpu_clock = ::std::option::Option::None;
    }

    pub fn has_cpu_clock(&self) -> bool {
        self.cpu_clock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_clock(&mut self, v: f64) {
        self.cpu_clock = ::std::option::Option::Some(v);
    }

    pub fn get_cpu_clock<'a>(&self) -> f64 {
        self.cpu_clock.unwrap_or(0.)
    }

    // optional double task_clock = 14;

    pub fn clear_task_clock(&mut self) {
        self.task_clock = ::std::option::Option::None;
    }

    pub fn has_task_clock(&self) -> bool {
        self.task_clock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_clock(&mut self, v: f64) {
        self.task_clock = ::std::option::Option::Some(v);
    }

    pub fn get_task_clock<'a>(&self) -> f64 {
        self.task_clock.unwrap_or(0.)
    }

    // optional uint64 page_faults = 15;

    pub fn clear_page_faults(&mut self) {
        self.page_faults = ::std::option::Option::None;
    }

    pub fn has_page_faults(&self) -> bool {
        self.page_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_faults(&mut self, v: u64) {
        self.page_faults = ::std::option::Option::Some(v);
    }

    pub fn get_page_faults<'a>(&self) -> u64 {
        self.page_faults.unwrap_or(0)
    }

    // optional uint64 minor_faults = 16;

    pub fn clear_minor_faults(&mut self) {
        self.minor_faults = ::std::option::Option::None;
    }

    pub fn has_minor_faults(&self) -> bool {
        self.minor_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor_faults(&mut self, v: u64) {
        self.minor_faults = ::std::option::Option::Some(v);
    }

    pub fn get_minor_faults<'a>(&self) -> u64 {
        self.minor_faults.unwrap_or(0)
    }

    // optional uint64 major_faults = 17;

    pub fn clear_major_faults(&mut self) {
        self.major_faults = ::std::option::Option::None;
    }

    pub fn has_major_faults(&self) -> bool {
        self.major_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major_faults(&mut self, v: u64) {
        self.major_faults = ::std::option::Option::Some(v);
    }

    pub fn get_major_faults<'a>(&self) -> u64 {
        self.major_faults.unwrap_or(0)
    }

    // optional uint64 context_switches = 18;

    pub fn clear_context_switches(&mut self) {
        self.context_switches = ::std::option::Option::None;
    }

    pub fn has_context_switches(&self) -> bool {
        self.context_switches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_switches(&mut self, v: u64) {
        self.context_switches = ::std::option::Option::Some(v);
    }

    pub fn get_context_switches<'a>(&self) -> u64 {
        self.context_switches.unwrap_or(0)
    }

    // optional uint64 cpu_migrations = 19;

    pub fn clear_cpu_migrations(&mut self) {
        self.cpu_migrations = ::std::option::Option::None;
    }

    pub fn has_cpu_migrations(&self) -> bool {
        self.cpu_migrations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_migrations(&mut self, v: u64) {
        self.cpu_migrations = ::std::option::Option::Some(v);
    }

    pub fn get_cpu_migrations<'a>(&self) -> u64 {
        self.cpu_migrations.unwrap_or(0)
    }

    // optional uint64 alignment_faults = 20;

    pub fn clear_alignment_faults(&mut self) {
        self.alignment_faults = ::std::option::Option::None;
    }

    pub fn has_alignment_faults(&self) -> bool {
        self.alignment_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alignment_faults(&mut self, v: u64) {
        self.alignment_faults = ::std::option::Option::Some(v);
    }

    pub fn get_alignment_faults<'a>(&self) -> u64 {
        self.alignment_faults.unwrap_or(0)
    }

    // optional uint64 emulation_faults = 21;

    pub fn clear_emulation_faults(&mut self) {
        self.emulation_faults = ::std::option::Option::None;
    }

    pub fn has_emulation_faults(&self) -> bool {
        self.emulation_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emulation_faults(&mut self, v: u64) {
        self.emulation_faults = ::std::option::Option::Some(v);
    }

    pub fn get_emulation_faults<'a>(&self) -> u64 {
        self.emulation_faults.unwrap_or(0)
    }

    // optional uint64 l1_dcache_loads = 22;

    pub fn clear_l1_dcache_loads(&mut self) {
        self.l1_dcache_loads = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_loads(&self) -> bool {
        self.l1_dcache_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_loads(&mut self, v: u64) {
        self.l1_dcache_loads = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_loads<'a>(&self) -> u64 {
        self.l1_dcache_loads.unwrap_or(0)
    }

    // optional uint64 l1_dcache_load_misses = 23;

    pub fn clear_l1_dcache_load_misses(&mut self) {
        self.l1_dcache_load_misses = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_load_misses(&self) -> bool {
        self.l1_dcache_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_load_misses(&mut self, v: u64) {
        self.l1_dcache_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_load_misses<'a>(&self) -> u64 {
        self.l1_dcache_load_misses.unwrap_or(0)
    }

    // optional uint64 l1_dcache_stores = 24;

    pub fn clear_l1_dcache_stores(&mut self) {
        self.l1_dcache_stores = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_stores(&self) -> bool {
        self.l1_dcache_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_stores(&mut self, v: u64) {
        self.l1_dcache_stores = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_stores<'a>(&self) -> u64 {
        self.l1_dcache_stores.unwrap_or(0)
    }

    // optional uint64 l1_dcache_store_misses = 25;

    pub fn clear_l1_dcache_store_misses(&mut self) {
        self.l1_dcache_store_misses = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_store_misses(&self) -> bool {
        self.l1_dcache_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_store_misses(&mut self, v: u64) {
        self.l1_dcache_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_store_misses<'a>(&self) -> u64 {
        self.l1_dcache_store_misses.unwrap_or(0)
    }

    // optional uint64 l1_dcache_prefetches = 26;

    pub fn clear_l1_dcache_prefetches(&mut self) {
        self.l1_dcache_prefetches = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_prefetches(&self) -> bool {
        self.l1_dcache_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_prefetches(&mut self, v: u64) {
        self.l1_dcache_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_prefetches<'a>(&self) -> u64 {
        self.l1_dcache_prefetches.unwrap_or(0)
    }

    // optional uint64 l1_dcache_prefetch_misses = 27;

    pub fn clear_l1_dcache_prefetch_misses(&mut self) {
        self.l1_dcache_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_prefetch_misses(&self) -> bool {
        self.l1_dcache_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_prefetch_misses(&mut self, v: u64) {
        self.l1_dcache_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_prefetch_misses<'a>(&self) -> u64 {
        self.l1_dcache_prefetch_misses.unwrap_or(0)
    }

    // optional uint64 l1_icache_loads = 28;

    pub fn clear_l1_icache_loads(&mut self) {
        self.l1_icache_loads = ::std::option::Option::None;
    }

    pub fn has_l1_icache_loads(&self) -> bool {
        self.l1_icache_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_loads(&mut self, v: u64) {
        self.l1_icache_loads = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_loads<'a>(&self) -> u64 {
        self.l1_icache_loads.unwrap_or(0)
    }

    // optional uint64 l1_icache_load_misses = 29;

    pub fn clear_l1_icache_load_misses(&mut self) {
        self.l1_icache_load_misses = ::std::option::Option::None;
    }

    pub fn has_l1_icache_load_misses(&self) -> bool {
        self.l1_icache_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_load_misses(&mut self, v: u64) {
        self.l1_icache_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_load_misses<'a>(&self) -> u64 {
        self.l1_icache_load_misses.unwrap_or(0)
    }

    // optional uint64 l1_icache_prefetches = 30;

    pub fn clear_l1_icache_prefetches(&mut self) {
        self.l1_icache_prefetches = ::std::option::Option::None;
    }

    pub fn has_l1_icache_prefetches(&self) -> bool {
        self.l1_icache_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_prefetches(&mut self, v: u64) {
        self.l1_icache_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_prefetches<'a>(&self) -> u64 {
        self.l1_icache_prefetches.unwrap_or(0)
    }

    // optional uint64 l1_icache_prefetch_misses = 31;

    pub fn clear_l1_icache_prefetch_misses(&mut self) {
        self.l1_icache_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_l1_icache_prefetch_misses(&self) -> bool {
        self.l1_icache_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_prefetch_misses(&mut self, v: u64) {
        self.l1_icache_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_prefetch_misses<'a>(&self) -> u64 {
        self.l1_icache_prefetch_misses.unwrap_or(0)
    }

    // optional uint64 llc_loads = 32;

    pub fn clear_llc_loads(&mut self) {
        self.llc_loads = ::std::option::Option::None;
    }

    pub fn has_llc_loads(&self) -> bool {
        self.llc_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_loads(&mut self, v: u64) {
        self.llc_loads = ::std::option::Option::Some(v);
    }

    pub fn get_llc_loads<'a>(&self) -> u64 {
        self.llc_loads.unwrap_or(0)
    }

    // optional uint64 llc_load_misses = 33;

    pub fn clear_llc_load_misses(&mut self) {
        self.llc_load_misses = ::std::option::Option::None;
    }

    pub fn has_llc_load_misses(&self) -> bool {
        self.llc_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_load_misses(&mut self, v: u64) {
        self.llc_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_llc_load_misses<'a>(&self) -> u64 {
        self.llc_load_misses.unwrap_or(0)
    }

    // optional uint64 llc_stores = 34;

    pub fn clear_llc_stores(&mut self) {
        self.llc_stores = ::std::option::Option::None;
    }

    pub fn has_llc_stores(&self) -> bool {
        self.llc_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_stores(&mut self, v: u64) {
        self.llc_stores = ::std::option::Option::Some(v);
    }

    pub fn get_llc_stores<'a>(&self) -> u64 {
        self.llc_stores.unwrap_or(0)
    }

    // optional uint64 llc_store_misses = 35;

    pub fn clear_llc_store_misses(&mut self) {
        self.llc_store_misses = ::std::option::Option::None;
    }

    pub fn has_llc_store_misses(&self) -> bool {
        self.llc_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_store_misses(&mut self, v: u64) {
        self.llc_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_llc_store_misses<'a>(&self) -> u64 {
        self.llc_store_misses.unwrap_or(0)
    }

    // optional uint64 llc_prefetches = 36;

    pub fn clear_llc_prefetches(&mut self) {
        self.llc_prefetches = ::std::option::Option::None;
    }

    pub fn has_llc_prefetches(&self) -> bool {
        self.llc_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_prefetches(&mut self, v: u64) {
        self.llc_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_llc_prefetches<'a>(&self) -> u64 {
        self.llc_prefetches.unwrap_or(0)
    }

    // optional uint64 llc_prefetch_misses = 37;

    pub fn clear_llc_prefetch_misses(&mut self) {
        self.llc_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_llc_prefetch_misses(&self) -> bool {
        self.llc_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_prefetch_misses(&mut self, v: u64) {
        self.llc_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_llc_prefetch_misses<'a>(&self) -> u64 {
        self.llc_prefetch_misses.unwrap_or(0)
    }

    // optional uint64 dtlb_loads = 38;

    pub fn clear_dtlb_loads(&mut self) {
        self.dtlb_loads = ::std::option::Option::None;
    }

    pub fn has_dtlb_loads(&self) -> bool {
        self.dtlb_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_loads(&mut self, v: u64) {
        self.dtlb_loads = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_loads<'a>(&self) -> u64 {
        self.dtlb_loads.unwrap_or(0)
    }

    // optional uint64 dtlb_load_misses = 39;

    pub fn clear_dtlb_load_misses(&mut self) {
        self.dtlb_load_misses = ::std::option::Option::None;
    }

    pub fn has_dtlb_load_misses(&self) -> bool {
        self.dtlb_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_load_misses(&mut self, v: u64) {
        self.dtlb_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_load_misses<'a>(&self) -> u64 {
        self.dtlb_load_misses.unwrap_or(0)
    }

    // optional uint64 dtlb_stores = 40;

    pub fn clear_dtlb_stores(&mut self) {
        self.dtlb_stores = ::std::option::Option::None;
    }

    pub fn has_dtlb_stores(&self) -> bool {
        self.dtlb_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_stores(&mut self, v: u64) {
        self.dtlb_stores = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_stores<'a>(&self) -> u64 {
        self.dtlb_stores.unwrap_or(0)
    }

    // optional uint64 dtlb_store_misses = 41;

    pub fn clear_dtlb_store_misses(&mut self) {
        self.dtlb_store_misses = ::std::option::Option::None;
    }

    pub fn has_dtlb_store_misses(&self) -> bool {
        self.dtlb_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_store_misses(&mut self, v: u64) {
        self.dtlb_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_store_misses<'a>(&self) -> u64 {
        self.dtlb_store_misses.unwrap_or(0)
    }

    // optional uint64 dtlb_prefetches = 42;

    pub fn clear_dtlb_prefetches(&mut self) {
        self.dtlb_prefetches = ::std::option::Option::None;
    }

    pub fn has_dtlb_prefetches(&self) -> bool {
        self.dtlb_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_prefetches(&mut self, v: u64) {
        self.dtlb_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_prefetches<'a>(&self) -> u64 {
        self.dtlb_prefetches.unwrap_or(0)
    }

    // optional uint64 dtlb_prefetch_misses = 43;

    pub fn clear_dtlb_prefetch_misses(&mut self) {
        self.dtlb_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_dtlb_prefetch_misses(&self) -> bool {
        self.dtlb_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_prefetch_misses(&mut self, v: u64) {
        self.dtlb_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_prefetch_misses<'a>(&self) -> u64 {
        self.dtlb_prefetch_misses.unwrap_or(0)
    }

    // optional uint64 itlb_loads = 44;

    pub fn clear_itlb_loads(&mut self) {
        self.itlb_loads = ::std::option::Option::None;
    }

    pub fn has_itlb_loads(&self) -> bool {
        self.itlb_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itlb_loads(&mut self, v: u64) {
        self.itlb_loads = ::std::option::Option::Some(v);
    }

    pub fn get_itlb_loads<'a>(&self) -> u64 {
        self.itlb_loads.unwrap_or(0)
    }

    // optional uint64 itlb_load_misses = 45;

    pub fn clear_itlb_load_misses(&mut self) {
        self.itlb_load_misses = ::std::option::Option::None;
    }

    pub fn has_itlb_load_misses(&self) -> bool {
        self.itlb_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itlb_load_misses(&mut self, v: u64) {
        self.itlb_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_itlb_load_misses<'a>(&self) -> u64 {
        self.itlb_load_misses.unwrap_or(0)
    }

    // optional uint64 branch_loads = 46;

    pub fn clear_branch_loads(&mut self) {
        self.branch_loads = ::std::option::Option::None;
    }

    pub fn has_branch_loads(&self) -> bool {
        self.branch_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_loads(&mut self, v: u64) {
        self.branch_loads = ::std::option::Option::Some(v);
    }

    pub fn get_branch_loads<'a>(&self) -> u64 {
        self.branch_loads.unwrap_or(0)
    }

    // optional uint64 branch_load_misses = 47;

    pub fn clear_branch_load_misses(&mut self) {
        self.branch_load_misses = ::std::option::Option::None;
    }

    pub fn has_branch_load_misses(&self) -> bool {
        self.branch_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_load_misses(&mut self, v: u64) {
        self.branch_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_branch_load_misses<'a>(&self) -> u64 {
        self.branch_load_misses.unwrap_or(0)
    }

    // optional uint64 node_loads = 48;

    pub fn clear_node_loads(&mut self) {
        self.node_loads = ::std::option::Option::None;
    }

    pub fn has_node_loads(&self) -> bool {
        self.node_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_loads(&mut self, v: u64) {
        self.node_loads = ::std::option::Option::Some(v);
    }

    pub fn get_node_loads<'a>(&self) -> u64 {
        self.node_loads.unwrap_or(0)
    }

    // optional uint64 node_load_misses = 49;

    pub fn clear_node_load_misses(&mut self) {
        self.node_load_misses = ::std::option::Option::None;
    }

    pub fn has_node_load_misses(&self) -> bool {
        self.node_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_load_misses(&mut self, v: u64) {
        self.node_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_node_load_misses<'a>(&self) -> u64 {
        self.node_load_misses.unwrap_or(0)
    }

    // optional uint64 node_stores = 50;

    pub fn clear_node_stores(&mut self) {
        self.node_stores = ::std::option::Option::None;
    }

    pub fn has_node_stores(&self) -> bool {
        self.node_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_stores(&mut self, v: u64) {
        self.node_stores = ::std::option::Option::Some(v);
    }

    pub fn get_node_stores<'a>(&self) -> u64 {
        self.node_stores.unwrap_or(0)
    }

    // optional uint64 node_store_misses = 51;

    pub fn clear_node_store_misses(&mut self) {
        self.node_store_misses = ::std::option::Option::None;
    }

    pub fn has_node_store_misses(&self) -> bool {
        self.node_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_store_misses(&mut self, v: u64) {
        self.node_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_node_store_misses<'a>(&self) -> u64 {
        self.node_store_misses.unwrap_or(0)
    }

    // optional uint64 node_prefetches = 52;

    pub fn clear_node_prefetches(&mut self) {
        self.node_prefetches = ::std::option::Option::None;
    }

    pub fn has_node_prefetches(&self) -> bool {
        self.node_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_prefetches(&mut self, v: u64) {
        self.node_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_node_prefetches<'a>(&self) -> u64 {
        self.node_prefetches.unwrap_or(0)
    }

    // optional uint64 node_prefetch_misses = 53;

    pub fn clear_node_prefetch_misses(&mut self) {
        self.node_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_node_prefetch_misses(&self) -> bool {
        self.node_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_prefetch_misses(&mut self, v: u64) {
        self.node_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_node_prefetch_misses<'a>(&self) -> u64 {
        self.node_prefetch_misses.unwrap_or(0)
    }
}

impl ::protobuf::Message for PerfStatistics {
    fn is_initialized(&self) -> bool {
        if self.timestamp.is_none() {
            return false;
        };
        if self.duration.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.cycles = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.stalled_cycles_frontend = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.stalled_cycles_backend = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.instructions = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.cache_references = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.cache_misses = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.branches = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.branch_misses = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bus_cycles = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.ref_cycles = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.cpu_clock = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.task_clock = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.page_faults = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.minor_faults = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.major_faults = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.context_switches = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.cpu_migrations = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.alignment_faults = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.emulation_faults = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_loads = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_load_misses = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_stores = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_store_misses = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_prefetches = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_icache_loads = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_icache_load_misses = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_icache_prefetches = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_icache_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_loads = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_load_misses = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_stores = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_store_misses = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_prefetches = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_loads = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_load_misses = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_stores = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_store_misses = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_prefetches = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.itlb_loads = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.itlb_load_misses = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.branch_loads = ::std::option::Option::Some(tmp);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.branch_load_misses = ::std::option::Option::Some(tmp);
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_loads = ::std::option::Option::Some(tmp);
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_load_misses = ::std::option::Option::Some(tmp);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_stores = ::std::option::Option::Some(tmp);
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_store_misses = ::std::option::Option::Some(tmp);
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_prefetches = ::std::option::Option::Some(tmp);
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp.is_some() {
            my_size += 9;
        };
        if self.duration.is_some() {
            my_size += 9;
        };
        for value in self.cycles.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stalled_cycles_frontend.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stalled_cycles_backend.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.instructions.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cache_references.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cache_misses.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.branches.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.branch_misses.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bus_cycles.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ref_cycles.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.cpu_clock.is_some() {
            my_size += 9;
        };
        if self.task_clock.is_some() {
            my_size += 9;
        };
        for value in self.page_faults.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.minor_faults.iter() {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.major_faults.iter() {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.context_switches.iter() {
            my_size += ::protobuf::rt::value_size(18, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cpu_migrations.iter() {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.alignment_faults.iter() {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.emulation_faults.iter() {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_loads.iter() {
            my_size += ::protobuf::rt::value_size(22, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(23, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_stores.iter() {
            my_size += ::protobuf::rt::value_size(24, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_store_misses.iter() {
            my_size += ::protobuf::rt::value_size(25, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_prefetches.iter() {
            my_size += ::protobuf::rt::value_size(26, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_prefetch_misses.iter() {
            my_size += ::protobuf::rt::value_size(27, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_icache_loads.iter() {
            my_size += ::protobuf::rt::value_size(28, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_icache_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(29, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_icache_prefetches.iter() {
            my_size += ::protobuf::rt::value_size(30, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_icache_prefetch_misses.iter() {
            my_size += ::protobuf::rt::value_size(31, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_loads.iter() {
            my_size += ::protobuf::rt::value_size(32, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(33, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_stores.iter() {
            my_size += ::protobuf::rt::value_size(34, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_store_misses.iter() {
            my_size += ::protobuf::rt::value_size(35, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_prefetches.iter() {
            my_size += ::protobuf::rt::value_size(36, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_prefetch_misses.iter() {
            my_size += ::protobuf::rt::value_size(37, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_loads.iter() {
            my_size += ::protobuf::rt::value_size(38, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(39, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_stores.iter() {
            my_size += ::protobuf::rt::value_size(40, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_store_misses.iter() {
            my_size += ::protobuf::rt::value_size(41, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_prefetches.iter() {
            my_size += ::protobuf::rt::value_size(42, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_prefetch_misses.iter() {
            my_size += ::protobuf::rt::value_size(43, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.itlb_loads.iter() {
            my_size += ::protobuf::rt::value_size(44, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.itlb_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(45, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.branch_loads.iter() {
            my_size += ::protobuf::rt::value_size(46, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.branch_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(47, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_loads.iter() {
            my_size += ::protobuf::rt::value_size(48, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(49, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_stores.iter() {
            my_size += ::protobuf::rt::value_size(50, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_store_misses.iter() {
            my_size += ::protobuf::rt::value_size(51, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_prefetches.iter() {
            my_size += ::protobuf::rt::value_size(52, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_prefetch_misses.iter() {
            my_size += ::protobuf::rt::value_size(53, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            try!(os.write_double(1, v));
        };
        if let Some(v) = self.duration {
            try!(os.write_double(2, v));
        };
        if let Some(v) = self.cycles {
            try!(os.write_uint64(3, v));
        };
        if let Some(v) = self.stalled_cycles_frontend {
            try!(os.write_uint64(4, v));
        };
        if let Some(v) = self.stalled_cycles_backend {
            try!(os.write_uint64(5, v));
        };
        if let Some(v) = self.instructions {
            try!(os.write_uint64(6, v));
        };
        if let Some(v) = self.cache_references {
            try!(os.write_uint64(7, v));
        };
        if let Some(v) = self.cache_misses {
            try!(os.write_uint64(8, v));
        };
        if let Some(v) = self.branches {
            try!(os.write_uint64(9, v));
        };
        if let Some(v) = self.branch_misses {
            try!(os.write_uint64(10, v));
        };
        if let Some(v) = self.bus_cycles {
            try!(os.write_uint64(11, v));
        };
        if let Some(v) = self.ref_cycles {
            try!(os.write_uint64(12, v));
        };
        if let Some(v) = self.cpu_clock {
            try!(os.write_double(13, v));
        };
        if let Some(v) = self.task_clock {
            try!(os.write_double(14, v));
        };
        if let Some(v) = self.page_faults {
            try!(os.write_uint64(15, v));
        };
        if let Some(v) = self.minor_faults {
            try!(os.write_uint64(16, v));
        };
        if let Some(v) = self.major_faults {
            try!(os.write_uint64(17, v));
        };
        if let Some(v) = self.context_switches {
            try!(os.write_uint64(18, v));
        };
        if let Some(v) = self.cpu_migrations {
            try!(os.write_uint64(19, v));
        };
        if let Some(v) = self.alignment_faults {
            try!(os.write_uint64(20, v));
        };
        if let Some(v) = self.emulation_faults {
            try!(os.write_uint64(21, v));
        };
        if let Some(v) = self.l1_dcache_loads {
            try!(os.write_uint64(22, v));
        };
        if let Some(v) = self.l1_dcache_load_misses {
            try!(os.write_uint64(23, v));
        };
        if let Some(v) = self.l1_dcache_stores {
            try!(os.write_uint64(24, v));
        };
        if let Some(v) = self.l1_dcache_store_misses {
            try!(os.write_uint64(25, v));
        };
        if let Some(v) = self.l1_dcache_prefetches {
            try!(os.write_uint64(26, v));
        };
        if let Some(v) = self.l1_dcache_prefetch_misses {
            try!(os.write_uint64(27, v));
        };
        if let Some(v) = self.l1_icache_loads {
            try!(os.write_uint64(28, v));
        };
        if let Some(v) = self.l1_icache_load_misses {
            try!(os.write_uint64(29, v));
        };
        if let Some(v) = self.l1_icache_prefetches {
            try!(os.write_uint64(30, v));
        };
        if let Some(v) = self.l1_icache_prefetch_misses {
            try!(os.write_uint64(31, v));
        };
        if let Some(v) = self.llc_loads {
            try!(os.write_uint64(32, v));
        };
        if let Some(v) = self.llc_load_misses {
            try!(os.write_uint64(33, v));
        };
        if let Some(v) = self.llc_stores {
            try!(os.write_uint64(34, v));
        };
        if let Some(v) = self.llc_store_misses {
            try!(os.write_uint64(35, v));
        };
        if let Some(v) = self.llc_prefetches {
            try!(os.write_uint64(36, v));
        };
        if let Some(v) = self.llc_prefetch_misses {
            try!(os.write_uint64(37, v));
        };
        if let Some(v) = self.dtlb_loads {
            try!(os.write_uint64(38, v));
        };
        if let Some(v) = self.dtlb_load_misses {
            try!(os.write_uint64(39, v));
        };
        if let Some(v) = self.dtlb_stores {
            try!(os.write_uint64(40, v));
        };
        if let Some(v) = self.dtlb_store_misses {
            try!(os.write_uint64(41, v));
        };
        if let Some(v) = self.dtlb_prefetches {
            try!(os.write_uint64(42, v));
        };
        if let Some(v) = self.dtlb_prefetch_misses {
            try!(os.write_uint64(43, v));
        };
        if let Some(v) = self.itlb_loads {
            try!(os.write_uint64(44, v));
        };
        if let Some(v) = self.itlb_load_misses {
            try!(os.write_uint64(45, v));
        };
        if let Some(v) = self.branch_loads {
            try!(os.write_uint64(46, v));
        };
        if let Some(v) = self.branch_load_misses {
            try!(os.write_uint64(47, v));
        };
        if let Some(v) = self.node_loads {
            try!(os.write_uint64(48, v));
        };
        if let Some(v) = self.node_load_misses {
            try!(os.write_uint64(49, v));
        };
        if let Some(v) = self.node_stores {
            try!(os.write_uint64(50, v));
        };
        if let Some(v) = self.node_store_misses {
            try!(os.write_uint64(51, v));
        };
        if let Some(v) = self.node_prefetches {
            try!(os.write_uint64(52, v));
        };
        if let Some(v) = self.node_prefetch_misses {
            try!(os.write_uint64(53, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<PerfStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PerfStatistics {
    fn new() -> PerfStatistics {
        PerfStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<PerfStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "timestamp",
                    PerfStatistics::has_timestamp,
                    PerfStatistics::get_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "duration",
                    PerfStatistics::has_duration,
                    PerfStatistics::get_duration,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "cycles",
                    PerfStatistics::has_cycles,
                    PerfStatistics::get_cycles,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "stalled_cycles_frontend",
                    PerfStatistics::has_stalled_cycles_frontend,
                    PerfStatistics::get_stalled_cycles_frontend,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "stalled_cycles_backend",
                    PerfStatistics::has_stalled_cycles_backend,
                    PerfStatistics::get_stalled_cycles_backend,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "instructions",
                    PerfStatistics::has_instructions,
                    PerfStatistics::get_instructions,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "cache_references",
                    PerfStatistics::has_cache_references,
                    PerfStatistics::get_cache_references,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "cache_misses",
                    PerfStatistics::has_cache_misses,
                    PerfStatistics::get_cache_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "branches",
                    PerfStatistics::has_branches,
                    PerfStatistics::get_branches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "branch_misses",
                    PerfStatistics::has_branch_misses,
                    PerfStatistics::get_branch_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bus_cycles",
                    PerfStatistics::has_bus_cycles,
                    PerfStatistics::get_bus_cycles,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "ref_cycles",
                    PerfStatistics::has_ref_cycles,
                    PerfStatistics::get_ref_cycles,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "cpu_clock",
                    PerfStatistics::has_cpu_clock,
                    PerfStatistics::get_cpu_clock,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "task_clock",
                    PerfStatistics::has_task_clock,
                    PerfStatistics::get_task_clock,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "page_faults",
                    PerfStatistics::has_page_faults,
                    PerfStatistics::get_page_faults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "minor_faults",
                    PerfStatistics::has_minor_faults,
                    PerfStatistics::get_minor_faults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "major_faults",
                    PerfStatistics::has_major_faults,
                    PerfStatistics::get_major_faults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "context_switches",
                    PerfStatistics::has_context_switches,
                    PerfStatistics::get_context_switches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "cpu_migrations",
                    PerfStatistics::has_cpu_migrations,
                    PerfStatistics::get_cpu_migrations,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "alignment_faults",
                    PerfStatistics::has_alignment_faults,
                    PerfStatistics::get_alignment_faults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "emulation_faults",
                    PerfStatistics::has_emulation_faults,
                    PerfStatistics::get_emulation_faults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_loads",
                    PerfStatistics::has_l1_dcache_loads,
                    PerfStatistics::get_l1_dcache_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_load_misses",
                    PerfStatistics::has_l1_dcache_load_misses,
                    PerfStatistics::get_l1_dcache_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_stores",
                    PerfStatistics::has_l1_dcache_stores,
                    PerfStatistics::get_l1_dcache_stores,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_store_misses",
                    PerfStatistics::has_l1_dcache_store_misses,
                    PerfStatistics::get_l1_dcache_store_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_prefetches",
                    PerfStatistics::has_l1_dcache_prefetches,
                    PerfStatistics::get_l1_dcache_prefetches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_prefetch_misses",
                    PerfStatistics::has_l1_dcache_prefetch_misses,
                    PerfStatistics::get_l1_dcache_prefetch_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_icache_loads",
                    PerfStatistics::has_l1_icache_loads,
                    PerfStatistics::get_l1_icache_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_icache_load_misses",
                    PerfStatistics::has_l1_icache_load_misses,
                    PerfStatistics::get_l1_icache_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_icache_prefetches",
                    PerfStatistics::has_l1_icache_prefetches,
                    PerfStatistics::get_l1_icache_prefetches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_icache_prefetch_misses",
                    PerfStatistics::has_l1_icache_prefetch_misses,
                    PerfStatistics::get_l1_icache_prefetch_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_loads",
                    PerfStatistics::has_llc_loads,
                    PerfStatistics::get_llc_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_load_misses",
                    PerfStatistics::has_llc_load_misses,
                    PerfStatistics::get_llc_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_stores",
                    PerfStatistics::has_llc_stores,
                    PerfStatistics::get_llc_stores,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_store_misses",
                    PerfStatistics::has_llc_store_misses,
                    PerfStatistics::get_llc_store_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_prefetches",
                    PerfStatistics::has_llc_prefetches,
                    PerfStatistics::get_llc_prefetches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_prefetch_misses",
                    PerfStatistics::has_llc_prefetch_misses,
                    PerfStatistics::get_llc_prefetch_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_loads",
                    PerfStatistics::has_dtlb_loads,
                    PerfStatistics::get_dtlb_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_load_misses",
                    PerfStatistics::has_dtlb_load_misses,
                    PerfStatistics::get_dtlb_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_stores",
                    PerfStatistics::has_dtlb_stores,
                    PerfStatistics::get_dtlb_stores,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_store_misses",
                    PerfStatistics::has_dtlb_store_misses,
                    PerfStatistics::get_dtlb_store_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_prefetches",
                    PerfStatistics::has_dtlb_prefetches,
                    PerfStatistics::get_dtlb_prefetches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_prefetch_misses",
                    PerfStatistics::has_dtlb_prefetch_misses,
                    PerfStatistics::get_dtlb_prefetch_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "itlb_loads",
                    PerfStatistics::has_itlb_loads,
                    PerfStatistics::get_itlb_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "itlb_load_misses",
                    PerfStatistics::has_itlb_load_misses,
                    PerfStatistics::get_itlb_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "branch_loads",
                    PerfStatistics::has_branch_loads,
                    PerfStatistics::get_branch_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "branch_load_misses",
                    PerfStatistics::has_branch_load_misses,
                    PerfStatistics::get_branch_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_loads",
                    PerfStatistics::has_node_loads,
                    PerfStatistics::get_node_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_load_misses",
                    PerfStatistics::has_node_load_misses,
                    PerfStatistics::get_node_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_stores",
                    PerfStatistics::has_node_stores,
                    PerfStatistics::get_node_stores,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_store_misses",
                    PerfStatistics::has_node_store_misses,
                    PerfStatistics::get_node_store_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_prefetches",
                    PerfStatistics::has_node_prefetches,
                    PerfStatistics::get_node_prefetches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_prefetch_misses",
                    PerfStatistics::has_node_prefetch_misses,
                    PerfStatistics::get_node_prefetch_misses,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PerfStatistics>(
                    "PerfStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PerfStatistics {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_duration();
        self.clear_cycles();
        self.clear_stalled_cycles_frontend();
        self.clear_stalled_cycles_backend();
        self.clear_instructions();
        self.clear_cache_references();
        self.clear_cache_misses();
        self.clear_branches();
        self.clear_branch_misses();
        self.clear_bus_cycles();
        self.clear_ref_cycles();
        self.clear_cpu_clock();
        self.clear_task_clock();
        self.clear_page_faults();
        self.clear_minor_faults();
        self.clear_major_faults();
        self.clear_context_switches();
        self.clear_cpu_migrations();
        self.clear_alignment_faults();
        self.clear_emulation_faults();
        self.clear_l1_dcache_loads();
        self.clear_l1_dcache_load_misses();
        self.clear_l1_dcache_stores();
        self.clear_l1_dcache_store_misses();
        self.clear_l1_dcache_prefetches();
        self.clear_l1_dcache_prefetch_misses();
        self.clear_l1_icache_loads();
        self.clear_l1_icache_load_misses();
        self.clear_l1_icache_prefetches();
        self.clear_l1_icache_prefetch_misses();
        self.clear_llc_loads();
        self.clear_llc_load_misses();
        self.clear_llc_stores();
        self.clear_llc_store_misses();
        self.clear_llc_prefetches();
        self.clear_llc_prefetch_misses();
        self.clear_dtlb_loads();
        self.clear_dtlb_load_misses();
        self.clear_dtlb_stores();
        self.clear_dtlb_store_misses();
        self.clear_dtlb_prefetches();
        self.clear_dtlb_prefetch_misses();
        self.clear_itlb_loads();
        self.clear_itlb_load_misses();
        self.clear_branch_loads();
        self.clear_branch_load_misses();
        self.clear_node_loads();
        self.clear_node_load_misses();
        self.clear_node_stores();
        self.clear_node_store_misses();
        self.clear_node_prefetches();
        self.clear_node_prefetch_misses();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for PerfStatistics {
    fn eq(&self, other: &PerfStatistics) -> bool {
        self.timestamp == other.timestamp &&
        self.duration == other.duration &&
        self.cycles == other.cycles &&
        self.stalled_cycles_frontend == other.stalled_cycles_frontend &&
        self.stalled_cycles_backend == other.stalled_cycles_backend &&
        self.instructions == other.instructions &&
        self.cache_references == other.cache_references &&
        self.cache_misses == other.cache_misses &&
        self.branches == other.branches &&
        self.branch_misses == other.branch_misses &&
        self.bus_cycles == other.bus_cycles &&
        self.ref_cycles == other.ref_cycles &&
        self.cpu_clock == other.cpu_clock &&
        self.task_clock == other.task_clock &&
        self.page_faults == other.page_faults &&
        self.minor_faults == other.minor_faults &&
        self.major_faults == other.major_faults &&
        self.context_switches == other.context_switches &&
        self.cpu_migrations == other.cpu_migrations &&
        self.alignment_faults == other.alignment_faults &&
        self.emulation_faults == other.emulation_faults &&
        self.l1_dcache_loads == other.l1_dcache_loads &&
        self.l1_dcache_load_misses == other.l1_dcache_load_misses &&
        self.l1_dcache_stores == other.l1_dcache_stores &&
        self.l1_dcache_store_misses == other.l1_dcache_store_misses &&
        self.l1_dcache_prefetches == other.l1_dcache_prefetches &&
        self.l1_dcache_prefetch_misses == other.l1_dcache_prefetch_misses &&
        self.l1_icache_loads == other.l1_icache_loads &&
        self.l1_icache_load_misses == other.l1_icache_load_misses &&
        self.l1_icache_prefetches == other.l1_icache_prefetches &&
        self.l1_icache_prefetch_misses == other.l1_icache_prefetch_misses &&
        self.llc_loads == other.llc_loads &&
        self.llc_load_misses == other.llc_load_misses &&
        self.llc_stores == other.llc_stores &&
        self.llc_store_misses == other.llc_store_misses &&
        self.llc_prefetches == other.llc_prefetches &&
        self.llc_prefetch_misses == other.llc_prefetch_misses &&
        self.dtlb_loads == other.dtlb_loads &&
        self.dtlb_load_misses == other.dtlb_load_misses &&
        self.dtlb_stores == other.dtlb_stores &&
        self.dtlb_store_misses == other.dtlb_store_misses &&
        self.dtlb_prefetches == other.dtlb_prefetches &&
        self.dtlb_prefetch_misses == other.dtlb_prefetch_misses &&
        self.itlb_loads == other.itlb_loads &&
        self.itlb_load_misses == other.itlb_load_misses &&
        self.branch_loads == other.branch_loads &&
        self.branch_load_misses == other.branch_load_misses &&
        self.node_loads == other.node_loads &&
        self.node_load_misses == other.node_load_misses &&
        self.node_stores == other.node_stores &&
        self.node_store_misses == other.node_store_misses &&
        self.node_prefetches == other.node_prefetches &&
        self.node_prefetch_misses == other.node_prefetch_misses &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for PerfStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Request {
    // message fields
    slave_id: ::protobuf::SingularPtrField<SlaveID>,
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Request {
        static mut instance: ::protobuf::lazy::Lazy<Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Request,
        };
        unsafe {
            instance.get(|| {
                Request {
                    slave_id: ::protobuf::SingularPtrField::none(),
                    resources: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.SlaveID slave_id = 1;

    pub fn clear_slave_id(&mut self) {
        self.slave_id.clear();
    }

    pub fn has_slave_id(&self) -> bool {
        self.slave_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slave_id(&mut self, v: SlaveID) {
        self.slave_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slave_id<'a>(&'a mut self) -> &'a mut SlaveID {
        if self.slave_id.is_none() {
            self.slave_id.set_default();
        };
        self.slave_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_slave_id(&mut self) -> SlaveID {
        self.slave_id.take().unwrap_or_else(|| SlaveID::new())
    }

    pub fn get_slave_id<'a>(&'a self) -> &'a SlaveID {
        self.slave_id.as_ref().unwrap_or_else(|| SlaveID::default_instance())
    }

    // repeated .mesos.Resource resources = 2;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.slave_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.slave_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.slave_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Request>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Request {
    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static(_: ::std::option::Option<Request>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "slave_id",
                    Request::has_slave_id,
                    Request::get_slave_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    Request::get_resources,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Request>(
                    "Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.clear_slave_id();
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Request {
    fn eq(&self, other: &Request) -> bool {
        self.slave_id == other.slave_id &&
        self.resources == other.resources &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer {
    // message fields
    id: ::protobuf::SingularPtrField<OfferID>,
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    slave_id: ::protobuf::SingularPtrField<SlaveID>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    url: ::protobuf::SingularPtrField<URL>,
    resources: ::protobuf::RepeatedField<Resource>,
    attributes: ::protobuf::RepeatedField<Attribute>,
    executor_ids: ::protobuf::RepeatedField<ExecutorID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Offer {
    pub fn new() -> Offer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer {
        static mut instance: ::protobuf::lazy::Lazy<Offer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer,
        };
        unsafe {
            instance.get(|| {
                Offer {
                    id: ::protobuf::SingularPtrField::none(),
                    framework_id: ::protobuf::SingularPtrField::none(),
                    slave_id: ::protobuf::SingularPtrField::none(),
                    hostname: ::protobuf::SingularField::none(),
                    url: ::protobuf::SingularPtrField::none(),
                    resources: ::protobuf::RepeatedField::new(),
                    attributes: ::protobuf::RepeatedField::new(),
                    executor_ids: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.OfferID id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: OfferID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut OfferID {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> OfferID {
        self.id.take().unwrap_or_else(|| OfferID::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a OfferID {
        self.id.as_ref().unwrap_or_else(|| OfferID::default_instance())
    }

    // required .mesos.FrameworkID framework_id = 2;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id<'a>(&'a mut self) -> &'a mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        };
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id<'a>(&'a self) -> &'a FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    // required .mesos.SlaveID slave_id = 3;

    pub fn clear_slave_id(&mut self) {
        self.slave_id.clear();
    }

    pub fn has_slave_id(&self) -> bool {
        self.slave_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slave_id(&mut self, v: SlaveID) {
        self.slave_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slave_id<'a>(&'a mut self) -> &'a mut SlaveID {
        if self.slave_id.is_none() {
            self.slave_id.set_default();
        };
        self.slave_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_slave_id(&mut self) -> SlaveID {
        self.slave_id.take().unwrap_or_else(|| SlaveID::new())
    }

    pub fn get_slave_id<'a>(&'a self) -> &'a SlaveID {
        self.slave_id.as_ref().unwrap_or_else(|| SlaveID::default_instance())
    }

    // required string hostname = 4;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.URL url = 8;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: URL) {
        self.url = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url<'a>(&'a mut self) -> &'a mut URL {
        if self.url.is_none() {
            self.url.set_default();
        };
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> URL {
        self.url.take().unwrap_or_else(|| URL::new())
    }

    pub fn get_url<'a>(&'a self) -> &'a URL {
        self.url.as_ref().unwrap_or_else(|| URL::default_instance())
    }

    // repeated .mesos.Resource resources = 5;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }

    // repeated .mesos.Attribute attributes = 7;

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<Attribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Attribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<Attribute> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    pub fn get_attributes<'a>(&'a self) -> &'a [Attribute] {
        &self.attributes
    }

    // repeated .mesos.ExecutorID executor_ids = 6;

    pub fn clear_executor_ids(&mut self) {
        self.executor_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_executor_ids(&mut self, v: ::protobuf::RepeatedField<ExecutorID>) {
        self.executor_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_executor_ids<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ExecutorID> {
        &mut self.executor_ids
    }

    // Take field
    pub fn take_executor_ids(&mut self) -> ::protobuf::RepeatedField<ExecutorID> {
        ::std::mem::replace(&mut self.executor_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_executor_ids<'a>(&'a self) -> &'a [ExecutorID] {
        &self.executor_ids
    }
}

impl ::protobuf::Message for Offer {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        if self.framework_id.is_none() {
            return false;
        };
        if self.slave_id.is_none() {
            return false;
        };
        if self.hostname.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.framework_id.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.slave_id.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.hostname.set_default();
                    try!(is.read_string_into(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.url.set_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes));
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.executor_ids));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.framework_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.slave_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.url.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.attributes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.executor_ids.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.framework_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.slave_id.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.url.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.attributes.iter() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.executor_ids.iter() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer {
    fn new() -> Offer {
        Offer::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "id",
                    Offer::has_id,
                    Offer::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "framework_id",
                    Offer::has_framework_id,
                    Offer::get_framework_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "slave_id",
                    Offer::has_slave_id,
                    Offer::get_slave_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    Offer::has_hostname,
                    Offer::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "url",
                    Offer::has_url,
                    Offer::get_url,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    Offer::get_resources,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "attributes",
                    Offer::get_attributes,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "executor_ids",
                    Offer::get_executor_ids,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer>(
                    "Offer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_framework_id();
        self.clear_slave_id();
        self.clear_hostname();
        self.clear_url();
        self.clear_resources();
        self.clear_attributes();
        self.clear_executor_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer {
    fn eq(&self, other: &Offer) -> bool {
        self.id == other.id &&
        self.framework_id == other.framework_id &&
        self.slave_id == other.slave_id &&
        self.hostname == other.hostname &&
        self.url == other.url &&
        self.resources == other.resources &&
        self.attributes == other.attributes &&
        self.executor_ids == other.executor_ids &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation {
    // message fields
    field_type: ::std::option::Option<Offer_Operation_Type>,
    launch: ::protobuf::SingularPtrField<Offer_Operation_Launch>,
    reserve: ::protobuf::SingularPtrField<Offer_Operation_Reserve>,
    unreserve: ::protobuf::SingularPtrField<Offer_Operation_Unreserve>,
    create: ::protobuf::SingularPtrField<Offer_Operation_Create>,
    destroy: ::protobuf::SingularPtrField<Offer_Operation_Destroy>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Offer_Operation {
    pub fn new() -> Offer_Operation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation {
                    field_type: ::std::option::Option::None,
                    launch: ::protobuf::SingularPtrField::none(),
                    reserve: ::protobuf::SingularPtrField::none(),
                    unreserve: ::protobuf::SingularPtrField::none(),
                    create: ::protobuf::SingularPtrField::none(),
                    destroy: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.Offer.Operation.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Offer_Operation_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Offer_Operation_Type {
        self.field_type.unwrap_or(Offer_Operation_Type::LAUNCH)
    }

    // optional .mesos.Offer.Operation.Launch launch = 2;

    pub fn clear_launch(&mut self) {
        self.launch.clear();
    }

    pub fn has_launch(&self) -> bool {
        self.launch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch(&mut self, v: Offer_Operation_Launch) {
        self.launch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_launch<'a>(&'a mut self) -> &'a mut Offer_Operation_Launch {
        if self.launch.is_none() {
            self.launch.set_default();
        };
        self.launch.as_mut().unwrap()
    }

    // Take field
    pub fn take_launch(&mut self) -> Offer_Operation_Launch {
        self.launch.take().unwrap_or_else(|| Offer_Operation_Launch::new())
    }

    pub fn get_launch<'a>(&'a self) -> &'a Offer_Operation_Launch {
        self.launch.as_ref().unwrap_or_else(|| Offer_Operation_Launch::default_instance())
    }

    // optional .mesos.Offer.Operation.Reserve reserve = 3;

    pub fn clear_reserve(&mut self) {
        self.reserve.clear();
    }

    pub fn has_reserve(&self) -> bool {
        self.reserve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserve(&mut self, v: Offer_Operation_Reserve) {
        self.reserve = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reserve<'a>(&'a mut self) -> &'a mut Offer_Operation_Reserve {
        if self.reserve.is_none() {
            self.reserve.set_default();
        };
        self.reserve.as_mut().unwrap()
    }

    // Take field
    pub fn take_reserve(&mut self) -> Offer_Operation_Reserve {
        self.reserve.take().unwrap_or_else(|| Offer_Operation_Reserve::new())
    }

    pub fn get_reserve<'a>(&'a self) -> &'a Offer_Operation_Reserve {
        self.reserve.as_ref().unwrap_or_else(|| Offer_Operation_Reserve::default_instance())
    }

    // optional .mesos.Offer.Operation.Unreserve unreserve = 4;

    pub fn clear_unreserve(&mut self) {
        self.unreserve.clear();
    }

    pub fn has_unreserve(&self) -> bool {
        self.unreserve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unreserve(&mut self, v: Offer_Operation_Unreserve) {
        self.unreserve = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unreserve<'a>(&'a mut self) -> &'a mut Offer_Operation_Unreserve {
        if self.unreserve.is_none() {
            self.unreserve.set_default();
        };
        self.unreserve.as_mut().unwrap()
    }

    // Take field
    pub fn take_unreserve(&mut self) -> Offer_Operation_Unreserve {
        self.unreserve.take().unwrap_or_else(|| Offer_Operation_Unreserve::new())
    }

    pub fn get_unreserve<'a>(&'a self) -> &'a Offer_Operation_Unreserve {
        self.unreserve.as_ref().unwrap_or_else(|| Offer_Operation_Unreserve::default_instance())
    }

    // optional .mesos.Offer.Operation.Create create = 5;

    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: Offer_Operation_Create) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create<'a>(&'a mut self) -> &'a mut Offer_Operation_Create {
        if self.create.is_none() {
            self.create.set_default();
        };
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> Offer_Operation_Create {
        self.create.take().unwrap_or_else(|| Offer_Operation_Create::new())
    }

    pub fn get_create<'a>(&'a self) -> &'a Offer_Operation_Create {
        self.create.as_ref().unwrap_or_else(|| Offer_Operation_Create::default_instance())
    }

    // optional .mesos.Offer.Operation.Destroy destroy = 6;

    pub fn clear_destroy(&mut self) {
        self.destroy.clear();
    }

    pub fn has_destroy(&self) -> bool {
        self.destroy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy(&mut self, v: Offer_Operation_Destroy) {
        self.destroy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy<'a>(&'a mut self) -> &'a mut Offer_Operation_Destroy {
        if self.destroy.is_none() {
            self.destroy.set_default();
        };
        self.destroy.as_mut().unwrap()
    }

    // Take field
    pub fn take_destroy(&mut self) -> Offer_Operation_Destroy {
        self.destroy.take().unwrap_or_else(|| Offer_Operation_Destroy::new())
    }

    pub fn get_destroy<'a>(&'a self) -> &'a Offer_Operation_Destroy {
        self.destroy.as_ref().unwrap_or_else(|| Offer_Operation_Destroy::default_instance())
    }
}

impl ::protobuf::Message for Offer_Operation {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.launch.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.reserve.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.unreserve.set_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.create.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.destroy.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.launch.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.reserve.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.unreserve.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.create.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.destroy.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v as i32));
        };
        if let Some(v) = self.launch.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.reserve.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.unreserve.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.create.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.destroy.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation {
    fn new() -> Offer_Operation {
        Offer_Operation::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    Offer_Operation::has_field_type,
                    Offer_Operation::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "launch",
                    Offer_Operation::has_launch,
                    Offer_Operation::get_launch,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "reserve",
                    Offer_Operation::has_reserve,
                    Offer_Operation::get_reserve,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "unreserve",
                    Offer_Operation::has_unreserve,
                    Offer_Operation::get_unreserve,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "create",
                    Offer_Operation::has_create,
                    Offer_Operation::get_create,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "destroy",
                    Offer_Operation::has_destroy,
                    Offer_Operation::get_destroy,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation>(
                    "Offer_Operation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_launch();
        self.clear_reserve();
        self.clear_unreserve();
        self.clear_create();
        self.clear_destroy();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation {
    fn eq(&self, other: &Offer_Operation) -> bool {
        self.field_type == other.field_type &&
        self.launch == other.launch &&
        self.reserve == other.reserve &&
        self.unreserve == other.unreserve &&
        self.create == other.create &&
        self.destroy == other.destroy &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation_Launch {
    // message fields
    task_infos: ::protobuf::RepeatedField<TaskInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Offer_Operation_Launch {
    pub fn new() -> Offer_Operation_Launch {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Launch {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Launch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Launch,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation_Launch {
                    task_infos: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.TaskInfo task_infos = 1;

    pub fn clear_task_infos(&mut self) {
        self.task_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_infos(&mut self, v: ::protobuf::RepeatedField<TaskInfo>) {
        self.task_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_task_infos<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<TaskInfo> {
        &mut self.task_infos
    }

    // Take field
    pub fn take_task_infos(&mut self) -> ::protobuf::RepeatedField<TaskInfo> {
        ::std::mem::replace(&mut self.task_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_task_infos<'a>(&'a self) -> &'a [TaskInfo] {
        &self.task_infos
    }
}

impl ::protobuf::Message for Offer_Operation_Launch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.task_infos));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.task_infos.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.task_infos.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation_Launch>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Launch {
    fn new() -> Offer_Operation_Launch {
        Offer_Operation_Launch::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Launch>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "task_infos",
                    Offer_Operation_Launch::get_task_infos,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Launch>(
                    "Offer_Operation_Launch",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Launch {
    fn clear(&mut self) {
        self.clear_task_infos();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation_Launch {
    fn eq(&self, other: &Offer_Operation_Launch) -> bool {
        self.task_infos == other.task_infos &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation_Launch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation_Reserve {
    // message fields
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Offer_Operation_Reserve {
    pub fn new() -> Offer_Operation_Reserve {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Reserve {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Reserve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Reserve,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation_Reserve {
                    resources: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.Resource resources = 1;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }
}

impl ::protobuf::Message for Offer_Operation_Reserve {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.resources.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation_Reserve>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Reserve {
    fn new() -> Offer_Operation_Reserve {
        Offer_Operation_Reserve::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Reserve>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    Offer_Operation_Reserve::get_resources,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Reserve>(
                    "Offer_Operation_Reserve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Reserve {
    fn clear(&mut self) {
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation_Reserve {
    fn eq(&self, other: &Offer_Operation_Reserve) -> bool {
        self.resources == other.resources &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation_Reserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation_Unreserve {
    // message fields
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Offer_Operation_Unreserve {
    pub fn new() -> Offer_Operation_Unreserve {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Unreserve {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Unreserve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Unreserve,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation_Unreserve {
                    resources: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.Resource resources = 1;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }
}

impl ::protobuf::Message for Offer_Operation_Unreserve {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.resources.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation_Unreserve>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Unreserve {
    fn new() -> Offer_Operation_Unreserve {
        Offer_Operation_Unreserve::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Unreserve>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    Offer_Operation_Unreserve::get_resources,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Unreserve>(
                    "Offer_Operation_Unreserve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Unreserve {
    fn clear(&mut self) {
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation_Unreserve {
    fn eq(&self, other: &Offer_Operation_Unreserve) -> bool {
        self.resources == other.resources &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation_Unreserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation_Create {
    // message fields
    volumes: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Offer_Operation_Create {
    pub fn new() -> Offer_Operation_Create {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Create {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Create> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Create,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation_Create {
                    volumes: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.Resource volumes = 1;

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumes<'a>(&'a self) -> &'a [Resource] {
        &self.volumes
    }
}

impl ::protobuf::Message for Offer_Operation_Create {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.volumes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.volumes.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation_Create>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Create {
    fn new() -> Offer_Operation_Create {
        Offer_Operation_Create::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Create>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "volumes",
                    Offer_Operation_Create::get_volumes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Create>(
                    "Offer_Operation_Create",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Create {
    fn clear(&mut self) {
        self.clear_volumes();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation_Create {
    fn eq(&self, other: &Offer_Operation_Create) -> bool {
        self.volumes == other.volumes &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation_Destroy {
    // message fields
    volumes: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Offer_Operation_Destroy {
    pub fn new() -> Offer_Operation_Destroy {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Destroy {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Destroy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Destroy,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation_Destroy {
                    volumes: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.Resource volumes = 1;

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumes<'a>(&'a self) -> &'a [Resource] {
        &self.volumes
    }
}

impl ::protobuf::Message for Offer_Operation_Destroy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.volumes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.volumes.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation_Destroy>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Destroy {
    fn new() -> Offer_Operation_Destroy {
        Offer_Operation_Destroy::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Destroy>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "volumes",
                    Offer_Operation_Destroy::get_volumes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Destroy>(
                    "Offer_Operation_Destroy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Destroy {
    fn clear(&mut self) {
        self.clear_volumes();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation_Destroy {
    fn eq(&self, other: &Offer_Operation_Destroy) -> bool {
        self.volumes == other.volumes &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation_Destroy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Offer_Operation_Type {
    LAUNCH = 1,
    RESERVE = 2,
    UNRESERVE = 3,
    CREATE = 4,
    DESTROY = 5,
}

impl ::protobuf::ProtobufEnum for Offer_Operation_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Offer_Operation_Type> {
        match value {
            1 => ::std::option::Option::Some(Offer_Operation_Type::LAUNCH),
            2 => ::std::option::Option::Some(Offer_Operation_Type::RESERVE),
            3 => ::std::option::Option::Some(Offer_Operation_Type::UNRESERVE),
            4 => ::std::option::Option::Some(Offer_Operation_Type::CREATE),
            5 => ::std::option::Option::Some(Offer_Operation_Type::DESTROY),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<Offer_Operation_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Offer_Operation_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Offer_Operation_Type {
}

#[derive(Clone,Default)]
pub struct TaskInfo {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    task_id: ::protobuf::SingularPtrField<TaskID>,
    slave_id: ::protobuf::SingularPtrField<SlaveID>,
    resources: ::protobuf::RepeatedField<Resource>,
    executor: ::protobuf::SingularPtrField<ExecutorInfo>,
    command: ::protobuf::SingularPtrField<CommandInfo>,
    container: ::protobuf::SingularPtrField<ContainerInfo>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    health_check: ::protobuf::SingularPtrField<HealthCheck>,
    labels: ::protobuf::SingularPtrField<Labels>,
    discovery: ::protobuf::SingularPtrField<DiscoveryInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl TaskInfo {
    pub fn new() -> TaskInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskInfo {
        static mut instance: ::protobuf::lazy::Lazy<TaskInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskInfo,
        };
        unsafe {
            instance.get(|| {
                TaskInfo {
                    name: ::protobuf::SingularField::none(),
                    task_id: ::protobuf::SingularPtrField::none(),
                    slave_id: ::protobuf::SingularPtrField::none(),
                    resources: ::protobuf::RepeatedField::new(),
                    executor: ::protobuf::SingularPtrField::none(),
                    command: ::protobuf::SingularPtrField::none(),
                    container: ::protobuf::SingularPtrField::none(),
                    data: ::protobuf::SingularField::none(),
                    health_check: ::protobuf::SingularPtrField::none(),
                    labels: ::protobuf::SingularPtrField::none(),
                    discovery: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .mesos.TaskID task_id = 2;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: TaskID) {
        self.task_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id<'a>(&'a mut self) -> &'a mut TaskID {
        if self.task_id.is_none() {
            self.task_id.set_default();
        };
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> TaskID {
        self.task_id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_task_id<'a>(&'a self) -> &'a TaskID {
        self.task_id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    // required .mesos.SlaveID slave_id = 3;

    pub fn clear_slave_id(&mut self) {
        self.slave_id.clear();
    }

    pub fn has_slave_id(&self) -> bool {
        self.slave_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slave_id(&mut self, v: SlaveID) {
        self.slave_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slave_id<'a>(&'a mut self) -> &'a mut SlaveID {
        if self.slave_id.is_none() {
            self.slave_id.set_default();
        };
        self.slave_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_slave_id(&mut self) -> SlaveID {
        self.slave_id.take().unwrap_or_else(|| SlaveID::new())
    }

    pub fn get_slave_id<'a>(&'a self) -> &'a SlaveID {
        self.slave_id.as_ref().unwrap_or_else(|| SlaveID::default_instance())
    }

    // repeated .mesos.Resource resources = 4;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }

    // optional .mesos.ExecutorInfo executor = 5;

    pub fn clear_executor(&mut self) {
        self.executor.clear();
    }

    pub fn has_executor(&self) -> bool {
        self.executor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor(&mut self, v: ExecutorInfo) {
        self.executor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor<'a>(&'a mut self) -> &'a mut ExecutorInfo {
        if self.executor.is_none() {
            self.executor.set_default();
        };
        self.executor.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor(&mut self) -> ExecutorInfo {
        self.executor.take().unwrap_or_else(|| ExecutorInfo::new())
    }

    pub fn get_executor<'a>(&'a self) -> &'a ExecutorInfo {
        self.executor.as_ref().unwrap_or_else(|| ExecutorInfo::default_instance())
    }

    // optional .mesos.CommandInfo command = 7;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command<'a>(&'a mut self) -> &'a mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        };
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command<'a>(&'a self) -> &'a CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }

    // optional .mesos.ContainerInfo container = 9;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ContainerInfo) {
        self.container = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container<'a>(&'a mut self) -> &'a mut ContainerInfo {
        if self.container.is_none() {
            self.container.set_default();
        };
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ContainerInfo {
        self.container.take().unwrap_or_else(|| ContainerInfo::new())
    }

    pub fn get_container<'a>(&'a self) -> &'a ContainerInfo {
        self.container.as_ref().unwrap_or_else(|| ContainerInfo::default_instance())
    }

    // optional bytes data = 6;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data<'a>(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .mesos.HealthCheck health_check = 8;

    pub fn clear_health_check(&mut self) {
        self.health_check.clear();
    }

    pub fn has_health_check(&self) -> bool {
        self.health_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_check(&mut self, v: HealthCheck) {
        self.health_check = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_health_check<'a>(&'a mut self) -> &'a mut HealthCheck {
        if self.health_check.is_none() {
            self.health_check.set_default();
        };
        self.health_check.as_mut().unwrap()
    }

    // Take field
    pub fn take_health_check(&mut self) -> HealthCheck {
        self.health_check.take().unwrap_or_else(|| HealthCheck::new())
    }

    pub fn get_health_check<'a>(&'a self) -> &'a HealthCheck {
        self.health_check.as_ref().unwrap_or_else(|| HealthCheck::default_instance())
    }

    // optional .mesos.Labels labels = 10;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    // optional .mesos.DiscoveryInfo discovery = 11;

    pub fn clear_discovery(&mut self) {
        self.discovery.clear();
    }

    pub fn has_discovery(&self) -> bool {
        self.discovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discovery(&mut self, v: DiscoveryInfo) {
        self.discovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovery<'a>(&'a mut self) -> &'a mut DiscoveryInfo {
        if self.discovery.is_none() {
            self.discovery.set_default();
        };
        self.discovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_discovery(&mut self) -> DiscoveryInfo {
        self.discovery.take().unwrap_or_else(|| DiscoveryInfo::new())
    }

    pub fn get_discovery<'a>(&'a self) -> &'a DiscoveryInfo {
        self.discovery.as_ref().unwrap_or_else(|| DiscoveryInfo::default_instance())
    }
}

impl ::protobuf::Message for TaskInfo {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        if self.task_id.is_none() {
            return false;
        };
        if self.slave_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.task_id.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.slave_id.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.executor.set_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.command.set_default();
                    try!(is.merge_message(tmp))
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.container.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.data.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.health_check.set_default();
                    try!(is.merge_message(tmp))
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.labels.set_default();
                    try!(is.merge_message(tmp))
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.discovery.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.task_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.slave_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.executor.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.command.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.container.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        for value in self.health_check.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.discovery.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.task_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.slave_id.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.executor.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.command.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.container.as_ref() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.data.as_ref() {
            try!(os.write_bytes(6, &v));
        };
        if let Some(v) = self.health_check.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.discovery.as_ref() {
            try!(os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TaskInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskInfo {
    fn new() -> TaskInfo {
        TaskInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    TaskInfo::has_name,
                    TaskInfo::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "task_id",
                    TaskInfo::has_task_id,
                    TaskInfo::get_task_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "slave_id",
                    TaskInfo::has_slave_id,
                    TaskInfo::get_slave_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    TaskInfo::get_resources,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor",
                    TaskInfo::has_executor,
                    TaskInfo::get_executor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "command",
                    TaskInfo::has_command,
                    TaskInfo::get_command,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "container",
                    TaskInfo::has_container,
                    TaskInfo::get_container,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "data",
                    TaskInfo::has_data,
                    TaskInfo::get_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "health_check",
                    TaskInfo::has_health_check,
                    TaskInfo::get_health_check,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    TaskInfo::has_labels,
                    TaskInfo::get_labels,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "discovery",
                    TaskInfo::has_discovery,
                    TaskInfo::get_discovery,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskInfo>(
                    "TaskInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskInfo {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_task_id();
        self.clear_slave_id();
        self.clear_resources();
        self.clear_executor();
        self.clear_command();
        self.clear_container();
        self.clear_data();
        self.clear_health_check();
        self.clear_labels();
        self.clear_discovery();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TaskInfo {
    fn eq(&self, other: &TaskInfo) -> bool {
        self.name == other.name &&
        self.task_id == other.task_id &&
        self.slave_id == other.slave_id &&
        self.resources == other.resources &&
        self.executor == other.executor &&
        self.command == other.command &&
        self.container == other.container &&
        self.data == other.data &&
        self.health_check == other.health_check &&
        self.labels == other.labels &&
        self.discovery == other.discovery &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TaskInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TaskStatus {
    // message fields
    task_id: ::protobuf::SingularPtrField<TaskID>,
    state: ::std::option::Option<TaskState>,
    message: ::protobuf::SingularField<::std::string::String>,
    source: ::std::option::Option<TaskStatus_Source>,
    reason: ::std::option::Option<TaskStatus_Reason>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    slave_id: ::protobuf::SingularPtrField<SlaveID>,
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    timestamp: ::std::option::Option<f64>,
    uuid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    healthy: ::std::option::Option<bool>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl TaskStatus {
    pub fn new() -> TaskStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskStatus {
        static mut instance: ::protobuf::lazy::Lazy<TaskStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskStatus,
        };
        unsafe {
            instance.get(|| {
                TaskStatus {
                    task_id: ::protobuf::SingularPtrField::none(),
                    state: ::std::option::Option::None,
                    message: ::protobuf::SingularField::none(),
                    source: ::std::option::Option::None,
                    reason: ::std::option::Option::None,
                    data: ::protobuf::SingularField::none(),
                    slave_id: ::protobuf::SingularPtrField::none(),
                    executor_id: ::protobuf::SingularPtrField::none(),
                    timestamp: ::std::option::Option::None,
                    uuid: ::protobuf::SingularField::none(),
                    healthy: ::std::option::Option::None,
                    labels: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.TaskID task_id = 1;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: TaskID) {
        self.task_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id<'a>(&'a mut self) -> &'a mut TaskID {
        if self.task_id.is_none() {
            self.task_id.set_default();
        };
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> TaskID {
        self.task_id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_task_id<'a>(&'a self) -> &'a TaskID {
        self.task_id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    // required .mesos.TaskState state = 2;

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: TaskState) {
        self.state = ::std::option::Option::Some(v);
    }

    pub fn get_state<'a>(&self) -> TaskState {
        self.state.unwrap_or(TaskState::TASK_STAGING)
    }

    // optional string message = 4;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message<'a>(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.TaskStatus.Source source = 9;

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: TaskStatus_Source) {
        self.source = ::std::option::Option::Some(v);
    }

    pub fn get_source<'a>(&self) -> TaskStatus_Source {
        self.source.unwrap_or(TaskStatus_Source::SOURCE_MASTER)
    }

    // optional .mesos.TaskStatus.Reason reason = 10;

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: TaskStatus_Reason) {
        self.reason = ::std::option::Option::Some(v);
    }

    pub fn get_reason<'a>(&self) -> TaskStatus_Reason {
        self.reason.unwrap_or(TaskStatus_Reason::REASON_COMMAND_EXECUTOR_FAILED)
    }

    // optional bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data<'a>(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .mesos.SlaveID slave_id = 5;

    pub fn clear_slave_id(&mut self) {
        self.slave_id.clear();
    }

    pub fn has_slave_id(&self) -> bool {
        self.slave_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slave_id(&mut self, v: SlaveID) {
        self.slave_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slave_id<'a>(&'a mut self) -> &'a mut SlaveID {
        if self.slave_id.is_none() {
            self.slave_id.set_default();
        };
        self.slave_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_slave_id(&mut self) -> SlaveID {
        self.slave_id.take().unwrap_or_else(|| SlaveID::new())
    }

    pub fn get_slave_id<'a>(&'a self) -> &'a SlaveID {
        self.slave_id.as_ref().unwrap_or_else(|| SlaveID::default_instance())
    }

    // optional .mesos.ExecutorID executor_id = 7;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id<'a>(&'a mut self) -> &'a mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        };
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id<'a>(&'a self) -> &'a ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    // optional double timestamp = 6;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp<'a>(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    // optional bytes uuid = 11;

    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.uuid.is_none() {
            self.uuid.set_default();
        };
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        self.uuid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_uuid<'a>(&'a self) -> &'a [u8] {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool healthy = 8;

    pub fn clear_healthy(&mut self) {
        self.healthy = ::std::option::Option::None;
    }

    pub fn has_healthy(&self) -> bool {
        self.healthy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthy(&mut self, v: bool) {
        self.healthy = ::std::option::Option::Some(v);
    }

    pub fn get_healthy<'a>(&self) -> bool {
        self.healthy.unwrap_or(false)
    }

    // optional .mesos.Labels labels = 12;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }
}

impl ::protobuf::Message for TaskStatus {
    fn is_initialized(&self) -> bool {
        if self.task_id.is_none() {
            return false;
        };
        if self.state.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.task_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.state = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.message.set_default();
                    try!(is.read_string_into(tmp))
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.source = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.reason = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.data.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.slave_id.set_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.executor_id.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.uuid.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.healthy = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.labels.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.task_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.state.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.source.iter() {
            my_size += ::protobuf::rt::enum_size(9, *value);
        };
        for value in self.reason.iter() {
            my_size += ::protobuf::rt::enum_size(10, *value);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        for value in self.slave_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.executor_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.timestamp.is_some() {
            my_size += 9;
        };
        for value in self.uuid.iter() {
            my_size += ::protobuf::rt::bytes_size(11, &value);
        };
        if self.healthy.is_some() {
            my_size += 2;
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.task_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.state {
            try!(os.write_enum(2, v as i32));
        };
        if let Some(v) = self.message.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.source {
            try!(os.write_enum(9, v as i32));
        };
        if let Some(v) = self.reason {
            try!(os.write_enum(10, v as i32));
        };
        if let Some(v) = self.data.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        if let Some(v) = self.slave_id.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.executor_id.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.timestamp {
            try!(os.write_double(6, v));
        };
        if let Some(v) = self.uuid.as_ref() {
            try!(os.write_bytes(11, &v));
        };
        if let Some(v) = self.healthy {
            try!(os.write_bool(8, v));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TaskStatus>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskStatus {
    fn new() -> TaskStatus {
        TaskStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "task_id",
                    TaskStatus::has_task_id,
                    TaskStatus::get_task_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "state",
                    TaskStatus::has_state,
                    TaskStatus::get_state,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "message",
                    TaskStatus::has_message,
                    TaskStatus::get_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "source",
                    TaskStatus::has_source,
                    TaskStatus::get_source,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "reason",
                    TaskStatus::has_reason,
                    TaskStatus::get_reason,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "data",
                    TaskStatus::has_data,
                    TaskStatus::get_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "slave_id",
                    TaskStatus::has_slave_id,
                    TaskStatus::get_slave_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor_id",
                    TaskStatus::has_executor_id,
                    TaskStatus::get_executor_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "timestamp",
                    TaskStatus::has_timestamp,
                    TaskStatus::get_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "uuid",
                    TaskStatus::has_uuid,
                    TaskStatus::get_uuid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "healthy",
                    TaskStatus::has_healthy,
                    TaskStatus::get_healthy,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    TaskStatus::has_labels,
                    TaskStatus::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskStatus>(
                    "TaskStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskStatus {
    fn clear(&mut self) {
        self.clear_task_id();
        self.clear_state();
        self.clear_message();
        self.clear_source();
        self.clear_reason();
        self.clear_data();
        self.clear_slave_id();
        self.clear_executor_id();
        self.clear_timestamp();
        self.clear_uuid();
        self.clear_healthy();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TaskStatus {
    fn eq(&self, other: &TaskStatus) -> bool {
        self.task_id == other.task_id &&
        self.state == other.state &&
        self.message == other.message &&
        self.source == other.source &&
        self.reason == other.reason &&
        self.data == other.data &&
        self.slave_id == other.slave_id &&
        self.executor_id == other.executor_id &&
        self.timestamp == other.timestamp &&
        self.uuid == other.uuid &&
        self.healthy == other.healthy &&
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TaskStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskStatus_Source {
    SOURCE_MASTER = 0,
    SOURCE_SLAVE = 1,
    SOURCE_EXECUTOR = 2,
}

impl ::protobuf::ProtobufEnum for TaskStatus_Source {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskStatus_Source> {
        match value {
            0 => ::std::option::Option::Some(TaskStatus_Source::SOURCE_MASTER),
            1 => ::std::option::Option::Some(TaskStatus_Source::SOURCE_SLAVE),
            2 => ::std::option::Option::Some(TaskStatus_Source::SOURCE_EXECUTOR),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<TaskStatus_Source>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskStatus_Source", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskStatus_Source {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskStatus_Reason {
    REASON_COMMAND_EXECUTOR_FAILED = 0,
    REASON_EXECUTOR_PREEMPTED = 17,
    REASON_EXECUTOR_TERMINATED = 1,
    REASON_EXECUTOR_UNREGISTERED = 2,
    REASON_FRAMEWORK_REMOVED = 3,
    REASON_GC_ERROR = 4,
    REASON_INVALID_FRAMEWORKID = 5,
    REASON_INVALID_OFFERS = 6,
    REASON_MASTER_DISCONNECTED = 7,
    REASON_MEMORY_LIMIT = 8,
    REASON_RECONCILIATION = 9,
    REASON_RESOURCES_UNKNOWN = 18,
    REASON_SLAVE_DISCONNECTED = 10,
    REASON_SLAVE_REMOVED = 11,
    REASON_SLAVE_RESTARTED = 12,
    REASON_SLAVE_UNKNOWN = 13,
    REASON_TASK_INVALID = 14,
    REASON_TASK_UNAUTHORIZED = 15,
    REASON_TASK_UNKNOWN = 16,
}

impl ::protobuf::ProtobufEnum for TaskStatus_Reason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskStatus_Reason> {
        match value {
            0 => ::std::option::Option::Some(TaskStatus_Reason::REASON_COMMAND_EXECUTOR_FAILED),
            17 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_PREEMPTED),
            1 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_TERMINATED),
            2 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_UNREGISTERED),
            3 => ::std::option::Option::Some(TaskStatus_Reason::REASON_FRAMEWORK_REMOVED),
            4 => ::std::option::Option::Some(TaskStatus_Reason::REASON_GC_ERROR),
            5 => ::std::option::Option::Some(TaskStatus_Reason::REASON_INVALID_FRAMEWORKID),
            6 => ::std::option::Option::Some(TaskStatus_Reason::REASON_INVALID_OFFERS),
            7 => ::std::option::Option::Some(TaskStatus_Reason::REASON_MASTER_DISCONNECTED),
            8 => ::std::option::Option::Some(TaskStatus_Reason::REASON_MEMORY_LIMIT),
            9 => ::std::option::Option::Some(TaskStatus_Reason::REASON_RECONCILIATION),
            18 => ::std::option::Option::Some(TaskStatus_Reason::REASON_RESOURCES_UNKNOWN),
            10 => ::std::option::Option::Some(TaskStatus_Reason::REASON_SLAVE_DISCONNECTED),
            11 => ::std::option::Option::Some(TaskStatus_Reason::REASON_SLAVE_REMOVED),
            12 => ::std::option::Option::Some(TaskStatus_Reason::REASON_SLAVE_RESTARTED),
            13 => ::std::option::Option::Some(TaskStatus_Reason::REASON_SLAVE_UNKNOWN),
            14 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_INVALID),
            15 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_UNAUTHORIZED),
            16 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<TaskStatus_Reason>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskStatus_Reason", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskStatus_Reason {
}

#[derive(Clone,Default)]
pub struct Filters {
    // message fields
    refuse_seconds: ::std::option::Option<f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Filters {
    pub fn new() -> Filters {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Filters {
        static mut instance: ::protobuf::lazy::Lazy<Filters> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Filters,
        };
        unsafe {
            instance.get(|| {
                Filters {
                    refuse_seconds: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional double refuse_seconds = 1;

    pub fn clear_refuse_seconds(&mut self) {
        self.refuse_seconds = ::std::option::Option::None;
    }

    pub fn has_refuse_seconds(&self) -> bool {
        self.refuse_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refuse_seconds(&mut self, v: f64) {
        self.refuse_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_refuse_seconds<'a>(&self) -> f64 {
        self.refuse_seconds.unwrap_or(5f64)
    }
}

impl ::protobuf::Message for Filters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.refuse_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.refuse_seconds.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.refuse_seconds {
            try!(os.write_double(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Filters>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Filters {
    fn new() -> Filters {
        Filters::new()
    }

    fn descriptor_static(_: ::std::option::Option<Filters>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "refuse_seconds",
                    Filters::has_refuse_seconds,
                    Filters::get_refuse_seconds,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Filters>(
                    "Filters",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Filters {
    fn clear(&mut self) {
        self.clear_refuse_seconds();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Filters {
    fn eq(&self, other: &Filters) -> bool {
        self.refuse_seconds == other.refuse_seconds &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Filters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Environment {
    // message fields
    variables: ::protobuf::RepeatedField<Environment_Variable>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Environment {
    pub fn new() -> Environment {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Environment {
        static mut instance: ::protobuf::lazy::Lazy<Environment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Environment,
        };
        unsafe {
            instance.get(|| {
                Environment {
                    variables: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.Environment.Variable variables = 1;

    pub fn clear_variables(&mut self) {
        self.variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_variables(&mut self, v: ::protobuf::RepeatedField<Environment_Variable>) {
        self.variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variables<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Environment_Variable> {
        &mut self.variables
    }

    // Take field
    pub fn take_variables(&mut self) -> ::protobuf::RepeatedField<Environment_Variable> {
        ::std::mem::replace(&mut self.variables, ::protobuf::RepeatedField::new())
    }

    pub fn get_variables<'a>(&'a self) -> &'a [Environment_Variable] {
        &self.variables
    }
}

impl ::protobuf::Message for Environment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.variables));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.variables.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.variables.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Environment>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Environment {
    fn new() -> Environment {
        Environment::new()
    }

    fn descriptor_static(_: ::std::option::Option<Environment>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "variables",
                    Environment::get_variables,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Environment>(
                    "Environment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Environment {
    fn clear(&mut self) {
        self.clear_variables();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Environment {
    fn eq(&self, other: &Environment) -> bool {
        self.variables == other.variables &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Environment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Environment_Variable {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Environment_Variable {
    pub fn new() -> Environment_Variable {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Environment_Variable {
        static mut instance: ::protobuf::lazy::Lazy<Environment_Variable> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Environment_Variable,
        };
        unsafe {
            instance.get(|| {
                Environment_Variable {
                    name: ::protobuf::SingularField::none(),
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Environment_Variable {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Environment_Variable>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Environment_Variable {
    fn new() -> Environment_Variable {
        Environment_Variable::new()
    }

    fn descriptor_static(_: ::std::option::Option<Environment_Variable>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Environment_Variable::has_name,
                    Environment_Variable::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    Environment_Variable::has_value,
                    Environment_Variable::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Environment_Variable>(
                    "Environment_Variable",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Environment_Variable {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Environment_Variable {
    fn eq(&self, other: &Environment_Variable) -> bool {
        self.name == other.name &&
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Environment_Variable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Parameter {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Parameter {
    pub fn new() -> Parameter {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Parameter {
        static mut instance: ::protobuf::lazy::Lazy<Parameter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Parameter,
        };
        unsafe {
            instance.get(|| {
                Parameter {
                    key: ::protobuf::SingularField::none(),
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        };
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key<'a>(&'a self) -> &'a str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Parameter {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        };
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.key.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.key.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Parameter>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Parameter {
    fn new() -> Parameter {
        Parameter::new()
    }

    fn descriptor_static(_: ::std::option::Option<Parameter>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "key",
                    Parameter::has_key,
                    Parameter::get_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    Parameter::has_value,
                    Parameter::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Parameter>(
                    "Parameter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Parameter {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Parameter {
    fn eq(&self, other: &Parameter) -> bool {
        self.key == other.key &&
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Parameters {
    // message fields
    parameter: ::protobuf::RepeatedField<Parameter>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Parameters {
    pub fn new() -> Parameters {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Parameters {
        static mut instance: ::protobuf::lazy::Lazy<Parameters> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Parameters,
        };
        unsafe {
            instance.get(|| {
                Parameters {
                    parameter: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.Parameter parameter = 1;

    pub fn clear_parameter(&mut self) {
        self.parameter.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameter(&mut self, v: ::protobuf::RepeatedField<Parameter>) {
        self.parameter = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameter<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Parameter> {
        &mut self.parameter
    }

    // Take field
    pub fn take_parameter(&mut self) -> ::protobuf::RepeatedField<Parameter> {
        ::std::mem::replace(&mut self.parameter, ::protobuf::RepeatedField::new())
    }

    pub fn get_parameter<'a>(&'a self) -> &'a [Parameter] {
        &self.parameter
    }
}

impl ::protobuf::Message for Parameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameter));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.parameter.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.parameter.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Parameters>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Parameters {
    fn new() -> Parameters {
        Parameters::new()
    }

    fn descriptor_static(_: ::std::option::Option<Parameters>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "parameter",
                    Parameters::get_parameter,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Parameters>(
                    "Parameters",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Parameters {
    fn clear(&mut self) {
        self.clear_parameter();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Parameters {
    fn eq(&self, other: &Parameters) -> bool {
        self.parameter == other.parameter &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Parameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Credential {
    // message fields
    principal: ::protobuf::SingularField<::std::string::String>,
    secret: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Credential {
    pub fn new() -> Credential {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Credential {
        static mut instance: ::protobuf::lazy::Lazy<Credential> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Credential,
        };
        unsafe {
            instance.get(|| {
                Credential {
                    principal: ::protobuf::SingularField::none(),
                    secret: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string principal = 1;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        };
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal<'a>(&'a self) -> &'a str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes secret = 2;

    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.secret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.secret.is_none() {
            self.secret.set_default();
        };
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> ::std::vec::Vec<u8> {
        self.secret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_secret<'a>(&'a self) -> &'a [u8] {
        match self.secret.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for Credential {
    fn is_initialized(&self) -> bool {
        if self.principal.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.principal.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.secret.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.principal.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.secret.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.principal.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.secret.as_ref() {
            try!(os.write_bytes(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Credential>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Credential {
    fn new() -> Credential {
        Credential::new()
    }

    fn descriptor_static(_: ::std::option::Option<Credential>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "principal",
                    Credential::has_principal,
                    Credential::get_principal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "secret",
                    Credential::has_secret,
                    Credential::get_secret,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Credential>(
                    "Credential",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Credential {
    fn clear(&mut self) {
        self.clear_principal();
        self.clear_secret();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Credential {
    fn eq(&self, other: &Credential) -> bool {
        self.principal == other.principal &&
        self.secret == other.secret &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Credential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Credentials {
    // message fields
    credentials: ::protobuf::RepeatedField<Credential>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Credentials {
    pub fn new() -> Credentials {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Credentials {
        static mut instance: ::protobuf::lazy::Lazy<Credentials> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Credentials,
        };
        unsafe {
            instance.get(|| {
                Credentials {
                    credentials: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.Credential credentials = 1;

    pub fn clear_credentials(&mut self) {
        self.credentials.clear();
    }

    // Param is passed by value, moved
    pub fn set_credentials(&mut self, v: ::protobuf::RepeatedField<Credential>) {
        self.credentials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_credentials<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Credential> {
        &mut self.credentials
    }

    // Take field
    pub fn take_credentials(&mut self) -> ::protobuf::RepeatedField<Credential> {
        ::std::mem::replace(&mut self.credentials, ::protobuf::RepeatedField::new())
    }

    pub fn get_credentials<'a>(&'a self) -> &'a [Credential] {
        &self.credentials
    }
}

impl ::protobuf::Message for Credentials {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.credentials));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.credentials.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.credentials.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Credentials>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Credentials {
    fn new() -> Credentials {
        Credentials::new()
    }

    fn descriptor_static(_: ::std::option::Option<Credentials>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "credentials",
                    Credentials::get_credentials,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Credentials>(
                    "Credentials",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Credentials {
    fn clear(&mut self) {
        self.clear_credentials();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Credentials {
    fn eq(&self, other: &Credentials) -> bool {
        self.credentials == other.credentials &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Credentials {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ACL {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ACL {
    pub fn new() -> ACL {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ACL {
        static mut instance: ::protobuf::lazy::Lazy<ACL> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ACL,
        };
        unsafe {
            instance.get(|| {
                ACL {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for ACL {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ACL>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ACL {
    fn new() -> ACL {
        ACL::new()
    }

    fn descriptor_static(_: ::std::option::Option<ACL>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ACL>(
                    "ACL",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ACL {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ACL {
    fn eq(&self, other: &ACL) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ACL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ACL_Entity {
    // message fields
    field_type: ::std::option::Option<ACL_Entity_Type>,
    values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ACL_Entity {
    pub fn new() -> ACL_Entity {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ACL_Entity {
        static mut instance: ::protobuf::lazy::Lazy<ACL_Entity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ACL_Entity,
        };
        unsafe {
            instance.get(|| {
                ACL_Entity {
                    field_type: ::std::option::Option::None,
                    values: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.ACL.Entity.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ACL_Entity_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> ACL_Entity_Type {
        self.field_type.unwrap_or(ACL_Entity_Type::SOME)
    }

    // repeated string values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    pub fn get_values<'a>(&'a self) -> &'a [::std::string::String] {
        &self.values
    }
}

impl ::protobuf::Message for ACL_Entity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.values));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.values.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v as i32));
        };
        for v in self.values.iter() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ACL_Entity>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ACL_Entity {
    fn new() -> ACL_Entity {
        ACL_Entity::new()
    }

    fn descriptor_static(_: ::std::option::Option<ACL_Entity>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    ACL_Entity::has_field_type,
                    ACL_Entity::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "values",
                    ACL_Entity::get_values,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ACL_Entity>(
                    "ACL_Entity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ACL_Entity {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ACL_Entity {
    fn eq(&self, other: &ACL_Entity) -> bool {
        self.field_type == other.field_type &&
        self.values == other.values &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ACL_Entity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ACL_Entity_Type {
    SOME = 0,
    ANY = 1,
    NONE = 2,
}

impl ::protobuf::ProtobufEnum for ACL_Entity_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ACL_Entity_Type> {
        match value {
            0 => ::std::option::Option::Some(ACL_Entity_Type::SOME),
            1 => ::std::option::Option::Some(ACL_Entity_Type::ANY),
            2 => ::std::option::Option::Some(ACL_Entity_Type::NONE),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<ACL_Entity_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ACL_Entity_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ACL_Entity_Type {
}

#[derive(Clone,Default)]
pub struct ACL_RegisterFramework {
    // message fields
    principals: ::protobuf::SingularPtrField<ACL_Entity>,
    roles: ::protobuf::SingularPtrField<ACL_Entity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ACL_RegisterFramework {
    pub fn new() -> ACL_RegisterFramework {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ACL_RegisterFramework {
        static mut instance: ::protobuf::lazy::Lazy<ACL_RegisterFramework> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ACL_RegisterFramework,
        };
        unsafe {
            instance.get(|| {
                ACL_RegisterFramework {
                    principals: ::protobuf::SingularPtrField::none(),
                    roles: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.ACL.Entity principals = 1;

    pub fn clear_principals(&mut self) {
        self.principals.clear();
    }

    pub fn has_principals(&self) -> bool {
        self.principals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principals(&mut self, v: ACL_Entity) {
        self.principals = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principals<'a>(&'a mut self) -> &'a mut ACL_Entity {
        if self.principals.is_none() {
            self.principals.set_default();
        };
        self.principals.as_mut().unwrap()
    }

    // Take field
    pub fn take_principals(&mut self) -> ACL_Entity {
        self.principals.take().unwrap_or_else(|| ACL_Entity::new())
    }

    pub fn get_principals<'a>(&'a self) -> &'a ACL_Entity {
        self.principals.as_ref().unwrap_or_else(|| ACL_Entity::default_instance())
    }

    // required .mesos.ACL.Entity roles = 2;

    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    pub fn has_roles(&self) -> bool {
        self.roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ACL_Entity) {
        self.roles = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_roles<'a>(&'a mut self) -> &'a mut ACL_Entity {
        if self.roles.is_none() {
            self.roles.set_default();
        };
        self.roles.as_mut().unwrap()
    }

    // Take field
    pub fn take_roles(&mut self) -> ACL_Entity {
        self.roles.take().unwrap_or_else(|| ACL_Entity::new())
    }

    pub fn get_roles<'a>(&'a self) -> &'a ACL_Entity {
        self.roles.as_ref().unwrap_or_else(|| ACL_Entity::default_instance())
    }
}

impl ::protobuf::Message for ACL_RegisterFramework {
    fn is_initialized(&self) -> bool {
        if self.principals.is_none() {
            return false;
        };
        if self.roles.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.principals.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.roles.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.principals.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.roles.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.principals.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.roles.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ACL_RegisterFramework>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ACL_RegisterFramework {
    fn new() -> ACL_RegisterFramework {
        ACL_RegisterFramework::new()
    }

    fn descriptor_static(_: ::std::option::Option<ACL_RegisterFramework>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "principals",
                    ACL_RegisterFramework::has_principals,
                    ACL_RegisterFramework::get_principals,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "roles",
                    ACL_RegisterFramework::has_roles,
                    ACL_RegisterFramework::get_roles,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ACL_RegisterFramework>(
                    "ACL_RegisterFramework",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ACL_RegisterFramework {
    fn clear(&mut self) {
        self.clear_principals();
        self.clear_roles();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ACL_RegisterFramework {
    fn eq(&self, other: &ACL_RegisterFramework) -> bool {
        self.principals == other.principals &&
        self.roles == other.roles &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ACL_RegisterFramework {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ACL_RunTask {
    // message fields
    principals: ::protobuf::SingularPtrField<ACL_Entity>,
    users: ::protobuf::SingularPtrField<ACL_Entity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ACL_RunTask {
    pub fn new() -> ACL_RunTask {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ACL_RunTask {
        static mut instance: ::protobuf::lazy::Lazy<ACL_RunTask> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ACL_RunTask,
        };
        unsafe {
            instance.get(|| {
                ACL_RunTask {
                    principals: ::protobuf::SingularPtrField::none(),
                    users: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.ACL.Entity principals = 1;

    pub fn clear_principals(&mut self) {
        self.principals.clear();
    }

    pub fn has_principals(&self) -> bool {
        self.principals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principals(&mut self, v: ACL_Entity) {
        self.principals = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principals<'a>(&'a mut self) -> &'a mut ACL_Entity {
        if self.principals.is_none() {
            self.principals.set_default();
        };
        self.principals.as_mut().unwrap()
    }

    // Take field
    pub fn take_principals(&mut self) -> ACL_Entity {
        self.principals.take().unwrap_or_else(|| ACL_Entity::new())
    }

    pub fn get_principals<'a>(&'a self) -> &'a ACL_Entity {
        self.principals.as_ref().unwrap_or_else(|| ACL_Entity::default_instance())
    }

    // required .mesos.ACL.Entity users = 2;

    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    pub fn has_users(&self) -> bool {
        self.users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ACL_Entity) {
        self.users = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_users<'a>(&'a mut self) -> &'a mut ACL_Entity {
        if self.users.is_none() {
            self.users.set_default();
        };
        self.users.as_mut().unwrap()
    }

    // Take field
    pub fn take_users(&mut self) -> ACL_Entity {
        self.users.take().unwrap_or_else(|| ACL_Entity::new())
    }

    pub fn get_users<'a>(&'a self) -> &'a ACL_Entity {
        self.users.as_ref().unwrap_or_else(|| ACL_Entity::default_instance())
    }
}

impl ::protobuf::Message for ACL_RunTask {
    fn is_initialized(&self) -> bool {
        if self.principals.is_none() {
            return false;
        };
        if self.users.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.principals.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.users.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.principals.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.users.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.principals.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.users.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ACL_RunTask>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ACL_RunTask {
    fn new() -> ACL_RunTask {
        ACL_RunTask::new()
    }

    fn descriptor_static(_: ::std::option::Option<ACL_RunTask>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "principals",
                    ACL_RunTask::has_principals,
                    ACL_RunTask::get_principals,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "users",
                    ACL_RunTask::has_users,
                    ACL_RunTask::get_users,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ACL_RunTask>(
                    "ACL_RunTask",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ACL_RunTask {
    fn clear(&mut self) {
        self.clear_principals();
        self.clear_users();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ACL_RunTask {
    fn eq(&self, other: &ACL_RunTask) -> bool {
        self.principals == other.principals &&
        self.users == other.users &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ACL_RunTask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ACL_ShutdownFramework {
    // message fields
    principals: ::protobuf::SingularPtrField<ACL_Entity>,
    framework_principals: ::protobuf::SingularPtrField<ACL_Entity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ACL_ShutdownFramework {
    pub fn new() -> ACL_ShutdownFramework {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ACL_ShutdownFramework {
        static mut instance: ::protobuf::lazy::Lazy<ACL_ShutdownFramework> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ACL_ShutdownFramework,
        };
        unsafe {
            instance.get(|| {
                ACL_ShutdownFramework {
                    principals: ::protobuf::SingularPtrField::none(),
                    framework_principals: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.ACL.Entity principals = 1;

    pub fn clear_principals(&mut self) {
        self.principals.clear();
    }

    pub fn has_principals(&self) -> bool {
        self.principals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principals(&mut self, v: ACL_Entity) {
        self.principals = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principals<'a>(&'a mut self) -> &'a mut ACL_Entity {
        if self.principals.is_none() {
            self.principals.set_default();
        };
        self.principals.as_mut().unwrap()
    }

    // Take field
    pub fn take_principals(&mut self) -> ACL_Entity {
        self.principals.take().unwrap_or_else(|| ACL_Entity::new())
    }

    pub fn get_principals<'a>(&'a self) -> &'a ACL_Entity {
        self.principals.as_ref().unwrap_or_else(|| ACL_Entity::default_instance())
    }

    // required .mesos.ACL.Entity framework_principals = 2;

    pub fn clear_framework_principals(&mut self) {
        self.framework_principals.clear();
    }

    pub fn has_framework_principals(&self) -> bool {
        self.framework_principals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_principals(&mut self, v: ACL_Entity) {
        self.framework_principals = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_principals<'a>(&'a mut self) -> &'a mut ACL_Entity {
        if self.framework_principals.is_none() {
            self.framework_principals.set_default();
        };
        self.framework_principals.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_principals(&mut self) -> ACL_Entity {
        self.framework_principals.take().unwrap_or_else(|| ACL_Entity::new())
    }

    pub fn get_framework_principals<'a>(&'a self) -> &'a ACL_Entity {
        self.framework_principals.as_ref().unwrap_or_else(|| ACL_Entity::default_instance())
    }
}

impl ::protobuf::Message for ACL_ShutdownFramework {
    fn is_initialized(&self) -> bool {
        if self.principals.is_none() {
            return false;
        };
        if self.framework_principals.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.principals.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.framework_principals.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.principals.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.framework_principals.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.principals.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.framework_principals.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ACL_ShutdownFramework>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ACL_ShutdownFramework {
    fn new() -> ACL_ShutdownFramework {
        ACL_ShutdownFramework::new()
    }

    fn descriptor_static(_: ::std::option::Option<ACL_ShutdownFramework>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "principals",
                    ACL_ShutdownFramework::has_principals,
                    ACL_ShutdownFramework::get_principals,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "framework_principals",
                    ACL_ShutdownFramework::has_framework_principals,
                    ACL_ShutdownFramework::get_framework_principals,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ACL_ShutdownFramework>(
                    "ACL_ShutdownFramework",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ACL_ShutdownFramework {
    fn clear(&mut self) {
        self.clear_principals();
        self.clear_framework_principals();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ACL_ShutdownFramework {
    fn eq(&self, other: &ACL_ShutdownFramework) -> bool {
        self.principals == other.principals &&
        self.framework_principals == other.framework_principals &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ACL_ShutdownFramework {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ACLs {
    // message fields
    permissive: ::std::option::Option<bool>,
    register_frameworks: ::protobuf::RepeatedField<ACL_RegisterFramework>,
    run_tasks: ::protobuf::RepeatedField<ACL_RunTask>,
    shutdown_frameworks: ::protobuf::RepeatedField<ACL_ShutdownFramework>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ACLs {
    pub fn new() -> ACLs {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ACLs {
        static mut instance: ::protobuf::lazy::Lazy<ACLs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ACLs,
        };
        unsafe {
            instance.get(|| {
                ACLs {
                    permissive: ::std::option::Option::None,
                    register_frameworks: ::protobuf::RepeatedField::new(),
                    run_tasks: ::protobuf::RepeatedField::new(),
                    shutdown_frameworks: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bool permissive = 1;

    pub fn clear_permissive(&mut self) {
        self.permissive = ::std::option::Option::None;
    }

    pub fn has_permissive(&self) -> bool {
        self.permissive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissive(&mut self, v: bool) {
        self.permissive = ::std::option::Option::Some(v);
    }

    pub fn get_permissive<'a>(&self) -> bool {
        self.permissive.unwrap_or(true)
    }

    // repeated .mesos.ACL.RegisterFramework register_frameworks = 2;

    pub fn clear_register_frameworks(&mut self) {
        self.register_frameworks.clear();
    }

    // Param is passed by value, moved
    pub fn set_register_frameworks(&mut self, v: ::protobuf::RepeatedField<ACL_RegisterFramework>) {
        self.register_frameworks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_register_frameworks<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ACL_RegisterFramework> {
        &mut self.register_frameworks
    }

    // Take field
    pub fn take_register_frameworks(&mut self) -> ::protobuf::RepeatedField<ACL_RegisterFramework> {
        ::std::mem::replace(&mut self.register_frameworks, ::protobuf::RepeatedField::new())
    }

    pub fn get_register_frameworks<'a>(&'a self) -> &'a [ACL_RegisterFramework] {
        &self.register_frameworks
    }

    // repeated .mesos.ACL.RunTask run_tasks = 3;

    pub fn clear_run_tasks(&mut self) {
        self.run_tasks.clear();
    }

    // Param is passed by value, moved
    pub fn set_run_tasks(&mut self, v: ::protobuf::RepeatedField<ACL_RunTask>) {
        self.run_tasks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_run_tasks<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ACL_RunTask> {
        &mut self.run_tasks
    }

    // Take field
    pub fn take_run_tasks(&mut self) -> ::protobuf::RepeatedField<ACL_RunTask> {
        ::std::mem::replace(&mut self.run_tasks, ::protobuf::RepeatedField::new())
    }

    pub fn get_run_tasks<'a>(&'a self) -> &'a [ACL_RunTask] {
        &self.run_tasks
    }

    // repeated .mesos.ACL.ShutdownFramework shutdown_frameworks = 4;

    pub fn clear_shutdown_frameworks(&mut self) {
        self.shutdown_frameworks.clear();
    }

    // Param is passed by value, moved
    pub fn set_shutdown_frameworks(&mut self, v: ::protobuf::RepeatedField<ACL_ShutdownFramework>) {
        self.shutdown_frameworks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shutdown_frameworks<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ACL_ShutdownFramework> {
        &mut self.shutdown_frameworks
    }

    // Take field
    pub fn take_shutdown_frameworks(&mut self) -> ::protobuf::RepeatedField<ACL_ShutdownFramework> {
        ::std::mem::replace(&mut self.shutdown_frameworks, ::protobuf::RepeatedField::new())
    }

    pub fn get_shutdown_frameworks<'a>(&'a self) -> &'a [ACL_ShutdownFramework] {
        &self.shutdown_frameworks
    }
}

impl ::protobuf::Message for ACLs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.permissive = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.register_frameworks));
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.run_tasks));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shutdown_frameworks));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.permissive.is_some() {
            my_size += 2;
        };
        for value in self.register_frameworks.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.run_tasks.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.shutdown_frameworks.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.permissive {
            try!(os.write_bool(1, v));
        };
        for v in self.register_frameworks.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.run_tasks.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.shutdown_frameworks.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ACLs>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ACLs {
    fn new() -> ACLs {
        ACLs::new()
    }

    fn descriptor_static(_: ::std::option::Option<ACLs>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "permissive",
                    ACLs::has_permissive,
                    ACLs::get_permissive,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "register_frameworks",
                    ACLs::get_register_frameworks,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "run_tasks",
                    ACLs::get_run_tasks,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "shutdown_frameworks",
                    ACLs::get_shutdown_frameworks,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ACLs>(
                    "ACLs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ACLs {
    fn clear(&mut self) {
        self.clear_permissive();
        self.clear_register_frameworks();
        self.clear_run_tasks();
        self.clear_shutdown_frameworks();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ACLs {
    fn eq(&self, other: &ACLs) -> bool {
        self.permissive == other.permissive &&
        self.register_frameworks == other.register_frameworks &&
        self.run_tasks == other.run_tasks &&
        self.shutdown_frameworks == other.shutdown_frameworks &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ACLs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RateLimit {
    // message fields
    qps: ::std::option::Option<f64>,
    principal: ::protobuf::SingularField<::std::string::String>,
    capacity: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RateLimit {
    pub fn new() -> RateLimit {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RateLimit {
        static mut instance: ::protobuf::lazy::Lazy<RateLimit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RateLimit,
        };
        unsafe {
            instance.get(|| {
                RateLimit {
                    qps: ::std::option::Option::None,
                    principal: ::protobuf::SingularField::none(),
                    capacity: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional double qps = 1;

    pub fn clear_qps(&mut self) {
        self.qps = ::std::option::Option::None;
    }

    pub fn has_qps(&self) -> bool {
        self.qps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qps(&mut self, v: f64) {
        self.qps = ::std::option::Option::Some(v);
    }

    pub fn get_qps<'a>(&self) -> f64 {
        self.qps.unwrap_or(0.)
    }

    // required string principal = 2;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        };
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal<'a>(&'a self) -> &'a str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint64 capacity = 3;

    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    pub fn get_capacity<'a>(&self) -> u64 {
        self.capacity.unwrap_or(0)
    }
}

impl ::protobuf::Message for RateLimit {
    fn is_initialized(&self) -> bool {
        if self.principal.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.qps = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.principal.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.qps.is_some() {
            my_size += 9;
        };
        for value in self.principal.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.capacity.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.qps {
            try!(os.write_double(1, v));
        };
        if let Some(v) = self.principal.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.capacity {
            try!(os.write_uint64(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RateLimit>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RateLimit {
    fn new() -> RateLimit {
        RateLimit::new()
    }

    fn descriptor_static(_: ::std::option::Option<RateLimit>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "qps",
                    RateLimit::has_qps,
                    RateLimit::get_qps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "principal",
                    RateLimit::has_principal,
                    RateLimit::get_principal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "capacity",
                    RateLimit::has_capacity,
                    RateLimit::get_capacity,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RateLimit>(
                    "RateLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RateLimit {
    fn clear(&mut self) {
        self.clear_qps();
        self.clear_principal();
        self.clear_capacity();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RateLimit {
    fn eq(&self, other: &RateLimit) -> bool {
        self.qps == other.qps &&
        self.principal == other.principal &&
        self.capacity == other.capacity &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RateLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RateLimits {
    // message fields
    limits: ::protobuf::RepeatedField<RateLimit>,
    aggregate_default_qps: ::std::option::Option<f64>,
    aggregate_default_capacity: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl RateLimits {
    pub fn new() -> RateLimits {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RateLimits {
        static mut instance: ::protobuf::lazy::Lazy<RateLimits> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RateLimits,
        };
        unsafe {
            instance.get(|| {
                RateLimits {
                    limits: ::protobuf::RepeatedField::new(),
                    aggregate_default_qps: ::std::option::Option::None,
                    aggregate_default_capacity: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.RateLimit limits = 1;

    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::protobuf::RepeatedField<RateLimit>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<RateLimit> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::protobuf::RepeatedField<RateLimit> {
        ::std::mem::replace(&mut self.limits, ::protobuf::RepeatedField::new())
    }

    pub fn get_limits<'a>(&'a self) -> &'a [RateLimit] {
        &self.limits
    }

    // optional double aggregate_default_qps = 2;

    pub fn clear_aggregate_default_qps(&mut self) {
        self.aggregate_default_qps = ::std::option::Option::None;
    }

    pub fn has_aggregate_default_qps(&self) -> bool {
        self.aggregate_default_qps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_default_qps(&mut self, v: f64) {
        self.aggregate_default_qps = ::std::option::Option::Some(v);
    }

    pub fn get_aggregate_default_qps<'a>(&self) -> f64 {
        self.aggregate_default_qps.unwrap_or(0.)
    }

    // optional uint64 aggregate_default_capacity = 3;

    pub fn clear_aggregate_default_capacity(&mut self) {
        self.aggregate_default_capacity = ::std::option::Option::None;
    }

    pub fn has_aggregate_default_capacity(&self) -> bool {
        self.aggregate_default_capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_default_capacity(&mut self, v: u64) {
        self.aggregate_default_capacity = ::std::option::Option::Some(v);
    }

    pub fn get_aggregate_default_capacity<'a>(&self) -> u64 {
        self.aggregate_default_capacity.unwrap_or(0)
    }
}

impl ::protobuf::Message for RateLimits {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limits));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.aggregate_default_qps = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.aggregate_default_capacity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.limits.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.aggregate_default_qps.is_some() {
            my_size += 9;
        };
        for value in self.aggregate_default_capacity.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.limits.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.aggregate_default_qps {
            try!(os.write_double(2, v));
        };
        if let Some(v) = self.aggregate_default_capacity {
            try!(os.write_uint64(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RateLimits>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RateLimits {
    fn new() -> RateLimits {
        RateLimits::new()
    }

    fn descriptor_static(_: ::std::option::Option<RateLimits>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "limits",
                    RateLimits::get_limits,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "aggregate_default_qps",
                    RateLimits::has_aggregate_default_qps,
                    RateLimits::get_aggregate_default_qps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "aggregate_default_capacity",
                    RateLimits::has_aggregate_default_capacity,
                    RateLimits::get_aggregate_default_capacity,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RateLimits>(
                    "RateLimits",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RateLimits {
    fn clear(&mut self) {
        self.clear_limits();
        self.clear_aggregate_default_qps();
        self.clear_aggregate_default_capacity();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RateLimits {
    fn eq(&self, other: &RateLimits) -> bool {
        self.limits == other.limits &&
        self.aggregate_default_qps == other.aggregate_default_qps &&
        self.aggregate_default_capacity == other.aggregate_default_capacity &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RateLimits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Image {
    // message fields
    field_type: ::std::option::Option<Image_Type>,
    appc: ::protobuf::SingularPtrField<Image_AppC>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Image {
        static mut instance: ::protobuf::lazy::Lazy<Image> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Image,
        };
        unsafe {
            instance.get(|| {
                Image {
                    field_type: ::std::option::Option::None,
                    appc: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.Image.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Image_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Image_Type {
        self.field_type.unwrap_or(Image_Type::APPC)
    }

    // optional .mesos.Image.AppC appc = 2;

    pub fn clear_appc(&mut self) {
        self.appc.clear();
    }

    pub fn has_appc(&self) -> bool {
        self.appc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appc(&mut self, v: Image_AppC) {
        self.appc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appc<'a>(&'a mut self) -> &'a mut Image_AppC {
        if self.appc.is_none() {
            self.appc.set_default();
        };
        self.appc.as_mut().unwrap()
    }

    // Take field
    pub fn take_appc(&mut self) -> Image_AppC {
        self.appc.take().unwrap_or_else(|| Image_AppC::new())
    }

    pub fn get_appc<'a>(&'a self) -> &'a Image_AppC {
        self.appc.as_ref().unwrap_or_else(|| Image_AppC::default_instance())
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.appc.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.appc.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v as i32));
        };
        if let Some(v) = self.appc.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Image>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Image {
    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static(_: ::std::option::Option<Image>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    Image::has_field_type,
                    Image::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "appc",
                    Image::has_appc,
                    Image::get_appc,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Image>(
                    "Image",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_appc();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Image {
    fn eq(&self, other: &Image) -> bool {
        self.field_type == other.field_type &&
        self.appc == other.appc &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Image_AppC {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    id: ::protobuf::SingularField<::std::string::String>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Image_AppC {
    pub fn new() -> Image_AppC {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Image_AppC {
        static mut instance: ::protobuf::lazy::Lazy<Image_AppC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Image_AppC,
        };
        unsafe {
            instance.get(|| {
                Image_AppC {
                    name: ::protobuf::SingularField::none(),
                    id: ::protobuf::SingularField::none(),
                    labels: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.Labels labels = 3;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }
}

impl ::protobuf::Message for Image_AppC {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.id.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.labels.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.id.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.id.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Image_AppC>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Image_AppC {
    fn new() -> Image_AppC {
        Image_AppC::new()
    }

    fn descriptor_static(_: ::std::option::Option<Image_AppC>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Image_AppC::has_name,
                    Image_AppC::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "id",
                    Image_AppC::has_id,
                    Image_AppC::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    Image_AppC::has_labels,
                    Image_AppC::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Image_AppC>(
                    "Image_AppC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Image_AppC {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_id();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Image_AppC {
    fn eq(&self, other: &Image_AppC) -> bool {
        self.name == other.name &&
        self.id == other.id &&
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Image_AppC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Image_Type {
    APPC = 1,
}

impl ::protobuf::ProtobufEnum for Image_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Image_Type> {
        match value {
            1 => ::std::option::Option::Some(Image_Type::APPC),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<Image_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Image_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Image_Type {
}

#[derive(Clone,Default)]
pub struct Volume {
    // message fields
    mode: ::std::option::Option<Volume_Mode>,
    container_path: ::protobuf::SingularField<::std::string::String>,
    host_path: ::protobuf::SingularField<::std::string::String>,
    image: ::protobuf::SingularPtrField<Image>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Volume {
    pub fn new() -> Volume {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Volume {
        static mut instance: ::protobuf::lazy::Lazy<Volume> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Volume,
        };
        unsafe {
            instance.get(|| {
                Volume {
                    mode: ::std::option::Option::None,
                    container_path: ::protobuf::SingularField::none(),
                    host_path: ::protobuf::SingularField::none(),
                    image: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.Volume.Mode mode = 3;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: Volume_Mode) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode<'a>(&self) -> Volume_Mode {
        self.mode.unwrap_or(Volume_Mode::RW)
    }

    // required string container_path = 1;

    pub fn clear_container_path(&mut self) {
        self.container_path.clear();
    }

    pub fn has_container_path(&self) -> bool {
        self.container_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_path(&mut self, v: ::std::string::String) {
        self.container_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.container_path.is_none() {
            self.container_path.set_default();
        };
        self.container_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_container_path(&mut self) -> ::std::string::String {
        self.container_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_container_path<'a>(&'a self) -> &'a str {
        match self.container_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string host_path = 2;

    pub fn clear_host_path(&mut self) {
        self.host_path.clear();
    }

    pub fn has_host_path(&self) -> bool {
        self.host_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_path(&mut self, v: ::std::string::String) {
        self.host_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.host_path.is_none() {
            self.host_path.set_default();
        };
        self.host_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_path(&mut self) -> ::std::string::String {
        self.host_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_host_path<'a>(&'a self) -> &'a str {
        match self.host_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.Image image = 4;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Image) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image<'a>(&'a mut self) -> &'a mut Image {
        if self.image.is_none() {
            self.image.set_default();
        };
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Image {
        self.image.take().unwrap_or_else(|| Image::new())
    }

    pub fn get_image<'a>(&'a self) -> &'a Image {
        self.image.as_ref().unwrap_or_else(|| Image::default_instance())
    }
}

impl ::protobuf::Message for Volume {
    fn is_initialized(&self) -> bool {
        if self.mode.is_none() {
            return false;
        };
        if self.container_path.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.mode = ::std::option::Option::Some(tmp);
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.container_path.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.host_path.set_default();
                    try!(is.read_string_into(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.image.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.mode.iter() {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        for value in self.container_path.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.host_path.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.image.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode {
            try!(os.write_enum(3, v as i32));
        };
        if let Some(v) = self.container_path.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.host_path.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.image.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Volume>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Volume {
    fn new() -> Volume {
        Volume::new()
    }

    fn descriptor_static(_: ::std::option::Option<Volume>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "mode",
                    Volume::has_mode,
                    Volume::get_mode,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "container_path",
                    Volume::has_container_path,
                    Volume::get_container_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "host_path",
                    Volume::has_host_path,
                    Volume::get_host_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "image",
                    Volume::has_image,
                    Volume::get_image,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Volume>(
                    "Volume",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Volume {
    fn clear(&mut self) {
        self.clear_mode();
        self.clear_container_path();
        self.clear_host_path();
        self.clear_image();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Volume {
    fn eq(&self, other: &Volume) -> bool {
        self.mode == other.mode &&
        self.container_path == other.container_path &&
        self.host_path == other.host_path &&
        self.image == other.image &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Volume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Volume_Mode {
    RW = 1,
    RO = 2,
}

impl ::protobuf::ProtobufEnum for Volume_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Volume_Mode> {
        match value {
            1 => ::std::option::Option::Some(Volume_Mode::RW),
            2 => ::std::option::Option::Some(Volume_Mode::RO),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<Volume_Mode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Volume_Mode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Volume_Mode {
}

#[derive(Clone,Default)]
pub struct ContainerInfo {
    // message fields
    field_type: ::std::option::Option<ContainerInfo_Type>,
    volumes: ::protobuf::RepeatedField<Volume>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    docker: ::protobuf::SingularPtrField<ContainerInfo_DockerInfo>,
    mesos: ::protobuf::SingularPtrField<ContainerInfo_MesosInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ContainerInfo {
    pub fn new() -> ContainerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo,
        };
        unsafe {
            instance.get(|| {
                ContainerInfo {
                    field_type: ::std::option::Option::None,
                    volumes: ::protobuf::RepeatedField::new(),
                    hostname: ::protobuf::SingularField::none(),
                    docker: ::protobuf::SingularPtrField::none(),
                    mesos: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.ContainerInfo.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ContainerInfo_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> ContainerInfo_Type {
        self.field_type.unwrap_or(ContainerInfo_Type::DOCKER)
    }

    // repeated .mesos.Volume volumes = 2;

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Volume>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Volume> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Volume> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumes<'a>(&'a self) -> &'a [Volume] {
        &self.volumes
    }

    // optional string hostname = 4;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.ContainerInfo.DockerInfo docker = 3;

    pub fn clear_docker(&mut self) {
        self.docker.clear();
    }

    pub fn has_docker(&self) -> bool {
        self.docker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_docker(&mut self, v: ContainerInfo_DockerInfo) {
        self.docker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_docker<'a>(&'a mut self) -> &'a mut ContainerInfo_DockerInfo {
        if self.docker.is_none() {
            self.docker.set_default();
        };
        self.docker.as_mut().unwrap()
    }

    // Take field
    pub fn take_docker(&mut self) -> ContainerInfo_DockerInfo {
        self.docker.take().unwrap_or_else(|| ContainerInfo_DockerInfo::new())
    }

    pub fn get_docker<'a>(&'a self) -> &'a ContainerInfo_DockerInfo {
        self.docker.as_ref().unwrap_or_else(|| ContainerInfo_DockerInfo::default_instance())
    }

    // optional .mesos.ContainerInfo.MesosInfo mesos = 5;

    pub fn clear_mesos(&mut self) {
        self.mesos.clear();
    }

    pub fn has_mesos(&self) -> bool {
        self.mesos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mesos(&mut self, v: ContainerInfo_MesosInfo) {
        self.mesos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mesos<'a>(&'a mut self) -> &'a mut ContainerInfo_MesosInfo {
        if self.mesos.is_none() {
            self.mesos.set_default();
        };
        self.mesos.as_mut().unwrap()
    }

    // Take field
    pub fn take_mesos(&mut self) -> ContainerInfo_MesosInfo {
        self.mesos.take().unwrap_or_else(|| ContainerInfo_MesosInfo::new())
    }

    pub fn get_mesos<'a>(&'a self) -> &'a ContainerInfo_MesosInfo {
        self.mesos.as_ref().unwrap_or_else(|| ContainerInfo_MesosInfo::default_instance())
    }
}

impl ::protobuf::Message for ContainerInfo {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.hostname.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.docker.set_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.mesos.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.volumes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.docker.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.mesos.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v as i32));
        };
        for v in self.volumes.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.docker.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.mesos.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo {
    fn new() -> ContainerInfo {
        ContainerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    ContainerInfo::has_field_type,
                    ContainerInfo::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "volumes",
                    ContainerInfo::get_volumes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    ContainerInfo::has_hostname,
                    ContainerInfo::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "docker",
                    ContainerInfo::has_docker,
                    ContainerInfo::get_docker,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "mesos",
                    ContainerInfo::has_mesos,
                    ContainerInfo::get_mesos,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo>(
                    "ContainerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_volumes();
        self.clear_hostname();
        self.clear_docker();
        self.clear_mesos();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerInfo {
    fn eq(&self, other: &ContainerInfo) -> bool {
        self.field_type == other.field_type &&
        self.volumes == other.volumes &&
        self.hostname == other.hostname &&
        self.docker == other.docker &&
        self.mesos == other.mesos &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ContainerInfo_DockerInfo {
    // message fields
    image: ::protobuf::SingularField<::std::string::String>,
    network: ::std::option::Option<ContainerInfo_DockerInfo_Network>,
    port_mappings: ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping>,
    privileged: ::std::option::Option<bool>,
    parameters: ::protobuf::RepeatedField<Parameter>,
    force_pull_image: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ContainerInfo_DockerInfo {
    pub fn new() -> ContainerInfo_DockerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo_DockerInfo {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo_DockerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo_DockerInfo,
        };
        unsafe {
            instance.get(|| {
                ContainerInfo_DockerInfo {
                    image: ::protobuf::SingularField::none(),
                    network: ::std::option::Option::None,
                    port_mappings: ::protobuf::RepeatedField::new(),
                    privileged: ::std::option::Option::None,
                    parameters: ::protobuf::RepeatedField::new(),
                    force_pull_image: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string image = 1;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        };
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_image<'a>(&'a self) -> &'a str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.ContainerInfo.DockerInfo.Network network = 2;

    pub fn clear_network(&mut self) {
        self.network = ::std::option::Option::None;
    }

    pub fn has_network(&self) -> bool {
        self.network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ContainerInfo_DockerInfo_Network) {
        self.network = ::std::option::Option::Some(v);
    }

    pub fn get_network<'a>(&self) -> ContainerInfo_DockerInfo_Network {
        self.network.unwrap_or(ContainerInfo_DockerInfo_Network::HOST)
    }

    // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;

    pub fn clear_port_mappings(&mut self) {
        self.port_mappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_mappings(&mut self, v: ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping>) {
        self.port_mappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_port_mappings<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping> {
        &mut self.port_mappings
    }

    // Take field
    pub fn take_port_mappings(&mut self) -> ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping> {
        ::std::mem::replace(&mut self.port_mappings, ::protobuf::RepeatedField::new())
    }

    pub fn get_port_mappings<'a>(&'a self) -> &'a [ContainerInfo_DockerInfo_PortMapping] {
        &self.port_mappings
    }

    // optional bool privileged = 4;

    pub fn clear_privileged(&mut self) {
        self.privileged = ::std::option::Option::None;
    }

    pub fn has_privileged(&self) -> bool {
        self.privileged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privileged(&mut self, v: bool) {
        self.privileged = ::std::option::Option::Some(v);
    }

    pub fn get_privileged<'a>(&self) -> bool {
        self.privileged.unwrap_or(false)
    }

    // repeated .mesos.Parameter parameters = 5;

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::protobuf::RepeatedField<Parameter>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Parameter> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::protobuf::RepeatedField<Parameter> {
        ::std::mem::replace(&mut self.parameters, ::protobuf::RepeatedField::new())
    }

    pub fn get_parameters<'a>(&'a self) -> &'a [Parameter] {
        &self.parameters
    }

    // optional bool force_pull_image = 6;

    pub fn clear_force_pull_image(&mut self) {
        self.force_pull_image = ::std::option::Option::None;
    }

    pub fn has_force_pull_image(&self) -> bool {
        self.force_pull_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_pull_image(&mut self, v: bool) {
        self.force_pull_image = ::std::option::Option::Some(v);
    }

    pub fn get_force_pull_image<'a>(&self) -> bool {
        self.force_pull_image.unwrap_or(false)
    }
}

impl ::protobuf::Message for ContainerInfo_DockerInfo {
    fn is_initialized(&self) -> bool {
        if self.image.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.image.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.network = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.port_mappings));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.privileged = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameters));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.force_pull_image = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.image.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.network.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in self.port_mappings.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.privileged.is_some() {
            my_size += 2;
        };
        for value in self.parameters.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.force_pull_image.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.image.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.network {
            try!(os.write_enum(2, v as i32));
        };
        for v in self.port_mappings.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.privileged {
            try!(os.write_bool(4, v));
        };
        for v in self.parameters.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.force_pull_image {
            try!(os.write_bool(6, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerInfo_DockerInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo_DockerInfo {
    fn new() -> ContainerInfo_DockerInfo {
        ContainerInfo_DockerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo_DockerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "image",
                    ContainerInfo_DockerInfo::has_image,
                    ContainerInfo_DockerInfo::get_image,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "network",
                    ContainerInfo_DockerInfo::has_network,
                    ContainerInfo_DockerInfo::get_network,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "port_mappings",
                    ContainerInfo_DockerInfo::get_port_mappings,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "privileged",
                    ContainerInfo_DockerInfo::has_privileged,
                    ContainerInfo_DockerInfo::get_privileged,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "parameters",
                    ContainerInfo_DockerInfo::get_parameters,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "force_pull_image",
                    ContainerInfo_DockerInfo::has_force_pull_image,
                    ContainerInfo_DockerInfo::get_force_pull_image,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo_DockerInfo>(
                    "ContainerInfo_DockerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo_DockerInfo {
    fn clear(&mut self) {
        self.clear_image();
        self.clear_network();
        self.clear_port_mappings();
        self.clear_privileged();
        self.clear_parameters();
        self.clear_force_pull_image();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerInfo_DockerInfo {
    fn eq(&self, other: &ContainerInfo_DockerInfo) -> bool {
        self.image == other.image &&
        self.network == other.network &&
        self.port_mappings == other.port_mappings &&
        self.privileged == other.privileged &&
        self.parameters == other.parameters &&
        self.force_pull_image == other.force_pull_image &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerInfo_DockerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ContainerInfo_DockerInfo_PortMapping {
    // message fields
    host_port: ::std::option::Option<u32>,
    container_port: ::std::option::Option<u32>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ContainerInfo_DockerInfo_PortMapping {
    pub fn new() -> ContainerInfo_DockerInfo_PortMapping {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo_DockerInfo_PortMapping {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo_DockerInfo_PortMapping> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo_DockerInfo_PortMapping,
        };
        unsafe {
            instance.get(|| {
                ContainerInfo_DockerInfo_PortMapping {
                    host_port: ::std::option::Option::None,
                    container_port: ::std::option::Option::None,
                    protocol: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint32 host_port = 1;

    pub fn clear_host_port(&mut self) {
        self.host_port = ::std::option::Option::None;
    }

    pub fn has_host_port(&self) -> bool {
        self.host_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_port(&mut self, v: u32) {
        self.host_port = ::std::option::Option::Some(v);
    }

    pub fn get_host_port<'a>(&self) -> u32 {
        self.host_port.unwrap_or(0)
    }

    // required uint32 container_port = 2;

    pub fn clear_container_port(&mut self) {
        self.container_port = ::std::option::Option::None;
    }

    pub fn has_container_port(&self) -> bool {
        self.container_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_port(&mut self, v: u32) {
        self.container_port = ::std::option::Option::Some(v);
    }

    pub fn get_container_port<'a>(&self) -> u32 {
        self.container_port.unwrap_or(0)
    }

    // optional string protocol = 3;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        };
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocol<'a>(&'a self) -> &'a str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ContainerInfo_DockerInfo_PortMapping {
    fn is_initialized(&self) -> bool {
        if self.host_port.is_none() {
            return false;
        };
        if self.container_port.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.host_port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.container_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.protocol.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.host_port.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.container_port.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.protocol.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.host_port {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.container_port {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.protocol.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerInfo_DockerInfo_PortMapping>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo_DockerInfo_PortMapping {
    fn new() -> ContainerInfo_DockerInfo_PortMapping {
        ContainerInfo_DockerInfo_PortMapping::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo_DockerInfo_PortMapping>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "host_port",
                    ContainerInfo_DockerInfo_PortMapping::has_host_port,
                    ContainerInfo_DockerInfo_PortMapping::get_host_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "container_port",
                    ContainerInfo_DockerInfo_PortMapping::has_container_port,
                    ContainerInfo_DockerInfo_PortMapping::get_container_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "protocol",
                    ContainerInfo_DockerInfo_PortMapping::has_protocol,
                    ContainerInfo_DockerInfo_PortMapping::get_protocol,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo_DockerInfo_PortMapping>(
                    "ContainerInfo_DockerInfo_PortMapping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo_DockerInfo_PortMapping {
    fn clear(&mut self) {
        self.clear_host_port();
        self.clear_container_port();
        self.clear_protocol();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerInfo_DockerInfo_PortMapping {
    fn eq(&self, other: &ContainerInfo_DockerInfo_PortMapping) -> bool {
        self.host_port == other.host_port &&
        self.container_port == other.container_port &&
        self.protocol == other.protocol &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerInfo_DockerInfo_PortMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContainerInfo_DockerInfo_Network {
    HOST = 1,
    BRIDGE = 2,
    NONE = 3,
}

impl ::protobuf::ProtobufEnum for ContainerInfo_DockerInfo_Network {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContainerInfo_DockerInfo_Network> {
        match value {
            1 => ::std::option::Option::Some(ContainerInfo_DockerInfo_Network::HOST),
            2 => ::std::option::Option::Some(ContainerInfo_DockerInfo_Network::BRIDGE),
            3 => ::std::option::Option::Some(ContainerInfo_DockerInfo_Network::NONE),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<ContainerInfo_DockerInfo_Network>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContainerInfo_DockerInfo_Network", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContainerInfo_DockerInfo_Network {
}

#[derive(Clone,Default)]
pub struct ContainerInfo_MesosInfo {
    // message fields
    image: ::protobuf::SingularPtrField<Image>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ContainerInfo_MesosInfo {
    pub fn new() -> ContainerInfo_MesosInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo_MesosInfo {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo_MesosInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo_MesosInfo,
        };
        unsafe {
            instance.get(|| {
                ContainerInfo_MesosInfo {
                    image: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.Image image = 1;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Image) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image<'a>(&'a mut self) -> &'a mut Image {
        if self.image.is_none() {
            self.image.set_default();
        };
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Image {
        self.image.take().unwrap_or_else(|| Image::new())
    }

    pub fn get_image<'a>(&'a self) -> &'a Image {
        self.image.as_ref().unwrap_or_else(|| Image::default_instance())
    }
}

impl ::protobuf::Message for ContainerInfo_MesosInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.image.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.image.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.image.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerInfo_MesosInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo_MesosInfo {
    fn new() -> ContainerInfo_MesosInfo {
        ContainerInfo_MesosInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo_MesosInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "image",
                    ContainerInfo_MesosInfo::has_image,
                    ContainerInfo_MesosInfo::get_image,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo_MesosInfo>(
                    "ContainerInfo_MesosInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo_MesosInfo {
    fn clear(&mut self) {
        self.clear_image();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerInfo_MesosInfo {
    fn eq(&self, other: &ContainerInfo_MesosInfo) -> bool {
        self.image == other.image &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerInfo_MesosInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContainerInfo_Type {
    DOCKER = 1,
    MESOS = 2,
}

impl ::protobuf::ProtobufEnum for ContainerInfo_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContainerInfo_Type> {
        match value {
            1 => ::std::option::Option::Some(ContainerInfo_Type::DOCKER),
            2 => ::std::option::Option::Some(ContainerInfo_Type::MESOS),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<ContainerInfo_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContainerInfo_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContainerInfo_Type {
}

#[derive(Clone,Default)]
pub struct Labels {
    // message fields
    labels: ::protobuf::RepeatedField<Label>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Labels {
    pub fn new() -> Labels {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Labels {
        static mut instance: ::protobuf::lazy::Lazy<Labels> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Labels,
        };
        unsafe {
            instance.get(|| {
                Labels {
                    labels: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.Label labels = 1;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::protobuf::RepeatedField<Label>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Label> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::protobuf::RepeatedField<Label> {
        ::std::mem::replace(&mut self.labels, ::protobuf::RepeatedField::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a [Label] {
        &self.labels
    }
}

impl ::protobuf::Message for Labels {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.labels));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.labels.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Labels>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Labels {
    fn new() -> Labels {
        Labels::new()
    }

    fn descriptor_static(_: ::std::option::Option<Labels>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "labels",
                    Labels::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Labels>(
                    "Labels",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Labels {
    fn clear(&mut self) {
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Labels {
    fn eq(&self, other: &Labels) -> bool {
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Labels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Label {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Label {
    pub fn new() -> Label {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Label {
        static mut instance: ::protobuf::lazy::Lazy<Label> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Label,
        };
        unsafe {
            instance.get(|| {
                Label {
                    key: ::protobuf::SingularField::none(),
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        };
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key<'a>(&'a self) -> &'a str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Label {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.key.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.key.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Label>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Label {
    fn new() -> Label {
        Label::new()
    }

    fn descriptor_static(_: ::std::option::Option<Label>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "key",
                    Label::has_key,
                    Label::get_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    Label::has_value,
                    Label::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Label>(
                    "Label",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Label {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Label {
    fn eq(&self, other: &Label) -> bool {
        self.key == other.key &&
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Label {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Port {
    // message fields
    number: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Port {
    pub fn new() -> Port {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Port {
        static mut instance: ::protobuf::lazy::Lazy<Port> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Port,
        };
        unsafe {
            instance.get(|| {
                Port {
                    number: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    protocol: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint32 number = 1;

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: u32) {
        self.number = ::std::option::Option::Some(v);
    }

    pub fn get_number<'a>(&self) -> u32 {
        self.number.unwrap_or(0)
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string protocol = 3;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        };
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocol<'a>(&'a self) -> &'a str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Port {
    fn is_initialized(&self) -> bool {
        if self.number.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.protocol.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.number.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.protocol.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.number {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.protocol.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Port>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Port {
    fn new() -> Port {
        Port::new()
    }

    fn descriptor_static(_: ::std::option::Option<Port>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "number",
                    Port::has_number,
                    Port::get_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Port::has_name,
                    Port::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "protocol",
                    Port::has_protocol,
                    Port::get_protocol,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Port>(
                    "Port",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Port {
    fn clear(&mut self) {
        self.clear_number();
        self.clear_name();
        self.clear_protocol();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Port {
    fn eq(&self, other: &Port) -> bool {
        self.number == other.number &&
        self.name == other.name &&
        self.protocol == other.protocol &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Port {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Ports {
    // message fields
    ports: ::protobuf::RepeatedField<Port>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Ports {
    pub fn new() -> Ports {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Ports {
        static mut instance: ::protobuf::lazy::Lazy<Ports> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ports,
        };
        unsafe {
            instance.get(|| {
                Ports {
                    ports: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.Port ports = 1;

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<Port>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Port> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<Port> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }

    pub fn get_ports<'a>(&'a self) -> &'a [Port] {
        &self.ports
    }
}

impl ::protobuf::Message for Ports {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.ports.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.ports.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Ports>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Ports {
    fn new() -> Ports {
        Ports::new()
    }

    fn descriptor_static(_: ::std::option::Option<Ports>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "ports",
                    Ports::get_ports,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ports>(
                    "Ports",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Ports {
    fn clear(&mut self) {
        self.clear_ports();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Ports {
    fn eq(&self, other: &Ports) -> bool {
        self.ports == other.ports &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Ports {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct DiscoveryInfo {
    // message fields
    visibility: ::std::option::Option<DiscoveryInfo_Visibility>,
    name: ::protobuf::SingularField<::std::string::String>,
    environment: ::protobuf::SingularField<::std::string::String>,
    location: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    ports: ::protobuf::SingularPtrField<Ports>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl DiscoveryInfo {
    pub fn new() -> DiscoveryInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DiscoveryInfo {
        static mut instance: ::protobuf::lazy::Lazy<DiscoveryInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DiscoveryInfo,
        };
        unsafe {
            instance.get(|| {
                DiscoveryInfo {
                    visibility: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    environment: ::protobuf::SingularField::none(),
                    location: ::protobuf::SingularField::none(),
                    version: ::protobuf::SingularField::none(),
                    ports: ::protobuf::SingularPtrField::none(),
                    labels: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.DiscoveryInfo.Visibility visibility = 1;

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: DiscoveryInfo_Visibility) {
        self.visibility = ::std::option::Option::Some(v);
    }

    pub fn get_visibility<'a>(&self) -> DiscoveryInfo_Visibility {
        self.visibility.unwrap_or(DiscoveryInfo_Visibility::FRAMEWORK)
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string environment = 3;

    pub fn clear_environment(&mut self) {
        self.environment.clear();
    }

    pub fn has_environment(&self) -> bool {
        self.environment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: ::std::string::String) {
        self.environment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_environment<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.environment.is_none() {
            self.environment.set_default();
        };
        self.environment.as_mut().unwrap()
    }

    // Take field
    pub fn take_environment(&mut self) -> ::std::string::String {
        self.environment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_environment<'a>(&'a self) -> &'a str {
        match self.environment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string location = 4;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.location.is_none() {
            self.location.set_default();
        };
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_location<'a>(&'a self) -> &'a str {
        match self.location.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string version = 5;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        };
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_version<'a>(&'a self) -> &'a str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.Ports ports = 6;

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    pub fn has_ports(&self) -> bool {
        self.ports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: Ports) {
        self.ports = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ports<'a>(&'a mut self) -> &'a mut Ports {
        if self.ports.is_none() {
            self.ports.set_default();
        };
        self.ports.as_mut().unwrap()
    }

    // Take field
    pub fn take_ports(&mut self) -> Ports {
        self.ports.take().unwrap_or_else(|| Ports::new())
    }

    pub fn get_ports<'a>(&'a self) -> &'a Ports {
        self.ports.as_ref().unwrap_or_else(|| Ports::default_instance())
    }

    // optional .mesos.Labels labels = 7;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }
}

impl ::protobuf::Message for DiscoveryInfo {
    fn is_initialized(&self) -> bool {
        if self.visibility.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.visibility = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.environment.set_default();
                    try!(is.read_string_into(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.location.set_default();
                    try!(is.read_string_into(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.version.set_default();
                    try!(is.read_string_into(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.ports.set_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.labels.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.visibility.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.environment.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.location.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.version.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.ports.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.visibility {
            try!(os.write_enum(1, v as i32));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.environment.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.location.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.version.as_ref() {
            try!(os.write_string(5, &v));
        };
        if let Some(v) = self.ports.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<DiscoveryInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DiscoveryInfo {
    fn new() -> DiscoveryInfo {
        DiscoveryInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<DiscoveryInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "visibility",
                    DiscoveryInfo::has_visibility,
                    DiscoveryInfo::get_visibility,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    DiscoveryInfo::has_name,
                    DiscoveryInfo::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "environment",
                    DiscoveryInfo::has_environment,
                    DiscoveryInfo::get_environment,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "location",
                    DiscoveryInfo::has_location,
                    DiscoveryInfo::get_location,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "version",
                    DiscoveryInfo::has_version,
                    DiscoveryInfo::get_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "ports",
                    DiscoveryInfo::has_ports,
                    DiscoveryInfo::get_ports,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    DiscoveryInfo::has_labels,
                    DiscoveryInfo::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DiscoveryInfo>(
                    "DiscoveryInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DiscoveryInfo {
    fn clear(&mut self) {
        self.clear_visibility();
        self.clear_name();
        self.clear_environment();
        self.clear_location();
        self.clear_version();
        self.clear_ports();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for DiscoveryInfo {
    fn eq(&self, other: &DiscoveryInfo) -> bool {
        self.visibility == other.visibility &&
        self.name == other.name &&
        self.environment == other.environment &&
        self.location == other.location &&
        self.version == other.version &&
        self.ports == other.ports &&
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for DiscoveryInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DiscoveryInfo_Visibility {
    FRAMEWORK = 0,
    CLUSTER = 1,
    EXTERNAL = 2,
}

impl ::protobuf::ProtobufEnum for DiscoveryInfo_Visibility {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DiscoveryInfo_Visibility> {
        match value {
            0 => ::std::option::Option::Some(DiscoveryInfo_Visibility::FRAMEWORK),
            1 => ::std::option::Option::Some(DiscoveryInfo_Visibility::CLUSTER),
            2 => ::std::option::Option::Some(DiscoveryInfo_Visibility::EXTERNAL),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<DiscoveryInfo_Visibility>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DiscoveryInfo_Visibility", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DiscoveryInfo_Visibility {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Status {
    DRIVER_NOT_STARTED = 1,
    DRIVER_RUNNING = 2,
    DRIVER_ABORTED = 3,
    DRIVER_STOPPED = 4,
}

impl ::protobuf::ProtobufEnum for Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            1 => ::std::option::Option::Some(Status::DRIVER_NOT_STARTED),
            2 => ::std::option::Option::Some(Status::DRIVER_RUNNING),
            3 => ::std::option::Option::Some(Status::DRIVER_ABORTED),
            4 => ::std::option::Option::Some(Status::DRIVER_STOPPED),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<Status>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Status", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Status {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskState {
    TASK_STAGING = 6,
    TASK_STARTING = 0,
    TASK_RUNNING = 1,
    TASK_FINISHED = 2,
    TASK_FAILED = 3,
    TASK_KILLED = 4,
    TASK_LOST = 5,
    TASK_ERROR = 7,
}

impl ::protobuf::ProtobufEnum for TaskState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskState> {
        match value {
            6 => ::std::option::Option::Some(TaskState::TASK_STAGING),
            0 => ::std::option::Option::Some(TaskState::TASK_STARTING),
            1 => ::std::option::Option::Some(TaskState::TASK_RUNNING),
            2 => ::std::option::Option::Some(TaskState::TASK_FINISHED),
            3 => ::std::option::Option::Some(TaskState::TASK_FAILED),
            4 => ::std::option::Option::Some(TaskState::TASK_KILLED),
            5 => ::std::option::Option::Some(TaskState::TASK_LOST),
            7 => ::std::option::Option::Some(TaskState::TASK_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<TaskState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskState {
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x0b, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x22, 0x1c, 0x0a, 0x0b, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x49, 0x44, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x09, 0x22, 0x18, 0x0a, 0x07, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x49, 0x44, 0x12, 0x0d, 0x0a,
    0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x18, 0x0a, 0x07,
    0x53, 0x6c, 0x61, 0x76, 0x65, 0x49, 0x44, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x17, 0x0a, 0x06, 0x54, 0x61, 0x73, 0x6b, 0x49, 0x44,
    0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22,
    0x1b, 0x0a, 0x0a, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x12, 0x0d, 0x0a,
    0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x1c, 0x0a, 0x0b,
    0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x44, 0x12, 0x0d, 0x0a, 0x05, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x35, 0x0a, 0x07, 0x41, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d,
    0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x70, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x02, 0x28,
    0x05, 0x22, 0x77, 0x0a, 0x03, 0x55, 0x52, 0x4c, 0x12, 0x0e, 0x0a, 0x06, 0x73, 0x63, 0x68, 0x65,
    0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x1f, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x61, 0x74,
    0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1f, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79,
    0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x50,
    0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x12, 0x10, 0x0a, 0x08, 0x66, 0x72, 0x61, 0x67,
    0x6d, 0x65, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x22, 0xe6, 0x02, 0x0a, 0x0d, 0x46,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0c, 0x0a, 0x04,
    0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61,
    0x6d, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x12, 0x1e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x44, 0x12, 0x1b, 0x0a, 0x10, 0x66, 0x61, 0x69, 0x6c,
    0x6f, 0x76, 0x65, 0x72, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x01, 0x3a, 0x01, 0x30, 0x12, 0x19, 0x0a, 0x0a, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f,
    0x69, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65,
    0x12, 0x0f, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x3a, 0x01,
    0x2a, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x07, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c,
    0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x77, 0x65, 0x62, 0x75, 0x69, 0x5f,
    0x75, 0x72, 0x6c, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x12, 0x35, 0x0a, 0x0c, 0x63, 0x61, 0x70,
    0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x1f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79,
    0x1a, 0x61, 0x0a, 0x0a, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x32,
    0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e,
    0x66, 0x6f, 0x2e, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x2e, 0x54, 0x79,
    0x70, 0x65, 0x22, 0x1f, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x17, 0x0a, 0x13, 0x52, 0x45,
    0x56, 0x4f, 0x43, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x52, 0x45, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45,
    0x53, 0x10, 0x01, 0x22, 0xab, 0x02, 0x0a, 0x0b, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68,
    0x65, 0x63, 0x6b, 0x12, 0x25, 0x0a, 0x04, 0x68, 0x74, 0x74, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68,
    0x43, 0x68, 0x65, 0x63, 0x6b, 0x2e, 0x48, 0x54, 0x54, 0x50, 0x12, 0x19, 0x0a, 0x0d, 0x64, 0x65,
    0x6c, 0x61, 0x79, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x01, 0x3a, 0x02, 0x31, 0x35, 0x12, 0x1c, 0x0a, 0x10, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
    0x6c, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x3a,
    0x02, 0x31, 0x30, 0x12, 0x1b, 0x0a, 0x0f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73,
    0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x3a, 0x02, 0x32, 0x30,
    0x12, 0x1f, 0x0a, 0x14, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x75, 0x74, 0x69, 0x76, 0x65, 0x5f,
    0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x3a, 0x01,
    0x33, 0x12, 0x20, 0x0a, 0x14, 0x67, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x69, 0x6f,
    0x64, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x01, 0x3a,
    0x02, 0x31, 0x30, 0x12, 0x23, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x07,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x1a, 0x37, 0x0a, 0x04, 0x48, 0x54, 0x54, 0x50,
    0x12, 0x0c, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x0f,
    0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x3a, 0x01, 0x2f, 0x12,
    0x10, 0x0a, 0x08, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
    0x0d, 0x22, 0xd7, 0x02, 0x0a, 0x0b, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66,
    0x6f, 0x12, 0x33, 0x0a, 0x09, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
    0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x24, 0x0a, 0x04, 0x75, 0x72, 0x69, 0x73, 0x18, 0x01,
    0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x55, 0x52, 0x49, 0x12, 0x27, 0x0a, 0x0b,
    0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x45, 0x6e, 0x76, 0x69, 0x72, 0x6f,
    0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x13, 0x0a, 0x05, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x18, 0x06,
    0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61,
    0x6c, 0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x61, 0x72, 0x67,
    0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04,
    0x75, 0x73, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x1a, 0x4e, 0x0a, 0x03, 0x55, 0x52,
    0x49, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09,
    0x12, 0x12, 0x0a, 0x0a, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x08, 0x12, 0x15, 0x0a, 0x07, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x12, 0x0d, 0x0a, 0x05, 0x63,
    0x61, 0x63, 0x68, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x1a, 0x2f, 0x0a, 0x0d, 0x43, 0x6f,
    0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0d, 0x0a, 0x05, 0x69,
    0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0f, 0x0a, 0x07, 0x6f, 0x70,
    0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x22, 0xa7, 0x02, 0x0a, 0x0c,
    0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x26, 0x0a, 0x0b,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x49, 0x44, 0x12, 0x28, 0x0a, 0x0c, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x5f, 0x69, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x44, 0x12, 0x23,
    0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x07, 0x20, 0x02, 0x28, 0x0b, 0x32,
    0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49,
    0x6e, 0x66, 0x6f, 0x12, 0x27, 0x0a, 0x09, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
    0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x22, 0x0a, 0x09,
    0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0e,
    0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0c,
    0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x27, 0x0a, 0x09,
    0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72,
    0x79, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x89, 0x01, 0x0a, 0x0a, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72,
    0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09,
    0x12, 0x0a, 0x0a, 0x02, 0x69, 0x70, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x04,
    0x70, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0d, 0x3a, 0x04, 0x35, 0x30, 0x35, 0x30,
    0x12, 0x0b, 0x0a, 0x03, 0x70, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a,
    0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x0f, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x1f, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x22, 0xb2, 0x01, 0x0a, 0x09, 0x53, 0x6c, 0x61, 0x76, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12,
    0x10, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x3a,
    0x04, 0x35, 0x30, 0x35, 0x31, 0x12, 0x22, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x24, 0x0a, 0x0a, 0x61, 0x74, 0x74,
    0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x12,
    0x1a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x53, 0x6c, 0x61, 0x76, 0x65, 0x49, 0x44, 0x12, 0x19, 0x0a, 0x0a, 0x63,
    0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x3a,
    0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x22, 0xfc, 0x02, 0x0a, 0x05, 0x56, 0x61, 0x6c, 0x75, 0x65,
    0x12, 0x1f, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x11,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x54, 0x79, 0x70,
    0x65, 0x12, 0x23, 0x0a, 0x06, 0x73, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e,
    0x53, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x12, 0x23, 0x0a, 0x06, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x56,
    0x61, 0x6c, 0x75, 0x65, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x1d, 0x0a, 0x03, 0x73,
    0x65, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x53, 0x65, 0x74, 0x12, 0x1f, 0x0a, 0x04, 0x74, 0x65,
    0x78, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x1a, 0x17, 0x0a, 0x06, 0x53,
    0x63, 0x61, 0x6c, 0x61, 0x72, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x01, 0x1a, 0x23, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x0d, 0x0a,
    0x05, 0x62, 0x65, 0x67, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x02, 0x28, 0x04, 0x12, 0x0b, 0x0a, 0x03,
    0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x1a, 0x2b, 0x0a, 0x06, 0x52, 0x61, 0x6e,
    0x67, 0x65, 0x73, 0x12, 0x21, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x01, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65,
    0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x1a, 0x13, 0x0a, 0x03, 0x53, 0x65, 0x74, 0x12, 0x0c, 0x0a,
    0x04, 0x69, 0x74, 0x65, 0x6d, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x1a, 0x15, 0x0a, 0x04, 0x54,
    0x65, 0x78, 0x74, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x09, 0x22, 0x31, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x43,
    0x41, 0x4c, 0x41, 0x52, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x52, 0x41, 0x4e, 0x47, 0x45, 0x53,
    0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x53, 0x45, 0x54, 0x10, 0x02, 0x12, 0x08, 0x0a, 0x04, 0x54,
    0x45, 0x58, 0x54, 0x10, 0x03, 0x22, 0xc4, 0x01, 0x0a, 0x09, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62,
    0x75, 0x74, 0x65, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x1f, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0e, 0x32,
    0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x54, 0x79,
    0x70, 0x65, 0x12, 0x23, 0x0a, 0x06, 0x73, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65,
    0x2e, 0x53, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x12, 0x23, 0x0a, 0x06, 0x72, 0x61, 0x6e, 0x67, 0x65,
    0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x1d, 0x0a, 0x03,
    0x73, 0x65, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x53, 0x65, 0x74, 0x12, 0x1f, 0x0a, 0x04, 0x74,
    0x65, 0x78, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x22, 0xfb, 0x03, 0x0a,
    0x08, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
    0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x1f, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18,
    0x02, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x56, 0x61,
    0x6c, 0x75, 0x65, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x23, 0x0a, 0x06, 0x73, 0x63, 0x61, 0x6c,
    0x61, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x53, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x12, 0x23, 0x0a,
    0x06, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x52, 0x61, 0x6e, 0x67,
    0x65, 0x73, 0x12, 0x1d, 0x0a, 0x03, 0x73, 0x65, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x53, 0x65,
    0x74, 0x12, 0x0f, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x3a,
    0x01, 0x2a, 0x12, 0x34, 0x0a, 0x0b, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x26, 0x0a, 0x04, 0x64, 0x69, 0x73, 0x6b,
    0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x44, 0x69, 0x73, 0x6b, 0x49, 0x6e, 0x66, 0x6f,
    0x12, 0x30, 0x0a, 0x09, 0x72, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x09, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x2e, 0x52, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x49, 0x6e,
    0x66, 0x6f, 0x1a, 0x24, 0x0a, 0x0f, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70,
    0x61, 0x6c, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x1a, 0x7f, 0x0a, 0x08, 0x44, 0x69, 0x73, 0x6b,
    0x49, 0x6e, 0x66, 0x6f, 0x12, 0x39, 0x0a, 0x0b, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65,
    0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x44, 0x69, 0x73, 0x6b, 0x49,
    0x6e, 0x66, 0x6f, 0x2e, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x12,
    0x1d, 0x0a, 0x06, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x0d, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x1a, 0x19,
    0x0a, 0x0b, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x0a, 0x0a,
    0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x1a, 0x0f, 0x0a, 0x0d, 0x52, 0x65, 0x76,
    0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0xbc, 0x01, 0x0a, 0x18, 0x54,
    0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x74, 0x61,
    0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x09, 0x12, 0x0f, 0x0a, 0x07, 0x62, 0x61, 0x63, 0x6b, 0x6c, 0x6f, 0x67, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x0d, 0x0a, 0x05, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x0d, 0x0a, 0x05, 0x64, 0x72, 0x6f, 0x70, 0x73, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x12, 0x0f, 0x0a, 0x07, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,
    0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x12, 0x0c, 0x0a, 0x04, 0x71, 0x6c, 0x65, 0x6e, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x04, 0x12, 0x0f, 0x0a, 0x07, 0x72, 0x61, 0x74, 0x65, 0x62, 0x70, 0x73,
    0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x12, 0x0f, 0x0a, 0x07, 0x72, 0x61, 0x74, 0x65, 0x70, 0x70,
    0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x12, 0x10, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x65,
    0x75, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x22, 0x97, 0x09, 0x0a, 0x12, 0x52, 0x65,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73,
    0x12, 0x11, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x01, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73,
    0x18, 0x1e, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64,
    0x73, 0x18, 0x1f, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1b, 0x0a, 0x13, 0x63, 0x70, 0x75, 0x73, 0x5f,
    0x75, 0x73, 0x65, 0x72, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x01, 0x12, 0x1d, 0x0a, 0x15, 0x63, 0x70, 0x75, 0x73, 0x5f, 0x73, 0x79, 0x73,
    0x74, 0x65, 0x6d, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x01, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x70, 0x75, 0x73, 0x5f, 0x6c, 0x69, 0x6d, 0x69,
    0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x12, 0x17, 0x0a, 0x0f, 0x63, 0x70, 0x75, 0x73, 0x5f,
    0x6e, 0x72, 0x5f, 0x70, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x19, 0x0a, 0x11, 0x63, 0x70, 0x75, 0x73, 0x5f, 0x6e, 0x72, 0x5f, 0x74, 0x68, 0x72, 0x6f,
    0x74, 0x74, 0x6c, 0x65, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x20, 0x0a, 0x18, 0x63,
    0x70, 0x75, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x5f, 0x74, 0x69,
    0x6d, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x01, 0x12, 0x17, 0x0a,
    0x0f, 0x6d, 0x65, 0x6d, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73,
    0x18, 0x24, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1d, 0x0a, 0x15, 0x6d, 0x65, 0x6d, 0x5f, 0x74, 0x6f,
    0x74, 0x61, 0x6c, 0x5f, 0x6d, 0x65, 0x6d, 0x73, 0x77, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18,
    0x25, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x6d, 0x65, 0x6d, 0x5f, 0x6c, 0x69, 0x6d,
    0x69, 0x74, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1c,
    0x0a, 0x14, 0x6d, 0x65, 0x6d, 0x5f, 0x73, 0x6f, 0x66, 0x74, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74,
    0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x26, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e,
    0x6d, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x0a,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e, 0x6d, 0x65, 0x6d, 0x5f, 0x61, 0x6e, 0x6f, 0x6e,
    0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f,
    0x6d, 0x65, 0x6d, 0x5f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18,
    0x27, 0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x6d, 0x65, 0x6d, 0x5f, 0x72, 0x73, 0x73,
    0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1d, 0x0a, 0x15,
    0x6d, 0x65, 0x6d, 0x5f, 0x6d, 0x61, 0x70, 0x70, 0x65, 0x64, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f,
    0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e, 0x6d,
    0x65, 0x6d, 0x5f, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x28, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x20, 0x0a, 0x18, 0x6d, 0x65, 0x6d, 0x5f, 0x6c, 0x6f, 0x77, 0x5f, 0x70,
    0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x18,
    0x20, 0x20, 0x01, 0x28, 0x04, 0x12, 0x23, 0x0a, 0x1b, 0x6d, 0x65, 0x6d, 0x5f, 0x6d, 0x65, 0x64,
    0x69, 0x75, 0x6d, 0x5f, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x5f, 0x63, 0x6f, 0x75,
    0x6e, 0x74, 0x65, 0x72, 0x18, 0x21, 0x20, 0x01, 0x28, 0x04, 0x12, 0x25, 0x0a, 0x1d, 0x6d, 0x65,
    0x6d, 0x5f, 0x63, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x65, 0x73, 0x73,
    0x75, 0x72, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x18, 0x22, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x18, 0x0a, 0x10, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f,
    0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x64,
    0x69, 0x73, 0x6b, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x1b,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x23, 0x0a, 0x04, 0x70, 0x65, 0x72, 0x66, 0x18, 0x0d, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x50, 0x65, 0x72, 0x66, 0x53,
    0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x16, 0x0a, 0x0e, 0x6e, 0x65, 0x74,
    0x5f, 0x72, 0x78, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x0e, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x14, 0x0a, 0x0c, 0x6e, 0x65, 0x74, 0x5f, 0x72, 0x78, 0x5f, 0x62, 0x79, 0x74, 0x65,
    0x73, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x6e, 0x65, 0x74, 0x5f, 0x72,
    0x78, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x10, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16,
    0x0a, 0x0e, 0x6e, 0x65, 0x74, 0x5f, 0x72, 0x78, 0x5f, 0x64, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64,
    0x18, 0x11, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x78,
    0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x12, 0x20, 0x01, 0x28, 0x04, 0x12, 0x14,
    0x0a, 0x0c, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x78, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x13,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x78, 0x5f, 0x65,
    0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x14, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e, 0x6e,
    0x65, 0x74, 0x5f, 0x74, 0x78, 0x5f, 0x64, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x18, 0x15, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x21, 0x0a, 0x19, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x63, 0x70, 0x5f, 0x72,
    0x74, 0x74, 0x5f, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x65, 0x63, 0x73, 0x5f, 0x70, 0x35, 0x30,
    0x18, 0x16, 0x20, 0x01, 0x28, 0x01, 0x12, 0x21, 0x0a, 0x19, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x63,
    0x70, 0x5f, 0x72, 0x74, 0x74, 0x5f, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x65, 0x63, 0x73, 0x5f,
    0x70, 0x39, 0x30, 0x18, 0x17, 0x20, 0x01, 0x28, 0x01, 0x12, 0x21, 0x0a, 0x19, 0x6e, 0x65, 0x74,
    0x5f, 0x74, 0x63, 0x70, 0x5f, 0x72, 0x74, 0x74, 0x5f, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x65,
    0x63, 0x73, 0x5f, 0x70, 0x39, 0x35, 0x18, 0x18, 0x20, 0x01, 0x28, 0x01, 0x12, 0x21, 0x0a, 0x19,
    0x6e, 0x65, 0x74, 0x5f, 0x74, 0x63, 0x70, 0x5f, 0x72, 0x74, 0x74, 0x5f, 0x6d, 0x69, 0x63, 0x72,
    0x6f, 0x73, 0x65, 0x63, 0x73, 0x5f, 0x70, 0x39, 0x39, 0x18, 0x19, 0x20, 0x01, 0x28, 0x01, 0x12,
    0x22, 0x0a, 0x1a, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x63, 0x70, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x76,
    0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x1c, 0x20,
    0x01, 0x28, 0x01, 0x12, 0x25, 0x0a, 0x1d, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x63, 0x70, 0x5f, 0x74,
    0x69, 0x6d, 0x65, 0x5f, 0x77, 0x61, 0x69, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x73, 0x18, 0x1d, 0x20, 0x01, 0x28, 0x01, 0x12, 0x47, 0x0a, 0x1e, 0x6e, 0x65,
    0x74, 0x5f, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
    0x6c, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x18, 0x23, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x54, 0x72, 0x61, 0x66, 0x66,
    0x69, 0x63, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74,
    0x69, 0x63, 0x73, 0x22, 0xed, 0x01, 0x0a, 0x0d, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x55, 0x73, 0x61, 0x67, 0x65, 0x12, 0x30, 0x0a, 0x09, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f,
    0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x45,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x12, 0x1e, 0x0a, 0x05, 0x74, 0x6f, 0x74, 0x61, 0x6c,
    0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x1a, 0x89, 0x01, 0x0a, 0x08, 0x45, 0x78, 0x65, 0x63,
    0x75, 0x74, 0x6f, 0x72, 0x12, 0x2a, 0x0a, 0x0d, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72,
    0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f,
    0x12, 0x22, 0x0a, 0x09, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64, 0x18, 0x02, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x12, 0x2d, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69,
    0x63, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74,
    0x69, 0x63, 0x73, 0x22, 0xb0, 0x0a, 0x0a, 0x0e, 0x50, 0x65, 0x72, 0x66, 0x53, 0x74, 0x61, 0x74,
    0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x11, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
    0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x02, 0x28, 0x01, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x75, 0x72,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x02, 0x28, 0x01, 0x12, 0x0e, 0x0a, 0x06, 0x63,
    0x79, 0x63, 0x6c, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1f, 0x0a, 0x17, 0x73,
    0x74, 0x61, 0x6c, 0x6c, 0x65, 0x64, 0x5f, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x5f, 0x66, 0x72,
    0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1e, 0x0a, 0x16,
    0x73, 0x74, 0x61, 0x6c, 0x6c, 0x65, 0x64, 0x5f, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x5f, 0x62,
    0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x12, 0x14, 0x0a, 0x0c,
    0x69, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x06, 0x20, 0x01,
    0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x72, 0x65, 0x66, 0x65,
    0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x12, 0x14, 0x0a, 0x0c,
    0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x08, 0x20, 0x01,
    0x28, 0x04, 0x12, 0x10, 0x0a, 0x08, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x65, 0x73, 0x18, 0x09,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x5f, 0x6d,
    0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x62,
    0x75, 0x73, 0x5f, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x12, 0x0a, 0x0a, 0x72, 0x65, 0x66, 0x5f, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x18, 0x0c, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x70, 0x75, 0x5f, 0x63, 0x6c, 0x6f, 0x63, 0x6b,
    0x18, 0x0d, 0x20, 0x01, 0x28, 0x01, 0x12, 0x12, 0x0a, 0x0a, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x63,
    0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x01, 0x12, 0x13, 0x0a, 0x0b, 0x70, 0x61,
    0x67, 0x65, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x14, 0x0a, 0x0c, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x18,
    0x10, 0x20, 0x01, 0x28, 0x04, 0x12, 0x14, 0x0a, 0x0c, 0x6d, 0x61, 0x6a, 0x6f, 0x72, 0x5f, 0x66,
    0x61, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x11, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x63,
    0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x5f, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18,
    0x12, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e, 0x63, 0x70, 0x75, 0x5f, 0x6d, 0x69, 0x67,
    0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x13, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a,
    0x10, 0x61, 0x6c, 0x69, 0x67, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74,
    0x73, 0x18, 0x14, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x65, 0x6d, 0x75, 0x6c, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x15, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x17, 0x0a, 0x0f, 0x6c, 0x31, 0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x6c,
    0x6f, 0x61, 0x64, 0x73, 0x18, 0x16, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1d, 0x0a, 0x15, 0x6c, 0x31,
    0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73,
    0x73, 0x65, 0x73, 0x18, 0x17, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x6c, 0x31, 0x5f,
    0x64, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x73, 0x18, 0x18, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x1e, 0x0a, 0x16, 0x6c, 0x31, 0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65,
    0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x19, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x1c, 0x0a, 0x14, 0x6c, 0x31, 0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65,
    0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x1a, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x21, 0x0a, 0x19, 0x6c, 0x31, 0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x70,
    0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x1b,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x6c, 0x31, 0x5f, 0x69, 0x63, 0x61, 0x63, 0x68,
    0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18, 0x1c, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1d, 0x0a,
    0x15, 0x6c, 0x31, 0x5f, 0x69, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f,
    0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x1d, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1c, 0x0a, 0x14,
    0x6c, 0x31, 0x5f, 0x69, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74,
    0x63, 0x68, 0x65, 0x73, 0x18, 0x1e, 0x20, 0x01, 0x28, 0x04, 0x12, 0x21, 0x0a, 0x19, 0x6c, 0x31,
    0x5f, 0x69, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68,
    0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x1f, 0x20, 0x01, 0x28, 0x04, 0x12, 0x11, 0x0a,
    0x09, 0x6c, 0x6c, 0x63, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18, 0x20, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x17, 0x0a, 0x0f, 0x6c, 0x6c, 0x63, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73,
    0x73, 0x65, 0x73, 0x18, 0x21, 0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x6c, 0x6c, 0x63,
    0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x73, 0x18, 0x22, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a,
    0x10, 0x6c, 0x6c, 0x63, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65,
    0x73, 0x18, 0x23, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e, 0x6c, 0x6c, 0x63, 0x5f, 0x70,
    0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x24, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x1b, 0x0a, 0x13, 0x6c, 0x6c, 0x63, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x5f,
    0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x25, 0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a,
    0x64, 0x74, 0x6c, 0x62, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18, 0x26, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x18, 0x0a, 0x10, 0x64, 0x74, 0x6c, 0x62, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69,
    0x73, 0x73, 0x65, 0x73, 0x18, 0x27, 0x20, 0x01, 0x28, 0x04, 0x12, 0x13, 0x0a, 0x0b, 0x64, 0x74,
    0x6c, 0x62, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x73, 0x18, 0x28, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x19, 0x0a, 0x11, 0x64, 0x74, 0x6c, 0x62, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x6d, 0x69,
    0x73, 0x73, 0x65, 0x73, 0x18, 0x29, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x64, 0x74,
    0x6c, 0x62, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x2a, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x1c, 0x0a, 0x14, 0x64, 0x74, 0x6c, 0x62, 0x5f, 0x70, 0x72, 0x65, 0x66,
    0x65, 0x74, 0x63, 0x68, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x2b, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x12, 0x0a, 0x0a, 0x69, 0x74, 0x6c, 0x62, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18,
    0x2c, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x69, 0x74, 0x6c, 0x62, 0x5f, 0x6c, 0x6f,
    0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x2d, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x14, 0x0a, 0x0c, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18,
    0x2e, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1a, 0x0a, 0x12, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x5f,
    0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x2f, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x12, 0x0a, 0x0a, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18,
    0x30, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6c, 0x6f,
    0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x31, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x13, 0x0a, 0x0b, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x73, 0x18, 0x32,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x19, 0x0a, 0x11, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x73, 0x74, 0x6f,
    0x72, 0x65, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x33, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x17, 0x0a, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68,
    0x65, 0x73, 0x18, 0x34, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1c, 0x0a, 0x14, 0x6e, 0x6f, 0x64, 0x65,
    0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73,
    0x18, 0x35, 0x20, 0x01, 0x28, 0x04, 0x22, 0x4f, 0x0a, 0x07, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x12, 0x20, 0x0a, 0x08, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x53, 0x6c, 0x61, 0x76,
    0x65, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73,
    0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x22, 0xec, 0x06, 0x0a, 0x05, 0x4f, 0x66, 0x66, 0x65,
    0x72, 0x12, 0x1a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x0e, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x49, 0x44, 0x12, 0x28, 0x0a,
    0x0c, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20,
    0x02, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x46, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x44, 0x12, 0x20, 0x0a, 0x08, 0x73, 0x6c, 0x61, 0x76, 0x65,
    0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x53, 0x6c, 0x61, 0x76, 0x65, 0x49, 0x44, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x6f, 0x73,
    0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x02, 0x28, 0x09, 0x12, 0x17, 0x0a, 0x03, 0x75,
    0x72, 0x6c, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x55, 0x52, 0x4c, 0x12, 0x22, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x24, 0x0a, 0x0a, 0x61, 0x74, 0x74, 0x72,
    0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x12, 0x27,
    0x0a, 0x0c, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x06,
    0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x45, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x1a, 0xdc, 0x04, 0x0a, 0x09, 0x4f, 0x70, 0x65, 0x72,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x29, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4f, 0x66, 0x66, 0x65,
    0x72, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x54, 0x79, 0x70, 0x65,
    0x12, 0x2d, 0x0a, 0x06, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x1d, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x4f,
    0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x12,
    0x2f, 0x0a, 0x07, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x4f,
    0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x12, 0x33, 0x0a, 0x09, 0x75, 0x6e, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4f, 0x66, 0x66, 0x65,
    0x72, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x55, 0x6e, 0x72, 0x65,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x12, 0x2d, 0x0a, 0x06, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4f, 0x66,
    0x66, 0x65, 0x72, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x43, 0x72,
    0x65, 0x61, 0x74, 0x65, 0x12, 0x2f, 0x0a, 0x07, 0x64, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x18,
    0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4f, 0x66,
    0x66, 0x65, 0x72, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x44, 0x65,
    0x73, 0x74, 0x72, 0x6f, 0x79, 0x1a, 0x2d, 0x0a, 0x06, 0x4c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x12,
    0x23, 0x0a, 0x0a, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x73, 0x18, 0x01, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x54, 0x61, 0x73, 0x6b,
    0x49, 0x6e, 0x66, 0x6f, 0x1a, 0x2d, 0x0a, 0x07, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x12,
    0x22, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x1a, 0x2f, 0x0a, 0x09, 0x55, 0x6e, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x12, 0x22, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x1a, 0x2a, 0x0a, 0x06, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x12, 0x20,
    0x0a, 0x07, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x1a, 0x2b, 0x0a, 0x07, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x12, 0x20, 0x0a, 0x07, 0x76,
    0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x22, 0x47, 0x0a,
    0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0a, 0x0a, 0x06, 0x4c, 0x41, 0x55, 0x4e, 0x43, 0x48, 0x10,
    0x01, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x45, 0x53, 0x45, 0x52, 0x56, 0x45, 0x10, 0x02, 0x12, 0x0d,
    0x0a, 0x09, 0x55, 0x4e, 0x52, 0x45, 0x53, 0x45, 0x52, 0x56, 0x45, 0x10, 0x03, 0x12, 0x0a, 0x0a,
    0x06, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x10, 0x04, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x45, 0x53,
    0x54, 0x52, 0x4f, 0x59, 0x10, 0x05, 0x22, 0xf3, 0x02, 0x0a, 0x08, 0x54, 0x61, 0x73, 0x6b, 0x49,
    0x6e, 0x66, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x1e, 0x0a, 0x07, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x02,
    0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x49,
    0x44, 0x12, 0x20, 0x0a, 0x08, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20,
    0x02, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x53, 0x6c, 0x61, 0x76,
    0x65, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73,
    0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x25, 0x0a, 0x08, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x23,
    0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49,
    0x6e, 0x66, 0x6f, 0x12, 0x27, 0x0a, 0x09, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
    0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0c, 0x0a, 0x04,
    0x64, 0x61, 0x74, 0x61, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x28, 0x0a, 0x0c, 0x68, 0x65,
    0x61, 0x6c, 0x74, 0x68, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43,
    0x68, 0x65, 0x63, 0x6b, 0x12, 0x1d, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x0a,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4c, 0x61, 0x62,
    0x65, 0x6c, 0x73, 0x12, 0x27, 0x0a, 0x09, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79,
    0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x44,
    0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0xce, 0x07, 0x0a,
    0x0a, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1e, 0x0a, 0x07, 0x74,
    0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x49, 0x44, 0x12, 0x1f, 0x0a, 0x05, 0x73,
    0x74, 0x61, 0x74, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x0f, 0x0a, 0x07,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12, 0x28, 0x0a,
    0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
    0x2e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x28, 0x0a, 0x06, 0x72, 0x65, 0x61, 0x73, 0x6f,
    0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e, 0x52, 0x65, 0x61, 0x73, 0x6f,
    0x6e, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x12,
    0x20, 0x0a, 0x08, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x53, 0x6c, 0x61, 0x76, 0x65, 0x49,
    0x44, 0x12, 0x26, 0x0a, 0x0b, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64,
    0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x45,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x12, 0x11, 0x0a, 0x09, 0x74, 0x69, 0x6d,
    0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x06, 0x20, 0x01, 0x28, 0x01, 0x12, 0x0c, 0x0a, 0x04,
    0x75, 0x75, 0x69, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0f, 0x0a, 0x07, 0x68, 0x65,
    0x61, 0x6c, 0x74, 0x68, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x12, 0x1d, 0x0a, 0x06, 0x6c,
    0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x22, 0x42, 0x0a, 0x06, 0x53, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x12, 0x11, 0x0a, 0x0d, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x4d,
    0x41, 0x53, 0x54, 0x45, 0x52, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c, 0x53, 0x4f, 0x55, 0x52, 0x43,
    0x45, 0x5f, 0x53, 0x4c, 0x41, 0x56, 0x45, 0x10, 0x01, 0x12, 0x13, 0x0a, 0x0f, 0x53, 0x4f, 0x55,
    0x52, 0x43, 0x45, 0x5f, 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x4f, 0x52, 0x10, 0x02, 0x22, 0xac,
    0x04, 0x0a, 0x06, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x12, 0x22, 0x0a, 0x1e, 0x52, 0x45, 0x41,
    0x53, 0x4f, 0x4e, 0x5f, 0x43, 0x4f, 0x4d, 0x4d, 0x41, 0x4e, 0x44, 0x5f, 0x45, 0x58, 0x45, 0x43,
    0x55, 0x54, 0x4f, 0x52, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1d, 0x0a,
    0x19, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x4f, 0x52,
    0x5f, 0x50, 0x52, 0x45, 0x45, 0x4d, 0x50, 0x54, 0x45, 0x44, 0x10, 0x11, 0x12, 0x1e, 0x0a, 0x1a,
    0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x4f, 0x52, 0x5f,
    0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x20, 0x0a, 0x1c,
    0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x4f, 0x52, 0x5f,
    0x55, 0x4e, 0x52, 0x45, 0x47, 0x49, 0x53, 0x54, 0x45, 0x52, 0x45, 0x44, 0x10, 0x02, 0x12, 0x1c,
    0x0a, 0x18, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x46, 0x52, 0x41, 0x4d, 0x45, 0x57, 0x4f,
    0x52, 0x4b, 0x5f, 0x52, 0x45, 0x4d, 0x4f, 0x56, 0x45, 0x44, 0x10, 0x03, 0x12, 0x13, 0x0a, 0x0f,
    0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x47, 0x43, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10,
    0x04, 0x12, 0x1e, 0x0a, 0x1a, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x49, 0x4e, 0x56, 0x41,
    0x4c, 0x49, 0x44, 0x5f, 0x46, 0x52, 0x41, 0x4d, 0x45, 0x57, 0x4f, 0x52, 0x4b, 0x49, 0x44, 0x10,
    0x05, 0x12, 0x19, 0x0a, 0x15, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x49, 0x4e, 0x56, 0x41,
    0x4c, 0x49, 0x44, 0x5f, 0x4f, 0x46, 0x46, 0x45, 0x52, 0x53, 0x10, 0x06, 0x12, 0x1e, 0x0a, 0x1a,
    0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x4d, 0x41, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x44, 0x49,
    0x53, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x45, 0x44, 0x10, 0x07, 0x12, 0x17, 0x0a, 0x13,
    0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x4d, 0x45, 0x4d, 0x4f, 0x52, 0x59, 0x5f, 0x4c, 0x49,
    0x4d, 0x49, 0x54, 0x10, 0x08, 0x12, 0x19, 0x0a, 0x15, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f,
    0x52, 0x45, 0x43, 0x4f, 0x4e, 0x43, 0x49, 0x4c, 0x49, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x09,
    0x12, 0x1c, 0x0a, 0x18, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x52, 0x45, 0x53, 0x4f, 0x55,
    0x52, 0x43, 0x45, 0x53, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x12, 0x12, 0x1d,
    0x0a, 0x19, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x53, 0x4c, 0x41, 0x56, 0x45, 0x5f, 0x44,
    0x49, 0x53, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x45, 0x44, 0x10, 0x0a, 0x12, 0x18, 0x0a,
    0x14, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x53, 0x4c, 0x41, 0x56, 0x45, 0x5f, 0x52, 0x45,
    0x4d, 0x4f, 0x56, 0x45, 0x44, 0x10, 0x0b, 0x12, 0x1a, 0x0a, 0x16, 0x52, 0x45, 0x41, 0x53, 0x4f,
    0x4e, 0x5f, 0x53, 0x4c, 0x41, 0x56, 0x45, 0x5f, 0x52, 0x45, 0x53, 0x54, 0x41, 0x52, 0x54, 0x45,
    0x44, 0x10, 0x0c, 0x12, 0x18, 0x0a, 0x14, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x53, 0x4c,
    0x41, 0x56, 0x45, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x0d, 0x12, 0x17, 0x0a,
    0x13, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x49, 0x4e, 0x56,
    0x41, 0x4c, 0x49, 0x44, 0x10, 0x0e, 0x12, 0x1c, 0x0a, 0x18, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e,
    0x5f, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x55, 0x4e, 0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x5a,
    0x45, 0x44, 0x10, 0x0f, 0x12, 0x17, 0x0a, 0x13, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x54,
    0x41, 0x53, 0x4b, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x10, 0x22, 0x24, 0x0a,
    0x07, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x12, 0x19, 0x0a, 0x0e, 0x72, 0x65, 0x66, 0x75,
    0x73, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01,
    0x3a, 0x01, 0x35, 0x22, 0x66, 0x0a, 0x0b, 0x45, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65,
    0x6e, 0x74, 0x12, 0x2e, 0x0a, 0x09, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x18,
    0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x45, 0x6e,
    0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62,
    0x6c, 0x65, 0x1a, 0x27, 0x0a, 0x08, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x0c,
    0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x22, 0x27, 0x0a, 0x09, 0x50,
    0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x12, 0x0b, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
    0x20, 0x02, 0x28, 0x09, 0x22, 0x31, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
    0x72, 0x73, 0x12, 0x23, 0x0a, 0x09, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x18,
    0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x50, 0x61,
    0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x22, 0x2f, 0x0a, 0x0a, 0x43, 0x72, 0x65, 0x64, 0x65,
    0x6e, 0x74, 0x69, 0x61, 0x6c, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70,
    0x61, 0x6c, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x73, 0x65, 0x63, 0x72,
    0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x35, 0x0a, 0x0b, 0x43, 0x72, 0x65, 0x64,
    0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x12, 0x26, 0x0a, 0x0b, 0x63, 0x72, 0x65, 0x64, 0x65,
    0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x22,
    0x8f, 0x03, 0x0a, 0x03, 0x41, 0x43, 0x4c, 0x1a, 0x69, 0x0a, 0x06, 0x45, 0x6e, 0x74, 0x69, 0x74,
    0x79, 0x12, 0x2a, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
    0x16, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x45, 0x6e, 0x74, 0x69,
    0x74, 0x79, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x04, 0x53, 0x4f, 0x4d, 0x45, 0x12, 0x0e, 0x0a,
    0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x22, 0x23, 0x0a,
    0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x53, 0x4f, 0x4d, 0x45, 0x10, 0x00, 0x12,
    0x07, 0x0a, 0x03, 0x41, 0x4e, 0x59, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45,
    0x10, 0x02, 0x1a, 0x5c, 0x0a, 0x11, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x46, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x25, 0x0a, 0x0a, 0x70, 0x72, 0x69, 0x6e, 0x63,
    0x69, 0x70, 0x61, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x20,
    0x0a, 0x05, 0x72, 0x6f, 0x6c, 0x65, 0x73, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x11, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79,
    0x1a, 0x52, 0x0a, 0x07, 0x52, 0x75, 0x6e, 0x54, 0x61, 0x73, 0x6b, 0x12, 0x25, 0x0a, 0x0a, 0x70,
    0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32,
    0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x45, 0x6e, 0x74, 0x69,
    0x74, 0x79, 0x12, 0x20, 0x0a, 0x05, 0x75, 0x73, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x02, 0x28,
    0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x45, 0x6e,
    0x74, 0x69, 0x74, 0x79, 0x1a, 0x6b, 0x0a, 0x11, 0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e,
    0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x25, 0x0a, 0x0a, 0x70, 0x72, 0x69,
    0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x11, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79,
    0x12, 0x2f, 0x0a, 0x14, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x70, 0x72,
    0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x11,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74,
    0x79, 0x22, 0xbd, 0x01, 0x0a, 0x04, 0x41, 0x43, 0x4c, 0x73, 0x12, 0x18, 0x0a, 0x0a, 0x70, 0x65,
    0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x76, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x04,
    0x74, 0x72, 0x75, 0x65, 0x12, 0x39, 0x0a, 0x13, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,
    0x5f, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x52, 0x65,
    0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x12,
    0x25, 0x0a, 0x09, 0x72, 0x75, 0x6e, 0x5f, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x18, 0x03, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x52,
    0x75, 0x6e, 0x54, 0x61, 0x73, 0x6b, 0x12, 0x39, 0x0a, 0x13, 0x73, 0x68, 0x75, 0x74, 0x64, 0x6f,
    0x77, 0x6e, 0x5f, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x18, 0x04, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x41, 0x43, 0x4c, 0x2e,
    0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x22, 0x3d, 0x0a, 0x09, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x0b,
    0x0a, 0x03, 0x71, 0x70, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x12, 0x11, 0x0a, 0x09, 0x70,
    0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x12, 0x10,
    0x0a, 0x08, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04,
    0x22, 0x71, 0x0a, 0x0a, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x12, 0x20,
    0x0a, 0x06, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74,
    0x12, 0x1d, 0x0a, 0x15, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x5f, 0x64, 0x65,
    0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x71, 0x70, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x12,
    0x22, 0x0a, 0x1a, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x5f, 0x64, 0x65, 0x66,
    0x61, 0x75, 0x6c, 0x74, 0x5f, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x04, 0x22, 0x9c, 0x01, 0x0a, 0x05, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x1f, 0x0a,
    0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x11, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1f,
    0x0a, 0x04, 0x61, 0x70, 0x70, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x41, 0x70, 0x70, 0x43, 0x1a,
    0x3f, 0x0a, 0x04, 0x41, 0x70, 0x70, 0x43, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x1d, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x0d, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73,
    0x22, 0x10, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x41, 0x50, 0x50, 0x43,
    0x10, 0x01, 0x22, 0x8a, 0x01, 0x0a, 0x06, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x12, 0x20, 0x0a,
    0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x12,
    0x16, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x70, 0x61, 0x74,
    0x68, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x68, 0x6f, 0x73, 0x74, 0x5f,
    0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1b, 0x0a, 0x05, 0x69, 0x6d,
    0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x16, 0x0a, 0x04, 0x4d, 0x6f, 0x64, 0x65, 0x12,
    0x06, 0x0a, 0x02, 0x52, 0x57, 0x10, 0x01, 0x12, 0x06, 0x0a, 0x02, 0x52, 0x4f, 0x10, 0x02, 0x22,
    0x87, 0x05, 0x0a, 0x0d, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66,
    0x6f, 0x12, 0x27, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32,
    0x19, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
    0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1e, 0x0a, 0x07, 0x76, 0x6f,
    0x6c, 0x75, 0x6d, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x6f,
    0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12, 0x2f, 0x0a, 0x06,
    0x64, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e,
    0x66, 0x6f, 0x2e, 0x44, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x2d, 0x0a,
    0x05, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e,
    0x66, 0x6f, 0x2e, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x1a, 0xf1, 0x02, 0x0a,
    0x0a, 0x44, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0d, 0x0a, 0x05, 0x69,
    0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x3e, 0x0a, 0x07, 0x6e, 0x65,
    0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x27, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66,
    0x6f, 0x2e, 0x44, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x4e, 0x65, 0x74,
    0x77, 0x6f, 0x72, 0x6b, 0x3a, 0x04, 0x48, 0x4f, 0x53, 0x54, 0x12, 0x42, 0x0a, 0x0d, 0x70, 0x6f,
    0x72, 0x74, 0x5f, 0x6d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x2b, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69,
    0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x44, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x6e,
    0x66, 0x6f, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x12, 0x19,
    0x0a, 0x0a, 0x70, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x12, 0x24, 0x0a, 0x0a, 0x70, 0x61, 0x72,
    0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x12,
    0x18, 0x0a, 0x10, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x5f, 0x70, 0x75, 0x6c, 0x6c, 0x5f, 0x69, 0x6d,
    0x61, 0x67, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x1a, 0x4a, 0x0a, 0x0b, 0x50, 0x6f, 0x72,
    0x74, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x12, 0x11, 0x0a, 0x09, 0x68, 0x6f, 0x73, 0x74,
    0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x63,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20,
    0x02, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x09, 0x22, 0x29, 0x0a, 0x07, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
    0x12, 0x08, 0x0a, 0x04, 0x48, 0x4f, 0x53, 0x54, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x42, 0x52,
    0x49, 0x44, 0x47, 0x45, 0x10, 0x02, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x03,
    0x1a, 0x28, 0x0a, 0x09, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1b, 0x0a,
    0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x1d, 0x0a, 0x04, 0x54, 0x79,
    0x70, 0x65, 0x12, 0x0a, 0x0a, 0x06, 0x44, 0x4f, 0x43, 0x4b, 0x45, 0x52, 0x10, 0x01, 0x12, 0x09,
    0x0a, 0x05, 0x4d, 0x45, 0x53, 0x4f, 0x53, 0x10, 0x02, 0x22, 0x26, 0x0a, 0x06, 0x4c, 0x61, 0x62,
    0x65, 0x6c, 0x73, 0x12, 0x1c, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x01, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4c, 0x61, 0x62, 0x65,
    0x6c, 0x22, 0x23, 0x0a, 0x05, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x12, 0x0b, 0x0a, 0x03, 0x6b, 0x65,
    0x79, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0x36, 0x0a, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x0e,
    0x0a, 0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x0c,
    0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08,
    0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x22, 0x23,
    0x0a, 0x05, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x1a, 0x0a, 0x05, 0x70, 0x6f, 0x72, 0x74, 0x73,
    0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x50,
    0x6f, 0x72, 0x74, 0x22, 0xfe, 0x01, 0x0a, 0x0d, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72,
    0x79, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x33, 0x0a, 0x0a, 0x76, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c,
    0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x2e,
    0x56, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61,
    0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x13, 0x0a, 0x0b, 0x65, 0x6e, 0x76, 0x69,
    0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a,
    0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x0f, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x1b, 0x0a, 0x05, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x0c, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x1d, 0x0a,
    0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x22, 0x36, 0x0a, 0x0a,
    0x56, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x0d, 0x0a, 0x09, 0x46, 0x52,
    0x41, 0x4d, 0x45, 0x57, 0x4f, 0x52, 0x4b, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x43, 0x4c, 0x55,
    0x53, 0x54, 0x45, 0x52, 0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x58, 0x54, 0x45, 0x52, 0x4e,
    0x41, 0x4c, 0x10, 0x02, 0x2a, 0x5c, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16,
    0x0a, 0x12, 0x44, 0x52, 0x49, 0x56, 0x45, 0x52, 0x5f, 0x4e, 0x4f, 0x54, 0x5f, 0x53, 0x54, 0x41,
    0x52, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x52, 0x49, 0x56, 0x45, 0x52,
    0x5f, 0x52, 0x55, 0x4e, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x02, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x52,
    0x49, 0x56, 0x45, 0x52, 0x5f, 0x41, 0x42, 0x4f, 0x52, 0x54, 0x45, 0x44, 0x10, 0x03, 0x12, 0x12,
    0x0a, 0x0e, 0x44, 0x52, 0x49, 0x56, 0x45, 0x52, 0x5f, 0x53, 0x54, 0x4f, 0x50, 0x50, 0x45, 0x44,
    0x10, 0x04, 0x2a, 0x96, 0x01, 0x0a, 0x09, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x65,
    0x12, 0x10, 0x0a, 0x0c, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x53, 0x54, 0x41, 0x47, 0x49, 0x4e, 0x47,
    0x10, 0x06, 0x12, 0x11, 0x0a, 0x0d, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x53, 0x54, 0x41, 0x52, 0x54,
    0x49, 0x4e, 0x47, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x52, 0x55,
    0x4e, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x11, 0x0a, 0x0d, 0x54, 0x41, 0x53, 0x4b, 0x5f,
    0x46, 0x49, 0x4e, 0x49, 0x53, 0x48, 0x45, 0x44, 0x10, 0x02, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x41,
    0x53, 0x4b, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x54,
    0x41, 0x53, 0x4b, 0x5f, 0x4b, 0x49, 0x4c, 0x4c, 0x45, 0x44, 0x10, 0x04, 0x12, 0x0d, 0x0a, 0x09,
    0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4c, 0x4f, 0x53, 0x54, 0x10, 0x05, 0x12, 0x0e, 0x0a, 0x0a, 0x54,
    0x41, 0x53, 0x4b, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x07, 0x42, 0x1a, 0x0a, 0x10, 0x6f,
    0x72, 0x67, 0x2e, 0x61, 0x70, 0x61, 0x63, 0x68, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x42,
    0x06, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x4a, 0xd0, 0xb9, 0x03, 0x0a, 0x07, 0x12, 0x05, 0x12,
    0x00, 0xe1, 0x0a, 0x01, 0x0a, 0x08, 0x0a, 0x01, 0x02, 0x12, 0x03, 0x12, 0x08, 0x0d, 0x0a, 0x08,
    0x0a, 0x01, 0x08, 0x12, 0x03, 0x14, 0x00, 0x29, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00,
    0x12, 0x03, 0x14, 0x00, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x03,
    0x14, 0x07, 0x13, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03, 0x14,
    0x07, 0x13, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x14,
    0x07, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x07, 0x12, 0x03, 0x14, 0x16, 0x28,
    0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x15, 0x00, 0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7,
    0x07, 0x01, 0x12, 0x03, 0x15, 0x00, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x02,
    0x12, 0x03, 0x15, 0x07, 0x1b, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x12,
    0x03, 0x15, 0x07, 0x1b, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x01, 0x12,
    0x03, 0x15, 0x07, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x07, 0x12, 0x03, 0x15,
    0x1e, 0x26, 0x0a, 0x70, 0x0a, 0x02, 0x05, 0x00, 0x12, 0x04, 0x1c, 0x00, 0x21, 0x01, 0x1a, 0x64,
    0x2a, 0x0a, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65,
    0x64, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x65, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x6f, 0x72, 0x0a, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x61, 0x66,
    0x74, 0x65, 0x72, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x61, 0x6c,
    0x6c, 0x73, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x00, 0x01, 0x12, 0x03, 0x1c, 0x05, 0x0b,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x00, 0x12, 0x03, 0x1d, 0x02, 0x19, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x1d, 0x02, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x00, 0x02, 0x12, 0x03, 0x1d, 0x17, 0x18, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02,
    0x01, 0x12, 0x03, 0x1e, 0x02, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x01, 0x12,
    0x03, 0x1e, 0x02, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x02, 0x12, 0x03, 0x1e,
    0x13, 0x14, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x02, 0x12, 0x03, 0x1f, 0x02, 0x15, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x02, 0x01, 0x12, 0x03, 0x1f, 0x02, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x02, 0x02, 0x12, 0x03, 0x1f, 0x13, 0x14, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x00, 0x02, 0x03, 0x12, 0x03, 0x20, 0x02, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03,
    0x01, 0x12, 0x03, 0x20, 0x02, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03, 0x02, 0x12,
    0x03, 0x20, 0x13, 0x14, 0x0a, 0x87, 0x01, 0x0a, 0x02, 0x04, 0x00, 0x12, 0x04, 0x28, 0x00, 0x2a,
    0x01, 0x1a, 0x7b, 0x2a, 0x0a, 0x20, 0x41, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49,
    0x44, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x20, 0x41, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x72, 0x65, 0x75, 0x73, 0x65,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x49, 0x44, 0x0a, 0x20, 0x69, 0x6e, 0x20, 0x6f, 0x72, 0x64,
    0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x6f, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x6f, 0x76, 0x65,
    0x72, 0x20, 0x28, 0x73, 0x65, 0x65, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x53, 0x63, 0x68, 0x65,
    0x64, 0x75, 0x6c, 0x65, 0x72, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x29, 0x2e, 0x0a, 0x0a, 0x0a,
    0x0a, 0x03, 0x04, 0x00, 0x01, 0x12, 0x03, 0x28, 0x08, 0x13, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00,
    0x02, 0x00, 0x12, 0x03, 0x29, 0x02, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x03, 0x29, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03,
    0x29, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x29, 0x12,
    0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x03, 0x12, 0x03, 0x29, 0x1a, 0x1b, 0x0a,
    0x31, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x30, 0x00, 0x32, 0x01, 0x1a, 0x25, 0x2a, 0x0a, 0x20,
    0x41, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49, 0x44, 0x20, 0x61, 0x73, 0x73, 0x69,
    0x67, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72,
    0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x03, 0x30, 0x08, 0x0f, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x03, 0x31, 0x02, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x31, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x00, 0x05, 0x12, 0x03, 0x31, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x31, 0x12, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x03, 0x12, 0x03,
    0x31, 0x1a, 0x1b, 0x0a, 0xd0, 0x01, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x04, 0x3a, 0x00, 0x3c, 0x01,
    0x1a, 0xc3, 0x01, 0x2a, 0x0a, 0x20, 0x41, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49,
    0x44, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20,
    0x73, 0x6c, 0x61, 0x76, 0x65, 0x2e, 0x20, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79,
    0x2c, 0x20, 0x61, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x20, 0x67, 0x65, 0x74, 0x73, 0x20, 0x61,
    0x20, 0x6e, 0x65, 0x77, 0x20, 0x49, 0x44, 0x0a, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x65, 0x76, 0x65,
    0x72, 0x20, 0x69, 0x74, 0x20, 0x28, 0x72, 0x65, 0x29, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
    0x72, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x20, 0x46,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x72, 0x73,
    0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x6e, 0x27, 0x74, 0x0a, 0x20, 0x61, 0x73, 0x73, 0x75,
    0x6d, 0x65, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x62, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x62,
    0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x61, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x20, 0x49,
    0x44, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x20, 0x68, 0x6f, 0x73, 0x74,
    0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x03, 0x3a,
    0x08, 0x0f, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x00, 0x12, 0x03, 0x3b, 0x02, 0x1c, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x04, 0x12, 0x03, 0x3b, 0x02, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x00, 0x05, 0x12, 0x03, 0x3b, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x00, 0x01, 0x12, 0x03, 0x3b, 0x12, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x00, 0x03, 0x12, 0x03, 0x3b, 0x1a, 0x1b, 0x0a, 0x99, 0x02, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x04,
    0x45, 0x00, 0x47, 0x01, 0x1a, 0x8c, 0x02, 0x2a, 0x0a, 0x20, 0x41, 0x20, 0x66, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20,
    0x49, 0x44, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x75, 0x69, 0x73,
    0x68, 0x20, 0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x49, 0x44,
    0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x0a, 0x20, 0x75, 0x6e,
    0x69, 0x71, 0x75, 0x65, 0x20, 0x77, 0x68, 0x69, 0x6c, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74,
    0x61, 0x73, 0x6b, 0x20, 0x69, 0x73, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x2e, 0x20, 0x48,
    0x6f, 0x77, 0x65, 0x76, 0x65, 0x72, 0x2c, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77,
    0x6f, 0x72, 0x6b, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x72, 0x65, 0x75, 0x73, 0x65, 0x20, 0x61, 0x6e,
    0x0a, 0x20, 0x49, 0x44, 0x20, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x5f, 0x20, 0x69, 0x66, 0x20, 0x61,
    0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x77,
    0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x49, 0x44, 0x20,
    0x68, 0x61, 0x73, 0x20, 0x72, 0x65, 0x61, 0x63, 0x68, 0x65, 0x64, 0x20, 0x61, 0x0a, 0x20, 0x74,
    0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x28, 0x65,
    0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x46, 0x49, 0x4e, 0x49, 0x53, 0x48,
    0x45, 0x44, 0x2c, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4c, 0x4f, 0x53, 0x54, 0x2c, 0x20, 0x54,
    0x41, 0x53, 0x4b, 0x5f, 0x4b, 0x49, 0x4c, 0x4c, 0x45, 0x44, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e,
    0x29, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x03, 0x01, 0x12, 0x03, 0x45, 0x08, 0x0e, 0x0a,
    0x0b, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x03, 0x46, 0x02, 0x1c, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x03, 0x02, 0x00, 0x04, 0x12, 0x03, 0x46, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03,
    0x02, 0x00, 0x05, 0x12, 0x03, 0x46, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00,
    0x01, 0x12, 0x03, 0x46, 0x12, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x03, 0x12,
    0x03, 0x46, 0x1a, 0x1b, 0x0a, 0x95, 0x01, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x04, 0x4f, 0x00, 0x51,
    0x01, 0x1a, 0x88, 0x01, 0x2a, 0x0a, 0x20, 0x41, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x49, 0x44, 0x20,
    0x74, 0x6f, 0x20, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x75, 0x69, 0x73, 0x68, 0x20, 0x61,
    0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x20, 0x4f, 0x6e, 0x6c, 0x79,
    0x20, 0x6f, 0x6e, 0x65, 0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x77,
    0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x49, 0x44, 0x20,
    0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6f, 0x6e,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x20,
    0x61, 0x74, 0x20, 0x61, 0x0a, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03,
    0x04, 0x04, 0x01, 0x12, 0x03, 0x4f, 0x08, 0x12, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x00,
    0x12, 0x03, 0x50, 0x02, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x04, 0x12, 0x03,
    0x50, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x05, 0x12, 0x03, 0x50, 0x0b,
    0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x01, 0x12, 0x03, 0x50, 0x12, 0x17, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x03, 0x12, 0x03, 0x50, 0x1a, 0x1b, 0x0a, 0xf7, 0x01,
    0x0a, 0x02, 0x04, 0x05, 0x12, 0x04, 0x5a, 0x00, 0x5c, 0x01, 0x1a, 0xea, 0x01, 0x2a, 0x0a, 0x20,
    0x41, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65,
    0x64, 0x20, 0x49, 0x44, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x75,
    0x69, 0x73, 0x68, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e,
    0x20, 0x54, 0x68, 0x65, 0x20, 0x49, 0x44, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20,
    0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x0a, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20,
    0x61, 0x6e, 0x79, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x63, 0x6f,
    0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
    0x72, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x2e,
    0x20, 0x49, 0x6e, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x75, 0x6c, 0x61, 0x72, 0x2c, 0x0a,
    0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x72, 0x75, 0x6e, 0x73, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x28, 0x66, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2c, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x29,
    0x20, 0x70, 0x61, 0x69, 0x72, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x75,
    0x6e, 0x69, 0x71, 0x75, 0x65, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12, 0x03,
    0x5a, 0x08, 0x13, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x00, 0x12, 0x03, 0x5b, 0x02, 0x1c,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x04, 0x12, 0x03, 0x5b, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x05, 0x12, 0x03, 0x5b, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x00, 0x01, 0x12, 0x03, 0x5b, 0x12, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x00, 0x03, 0x12, 0x03, 0x5b, 0x1a, 0x1b, 0x0a, 0x49, 0x0a, 0x02, 0x04, 0x06, 0x12, 0x04,
    0x64, 0x00, 0x6a, 0x01, 0x1a, 0x3d, 0x2a, 0x0a, 0x20, 0x41, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f,
    0x72, 0x6b, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2e, 0x0a, 0x0a, 0x20, 0x54, 0x4f,
    0x44, 0x4f, 0x28, 0x62, 0x6d, 0x61, 0x68, 0x6c, 0x65, 0x72, 0x29, 0x3a, 0x20, 0x55, 0x73, 0x65,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x77, 0x69, 0x64, 0x65, 0x6c,
    0x79, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x06, 0x01, 0x12, 0x03, 0x64, 0x08, 0x0f, 0x0a,
    0x3b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x00, 0x12, 0x03, 0x66, 0x02, 0x1f, 0x1a, 0x2e, 0x20, 0x4d,
    0x61, 0x79, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x68, 0x6f, 0x73,
    0x74, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x62, 0x6f, 0x74, 0x68, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x00, 0x04, 0x12, 0x03, 0x66, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x00, 0x05, 0x12, 0x03, 0x66, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00,
    0x01, 0x12, 0x03, 0x66, 0x12, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x03, 0x12,
    0x03, 0x66, 0x1d, 0x1e, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x01, 0x12, 0x03, 0x67, 0x02,
    0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x04, 0x12, 0x03, 0x67, 0x02, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x05, 0x12, 0x03, 0x67, 0x0b, 0x11, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x01, 0x01, 0x12, 0x03, 0x67, 0x12, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x01, 0x03, 0x12, 0x03, 0x67, 0x17, 0x18, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02,
    0x02, 0x12, 0x03, 0x69, 0x02, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x04, 0x12,
    0x03, 0x69, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x05, 0x12, 0x03, 0x69,
    0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x01, 0x12, 0x03, 0x69, 0x11, 0x15,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x03, 0x12, 0x03, 0x69, 0x18, 0x19, 0x0a, 0x21,
    0x0a, 0x02, 0x04, 0x07, 0x12, 0x04, 0x70, 0x00, 0x76, 0x01, 0x1a, 0x15, 0x2a, 0x0a, 0x20, 0x52,
    0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x61, 0x20, 0x55, 0x52, 0x4c, 0x2e,
    0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x07, 0x01, 0x12, 0x03, 0x70, 0x08, 0x0b, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x07, 0x02, 0x00, 0x12, 0x03, 0x71, 0x02, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x00, 0x04, 0x12, 0x03, 0x71, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00,
    0x05, 0x12, 0x03, 0x71, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x01, 0x12,
    0x03, 0x71, 0x12, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x03, 0x12, 0x03, 0x71,
    0x1b, 0x1c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x01, 0x12, 0x03, 0x72, 0x02, 0x1f, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x04, 0x12, 0x03, 0x72, 0x02, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x07, 0x02, 0x01, 0x06, 0x12, 0x03, 0x72, 0x0b, 0x12, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x01, 0x01, 0x12, 0x03, 0x72, 0x13, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x01, 0x03, 0x12, 0x03, 0x72, 0x1d, 0x1e, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x02, 0x12,
    0x03, 0x73, 0x02, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x04, 0x12, 0x03, 0x73,
    0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x05, 0x12, 0x03, 0x73, 0x0b, 0x11,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x01, 0x12, 0x03, 0x73, 0x12, 0x16, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x03, 0x12, 0x03, 0x73, 0x19, 0x1a, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x07, 0x02, 0x03, 0x12, 0x03, 0x74, 0x02, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x03, 0x04, 0x12, 0x03, 0x74, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x03, 0x06,
    0x12, 0x03, 0x74, 0x0b, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x03, 0x01, 0x12, 0x03,
    0x74, 0x15, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x03, 0x03, 0x12, 0x03, 0x74, 0x1d,
    0x1e, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x04, 0x12, 0x03, 0x75, 0x02, 0x1f, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x07, 0x02, 0x04, 0x04, 0x12, 0x03, 0x75, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x07, 0x02, 0x04, 0x05, 0x12, 0x03, 0x75, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x04, 0x01, 0x12, 0x03, 0x75, 0x12, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x04,
    0x03, 0x12, 0x03, 0x75, 0x1d, 0x1e, 0x0a, 0x27, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x05, 0x7c, 0x00,
    0xbc, 0x01, 0x01, 0x1a, 0x1a, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65,
    0x73, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x0a, 0x0a,
    0x0a, 0x0a, 0x03, 0x04, 0x08, 0x01, 0x12, 0x03, 0x7c, 0x08, 0x15, 0x0a, 0xc3, 0x01, 0x0a, 0x04,
    0x04, 0x08, 0x02, 0x00, 0x12, 0x04, 0x80, 0x01, 0x02, 0x1b, 0x1a, 0xb4, 0x01, 0x20, 0x55, 0x73,
    0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x55, 0x6e, 0x69, 0x78, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x6f,
    0x72, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x0a, 0x20, 0x62,
    0x65, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x65, 0x64, 0x20, 0x61, 0x73, 0x2e, 0x20, 0x49,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64,
    0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x6d,
    0x70, 0x74, 0x79, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73,
    0x0a, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x67, 0x69, 0x63,
    0x61, 0x6c, 0x6c, 0x79, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x75, 0x73, 0x65, 0x72, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x04, 0x12, 0x04, 0x80, 0x01, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x05, 0x12, 0x04, 0x80, 0x01, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x01, 0x12, 0x04, 0x80, 0x01, 0x12, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x03, 0x12, 0x04, 0x80, 0x01, 0x19, 0x1a, 0x0a, 0x48, 0x0a,
    0x04, 0x04, 0x08, 0x02, 0x01, 0x12, 0x04, 0x83, 0x01, 0x02, 0x1b, 0x1a, 0x3a, 0x20, 0x4e, 0x61,
    0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77,
    0x6f, 0x72, 0x6b, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x77, 0x73, 0x20, 0x75,
    0x70, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x57,
    0x65, 0x62, 0x20, 0x55, 0x49, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x04,
    0x12, 0x04, 0x83, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x05, 0x12,
    0x04, 0x83, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x83, 0x01, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x03, 0x12, 0x04, 0x83,
    0x01, 0x19, 0x1a, 0x0a, 0xff, 0x01, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x02, 0x12, 0x04, 0x8a, 0x01,
    0x02, 0x1e, 0x1a, 0xf0, 0x01, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x27, 0x69, 0x64, 0x27, 0x20, 0x69, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x61, 0x76, 0x61,
    0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x61, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x68, 0x61, 0x73, 0x0a, 0x20, 0x72, 0x65,
    0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x2c, 0x20, 0x68, 0x6f, 0x77, 0x65, 0x76, 0x65,
    0x72, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65,
    0x64, 0x20, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x20,
    0x74, 0x6f, 0x20, 0x66, 0x61, 0x63, 0x69, 0x6c, 0x69, 0x74, 0x61, 0x74, 0x65, 0x0a, 0x20, 0x73,
    0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x6f, 0x76, 0x65,
    0x72, 0x20, 0x28, 0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 0x69,
    0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20,
    0x4d, 0x65, 0x73, 0x6f, 0x73, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x44, 0x72,
    0x69, 0x76, 0x65, 0x72, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x70, 0x65,
    0x72, 0x66, 0x6f, 0x72, 0x6d, 0x69, 0x6e, 0x67, 0x0a, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x6f, 0x76,
    0x65, 0x72, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x04, 0x12, 0x04,
    0x8a, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x06, 0x12, 0x04, 0x8a,
    0x01, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8a, 0x01,
    0x17, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8a, 0x01, 0x1c,
    0x1d, 0x0a, 0x94, 0x02, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x03, 0x12, 0x04, 0x90, 0x01, 0x02, 0x37,
    0x1a, 0x85, 0x02, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x77, 0x61, 0x69, 0x74,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
    0x65, 0x72, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x6f, 0x76, 0x65, 0x72, 0x20,
    0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x69, 0x74, 0x20, 0x74, 0x65, 0x61, 0x72, 0x73, 0x20,
    0x64, 0x6f, 0x77, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x20, 0x62, 0x79, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6c,
    0x6c, 0x20, 0x69, 0x74, 0x73, 0x0a, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x2f, 0x65, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x73, 0x68, 0x6f,
    0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x6e, 0x6f, 0x6e, 0x2d, 0x7a, 0x65, 0x72, 0x6f, 0x20,
    0x69, 0x66, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x65,
    0x78, 0x70, 0x65, 0x63, 0x74, 0x73, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x6e,
    0x6e, 0x65, 0x63, 0x74, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x61, 0x20, 0x66, 0x61, 0x69,
    0x6c, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x6f,
    0x73, 0x65, 0x20, 0x69, 0x74, 0x73, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x2f, 0x65, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03,
    0x04, 0x12, 0x04, 0x90, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x05,
    0x12, 0x04, 0x90, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x01, 0x12,
    0x04, 0x90, 0x01, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x03, 0x12, 0x04,
    0x90, 0x01, 0x25, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x08, 0x12, 0x04, 0x90,
    0x01, 0x27, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x07, 0x12, 0x04, 0x90, 0x01,
    0x32, 0x35, 0x0a, 0xef, 0x01, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x04, 0x12, 0x04, 0x96, 0x01, 0x02,
    0x31, 0x1a, 0xe0, 0x01, 0x20, 0x49, 0x66, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x70, 0x69, 0x64, 0x2c, 0x20, 0x65, 0x78, 0x65, 0x63,
    0x75, 0x74, 0x6f, 0x72, 0x20, 0x70, 0x69, 0x64, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73, 0x74,
    0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65,
    0x0a, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x74,
    0x6f, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6c,
    0x61, 0x76, 0x65, 0x73, 0x2e, 0x20, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74,
    0x69, 0x6e, 0x67, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x61, 0x0a, 0x20, 0x72, 0x65,
    0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f,
    0x20, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20,
    0x6f, 0x6c, 0x64, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0a, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75,
    0x73, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x63, 0x6f, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x49,
    0x2f, 0x4f, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x04, 0x04, 0x12, 0x04, 0x96,
    0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x04, 0x05, 0x12, 0x04, 0x96, 0x01,
    0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x04, 0x01, 0x12, 0x04, 0x96, 0x01, 0x10,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x04, 0x03, 0x12, 0x04, 0x96, 0x01, 0x1d, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x04, 0x08, 0x12, 0x04, 0x96, 0x01, 0x1f, 0x30, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x04, 0x07, 0x12, 0x04, 0x96, 0x01, 0x2a, 0x2f, 0x0a, 0x72,
    0x0a, 0x04, 0x04, 0x08, 0x02, 0x05, 0x12, 0x04, 0x9a, 0x01, 0x02, 0x2b, 0x1a, 0x64, 0x20, 0x55,
    0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x6f,
    0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x64, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x73,
    0x2c, 0x20, 0x64, 0x65, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x0a, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x70,
    0x6f, 0x6c, 0x69, 0x63, 0x79, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x05, 0x04, 0x12, 0x04, 0x9a, 0x01, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x05, 0x05, 0x12, 0x04, 0x9a, 0x01, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x05, 0x01, 0x12, 0x04, 0x9a, 0x01, 0x12, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x05, 0x03, 0x12, 0x04, 0x9a, 0x01, 0x19, 0x1a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x08, 0x02, 0x05, 0x08, 0x12, 0x04, 0x9a, 0x01, 0x1b, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x08, 0x02, 0x05, 0x07, 0x12, 0x04, 0x9a, 0x01, 0x26, 0x29, 0x0a, 0xd8, 0x01, 0x0a,
    0x04, 0x04, 0x08, 0x02, 0x06, 0x12, 0x04, 0xa0, 0x01, 0x02, 0x1f, 0x1a, 0xc9, 0x01, 0x20, 0x55,
    0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x68, 0x6f, 0x73, 0x74,
    0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x72, 0x65,
    0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x57, 0x65, 0x62, 0x20, 0x55, 0x49, 0x2e, 0x20, 0x49, 0x66,
    0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x6d, 0x70, 0x74, 0x79,
    0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x0a, 0x20, 0x77,
    0x69, 0x6c, 0x6c, 0x20, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x67, 0x69, 0x63, 0x61, 0x6c, 0x6c,
    0x79, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65,
    0x20, 0x69, 0x66, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x61, 0x76, 0x61, 0x69,
    0x6c, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x06, 0x04,
    0x12, 0x04, 0xa0, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x06, 0x05, 0x12,
    0x04, 0xa0, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x06, 0x01, 0x12, 0x04,
    0xa0, 0x01, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x06, 0x03, 0x12, 0x04, 0xa0,
    0x01, 0x1d, 0x1e, 0x0a, 0x90, 0x02, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x07, 0x12, 0x04, 0xa6, 0x01,
    0x02, 0x20, 0x1a, 0x81, 0x02, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64,
    0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x27, 0x73, 0x20, 0x70,
    0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x0a, 0x20, 0x75, 0x73, 0x65, 0x73, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x75,
    0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x20, 0x41, 0x50, 0x49, 0x0a, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6c, 0x69, 0x6d, 0x69,
    0x74, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63,
    0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x20, 0x49,
    0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x20,
    0x65, 0x76, 0x65, 0x6e, 0x0a, 0x20, 0x69, 0x66, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,
    0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x65,
    0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20,
    0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x64, 0x65, 0x73,
    0x69, 0x72, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x07, 0x04, 0x12,
    0x04, 0xa6, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x07, 0x05, 0x12, 0x04,
    0xa6, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x07, 0x01, 0x12, 0x04, 0xa6,
    0x01, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x07, 0x03, 0x12, 0x04, 0xa6, 0x01,
    0x1e, 0x1f, 0x0a, 0xc6, 0x01, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x08, 0x12, 0x04, 0xab, 0x01, 0x02,
    0x20, 0x1a, 0xb7, 0x01, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20,
    0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74, 0x69, 0x73, 0x65, 0x20,
    0x69, 0x74, 0x73, 0x20, 0x77, 0x65, 0x62, 0x20, 0x55, 0x49, 0x2c, 0x20, 0x73, 0x6f, 0x20, 0x74,
    0x68, 0x61, 0x74, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x77,
    0x65, 0x62, 0x20, 0x55, 0x49, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x6c, 0x69, 0x6e, 0x6b, 0x20, 0x74,
    0x6f, 0x20, 0x69, 0x74, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x65, 0x78, 0x70, 0x65,
    0x63, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6c,
    0x6c, 0x20, 0x55, 0x52, 0x4c, 0x2c, 0x0a, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6d,
    0x70, 0x6c, 0x65, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x6d, 0x79, 0x2d, 0x73, 0x63,
    0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e,
    0x63, 0x6f, 0x6d, 0x3a, 0x38, 0x30, 0x38, 0x30, 0x2f, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x08, 0x02, 0x08, 0x04, 0x12, 0x04, 0xab, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08,
    0x02, 0x08, 0x05, 0x12, 0x04, 0xab, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02,
    0x08, 0x01, 0x12, 0x04, 0xab, 0x01, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x08,
    0x03, 0x12, 0x04, 0xab, 0x01, 0x1e, 0x1f, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x08, 0x03, 0x00, 0x12,
    0x06, 0xad, 0x01, 0x02, 0xb6, 0x01, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x03, 0x00, 0x01,
    0x12, 0x04, 0xad, 0x01, 0x0a, 0x14, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x08, 0x03, 0x00, 0x04, 0x00,
    0x12, 0x06, 0xae, 0x01, 0x04, 0xb3, 0x01, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00,
    0x04, 0x00, 0x01, 0x12, 0x04, 0xae, 0x01, 0x09, 0x0d, 0x0a, 0x8a, 0x01, 0x0a, 0x08, 0x04, 0x08,
    0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb2, 0x01, 0x06, 0x1e, 0x1a, 0x78, 0x20, 0x52,
    0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x20, 0x72, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x72, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2e, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x52, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x27, 0x0a, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x2e, 0x0a, 0x20, 0x54, 0x4f,
    0x44, 0x4f, 0x28, 0x76, 0x69, 0x6e, 0x6f, 0x64, 0x29, 0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x69, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x61, 0x20, 0x6e,
    0x6f, 0x2d, 0x6f, 0x70, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x08, 0x03, 0x00, 0x04, 0x00,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xb2, 0x01, 0x06, 0x19, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x08, 0x03,
    0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xb2, 0x01, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x08, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb5, 0x01, 0x04, 0x1b, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x08, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb5, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x08, 0x03, 0x00, 0x02, 0x00, 0x06, 0x12, 0x04, 0xb5, 0x01, 0x0d, 0x11, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x08, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x12, 0x16, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb5, 0x01, 0x19, 0x1a,
    0x0a, 0x90, 0x01, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x09, 0x12, 0x04, 0xbb, 0x01, 0x02, 0x28, 0x1a,
    0x81, 0x01, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x61, 0x6c,
    0x6c, 0x6f, 0x77, 0x73, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b,
    0x20, 0x74, 0x6f, 0x20, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74, 0x69, 0x73, 0x65, 0x20, 0x69, 0x74,
    0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x66, 0x0a, 0x20, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69,
    0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x61, 0x62,
    0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65,
    0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x76, 0x6f,
    0x63, 0x61, 0x62, 0x6c, 0x65, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73,
    0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x09, 0x04, 0x12, 0x04, 0xbb, 0x01,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x09, 0x06, 0x12, 0x04, 0xbb, 0x01, 0x0b,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x09, 0x01, 0x12, 0x04, 0xbb, 0x01, 0x16, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x09, 0x03, 0x12, 0x04, 0xbb, 0x01, 0x25, 0x27, 0x0a,
    0x80, 0x02, 0x0a, 0x02, 0x04, 0x09, 0x12, 0x06, 0xc5, 0x01, 0x00, 0xf6, 0x01, 0x01, 0x1a, 0xf1,
    0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20,
    0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x20, 0x28, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x61, 0x72, 0x62, 0x69,
    0x74, 0x72, 0x61, 0x72, 0x79, 0x0a, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x2f, 0x63,
    0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x29, 0x2e, 0x20, 0x41, 0x20, 0x22, 0x73, 0x74, 0x72, 0x61,
    0x74, 0x65, 0x67, 0x79, 0x22, 0x20, 0x69, 0x73, 0x20, 0x70, 0x69, 0x63, 0x6b, 0x65, 0x64, 0x20,
    0x62, 0x79, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
    0x61, 0x6c, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x3b, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65,
    0x6e, 0x74, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x27, 0x63, 0x6f, 0x6d, 0x6d, 0x61,
    0x6e, 0x64, 0x27, 0x20, 0x69, 0x73, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64,
    0x2e, 0x0a, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x6d, 0x6f,
    0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x73, 0x74, 0x72, 0x61,
    0x74, 0x65, 0x67, 0x79, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72,
    0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x09, 0x01, 0x12, 0x04, 0xc5, 0x01, 0x08, 0x13, 0x0a,
    0x7e, 0x0a, 0x04, 0x04, 0x09, 0x03, 0x00, 0x12, 0x06, 0xc8, 0x01, 0x02, 0xd9, 0x01, 0x03, 0x1a,
    0x6e, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x48,
    0x54, 0x54, 0x50, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b,
    0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x66, 0x75,
    0x6c, 0x6c, 0x79, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64, 0x20,
    0x61, 0x6e, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x0a, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x6d, 0x6d, 0x65,
    0x6e, 0x64, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x75, 0x73, 0x65, 0x20, 0x2d, 0x20, 0x73,
    0x65, 0x65, 0x20, 0x4d, 0x45, 0x53, 0x4f, 0x53, 0x2d, 0x32, 0x35, 0x33, 0x33, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x03, 0x00, 0x01, 0x12, 0x04, 0xc8, 0x01, 0x0a, 0x0e, 0x0a, 0x30,
    0x0a, 0x06, 0x04, 0x09, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xca, 0x01, 0x04, 0x1d, 0x1a, 0x20,
    0x20, 0x50, 0x6f, 0x72, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x09, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xca, 0x01, 0x04,
    0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x09, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xca, 0x01,
    0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x09, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xca,
    0x01, 0x14, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x09, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xca, 0x01, 0x1b, 0x1c, 0x0a, 0x24, 0x0a, 0x06, 0x04, 0x09, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04,
    0xcd, 0x01, 0x04, 0x2d, 0x1a, 0x14, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x72, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x09,
    0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcd, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x09, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xcd, 0x01, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x09, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcd, 0x01, 0x14, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x09, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcd, 0x01, 0x1b, 0x1c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x09, 0x03, 0x00, 0x02, 0x01, 0x08, 0x12, 0x04, 0xcd, 0x01, 0x1d, 0x2c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x09, 0x03, 0x00, 0x02, 0x01, 0x07, 0x12, 0x04, 0xcd, 0x01, 0x28, 0x2b,
    0x0a, 0x7a, 0x0a, 0x06, 0x04, 0x09, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xd5, 0x01, 0x04, 0x21,
    0x1a, 0x6a, 0x20, 0x45, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65, 0x73, 0x2e, 0x20, 0x4e,
    0x6f, 0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e,
    0x79, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65, 0x73, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x69,
    0x65, 0x73, 0x0a, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x72, 0x65, 0x74,
    0x75, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x69, 0x73, 0x20,
    0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x09, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd5, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x09, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd5, 0x01, 0x0d, 0x13, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x09, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd5, 0x01, 0x14, 0x1c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x09, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd5, 0x01, 0x1f, 0x20,
    0x0a, 0x50, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x00, 0x12, 0x04, 0xdc, 0x01, 0x02, 0x19, 0x1a, 0x42,
    0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65,
    0x63, 0x6b, 0x20, 0x2d, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x79, 0x65, 0x74, 0x20, 0x72, 0x65, 0x63,
    0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x75, 0x73, 0x65,
    0x2c, 0x20, 0x73, 0x65, 0x65, 0x20, 0x4d, 0x45, 0x53, 0x4f, 0x53, 0x2d, 0x32, 0x35, 0x33, 0x33,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdc, 0x01, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x06, 0x12, 0x04, 0xdc, 0x01, 0x0b, 0x0f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdc, 0x01, 0x10, 0x14, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdc, 0x01, 0x17, 0x18, 0x0a, 0x48,
    0x0a, 0x04, 0x04, 0x09, 0x02, 0x01, 0x12, 0x04, 0xe6, 0x01, 0x02, 0x35, 0x1a, 0x3a, 0x20, 0x41,
    0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x6f,
    0x20, 0x77, 0x61, 0x69, 0x74, 0x20, 0x75, 0x6e, 0x74, 0x69, 0x6c, 0x20, 0x73, 0x74, 0x61, 0x72,
    0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20,
    0x63, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xe6, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xe6, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xe6, 0x01, 0x12, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xe6, 0x01, 0x22, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x08, 0x12, 0x04, 0xe6,
    0x01, 0x24, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x07, 0x12, 0x04, 0xe6, 0x01,
    0x2f, 0x33, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x02, 0x12, 0x04, 0xe9, 0x01, 0x02, 0x38,
    0x1a, 0x21, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x20, 0x62, 0x65, 0x74, 0x77,
    0x65, 0x65, 0x6e, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b,
    0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe9, 0x01,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe9, 0x01, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe9, 0x01, 0x12, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe9, 0x01, 0x25, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x08, 0x12, 0x04, 0xe9, 0x01, 0x27, 0x37, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x07, 0x12, 0x04, 0xe9, 0x01, 0x32, 0x36, 0x0a, 0x48, 0x0a,
    0x04, 0x04, 0x09, 0x02, 0x03, 0x12, 0x04, 0xec, 0x01, 0x02, 0x37, 0x1a, 0x3a, 0x20, 0x41, 0x6d,
    0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x6f, 0x20,
    0x77, 0x61, 0x69, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x65, 0x61,
    0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6d,
    0x70, 0x6c, 0x65, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x04,
    0x12, 0x04, 0xec, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x05, 0x12,
    0x04, 0xec, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xec, 0x01, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x03, 0x12, 0x04, 0xec,
    0x01, 0x24, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x08, 0x12, 0x04, 0xec, 0x01,
    0x26, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x07, 0x12, 0x04, 0xec, 0x01, 0x31,
    0x35, 0x0a, 0x4a, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x04, 0x12, 0x04, 0xef, 0x01, 0x02, 0x39, 0x1a,
    0x3c, 0x20, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x63, 0x6f, 0x6e, 0x73,
    0x65, 0x63, 0x75, 0x74, 0x69, 0x76, 0x65, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x73,
    0x20, 0x75, 0x6e, 0x74, 0x69, 0x6c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x65,
    0x64, 0x20, 0x75, 0x6e, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x04, 0x04, 0x12, 0x04, 0xef, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x04, 0x05, 0x12, 0x04, 0xef, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x04, 0x01, 0x12, 0x04, 0xef, 0x01, 0x12, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x04, 0x03, 0x12, 0x04, 0xef, 0x01, 0x29, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x04, 0x08, 0x12, 0x04, 0xef, 0x01, 0x2b, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x04,
    0x07, 0x12, 0x04, 0xef, 0x01, 0x36, 0x37, 0x0a, 0x4a, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x05, 0x12,
    0x04, 0xf2, 0x01, 0x02, 0x3c, 0x1a, 0x3c, 0x20, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x20,
    0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68,
    0x65, 0x63, 0x6b, 0x73, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63,
    0x68, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x05, 0x04, 0x12, 0x04, 0xf2, 0x01,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x05, 0x05, 0x12, 0x04, 0xf2, 0x01, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x05, 0x01, 0x12, 0x04, 0xf2, 0x01, 0x12, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x05, 0x03, 0x12, 0x04, 0xf2, 0x01, 0x29, 0x2a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x05, 0x08, 0x12, 0x04, 0xf2, 0x01, 0x2b, 0x3b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x05, 0x07, 0x12, 0x04, 0xf2, 0x01, 0x36, 0x3a, 0x0a, 0x25, 0x0a,
    0x04, 0x04, 0x09, 0x02, 0x06, 0x12, 0x04, 0xf5, 0x01, 0x02, 0x23, 0x1a, 0x17, 0x20, 0x43, 0x6f,
    0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65,
    0x63, 0x6b, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x06, 0x04, 0x12, 0x04, 0xf5,
    0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x06, 0x06, 0x12, 0x04, 0xf5, 0x01,
    0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x06, 0x01, 0x12, 0x04, 0xf5, 0x01, 0x17,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x06, 0x03, 0x12, 0x04, 0xf5, 0x01, 0x21, 0x22,
    0x0a, 0xd5, 0x04, 0x0a, 0x02, 0x04, 0x0a, 0x12, 0x06, 0x83, 0x02, 0x00, 0xc9, 0x02, 0x01, 0x1a,
    0xc6, 0x04, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61,
    0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2c, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x65, 0x64, 0x20, 0x76, 0x69, 0x61, 0x3a, 0x20, 0x27, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68,
    0x20, 0x2d, 0x63, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x27, 0x2e, 0x20, 0x41, 0x6e, 0x79, 0x20,
    0x55, 0x52, 0x49, 0x73, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x0a, 0x20,
    0x61, 0x72, 0x65, 0x20, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x64, 0x20, 0x62, 0x65, 0x66, 0x6f,
    0x72, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x20, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x69, 0x65,
    0x6c, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x0a, 0x20, 0x75, 0x72, 0x69, 0x20, 0x69,
    0x73, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c,
    0x65, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
    0x6e, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x2e,
    0x0a, 0x20, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2c, 0x20, 0x69, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x20, 0x66,
    0x69, 0x6c, 0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x67, 0x6e,
    0x69, 0x7a, 0x65, 0x64, 0x20, 0x61, 0x72, 0x63, 0x68, 0x69, 0x76, 0x65, 0x20, 0x65, 0x78, 0x74,
    0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x28, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74,
    0x6c, 0x79, 0x20, 0x5b, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x5d, 0x20,
    0x74, 0x61, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x7a, 0x69, 0x70, 0x29, 0x20, 0x69, 0x74, 0x20,
    0x69, 0x73, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x74,
    0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x27, 0x73,
    0x0a, 0x20, 0x77, 0x6f, 0x72, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74,
    0x6f, 0x72, 0x79, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x64, 0x69, 0x73, 0x61,
    0x62, 0x6c, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x20,
    0x60, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x60, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x66, 0x61,
    0x6c, 0x73, 0x65, 0x2e, 0x20, 0x49, 0x6e, 0x20, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e,
    0x2c, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e,
    0x74, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x73, 0x65, 0x74, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x69, 0x6e, 0x67, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
    0x64, 0x20, 0x28, 0x73, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62,
    0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x22, 0x70, 0x61, 0x72, 0x61, 0x6d,
    0x65, 0x74, 0x65, 0x72, 0x69, 0x7a, 0x65, 0x22, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x6f,
    0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x29, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0a, 0x01, 0x12,
    0x04, 0x83, 0x02, 0x08, 0x13, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0a, 0x03, 0x00, 0x12, 0x06, 0x84,
    0x02, 0x02, 0x99, 0x02, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x03, 0x00, 0x01, 0x12, 0x04,
    0x84, 0x02, 0x0a, 0x0d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04,
    0x85, 0x02, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x85, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x00, 0x05,
    0x12, 0x04, 0x85, 0x02, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x85, 0x02, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x85, 0x02, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0a, 0x03, 0x00,
    0x02, 0x01, 0x12, 0x04, 0x86, 0x02, 0x04, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00,
    0x02, 0x01, 0x04, 0x12, 0x04, 0x86, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03,
    0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x86, 0x02, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a,
    0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x86, 0x02, 0x12, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0a, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x86, 0x02, 0x1f, 0x20, 0x0a, 0xf5, 0x01, 0x0a,
    0x06, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0x8c, 0x02, 0x04, 0x2f, 0x1a, 0xe4, 0x01,
    0x20, 0x49, 0x6e, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x65, 0x74,
    0x63, 0x68, 0x65, 0x64, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x63,
    0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x72,
    0x63, 0x68, 0x69, 0x76, 0x65, 0x2c, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x0a, 0x20,
    0x69, 0x74, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x74,
    0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x2e, 0x20, 0x4e,
    0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65,
    0x64, 0x20, 0x61, 0x72, 0x63, 0x68, 0x69, 0x76, 0x65, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x63, 0x6f, 0x70, 0x69, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x65,
    0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x6f, 0x72, 0x69, 0x67, 0x69,
    0x6e, 0x61, 0x74, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x72,
    0x63, 0x68, 0x69, 0x76, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x63,
    0x68, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12,
    0x04, 0x8c, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x02, 0x05,
    0x12, 0x04, 0x8c, 0x02, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x02,
    0x01, 0x12, 0x04, 0x8c, 0x02, 0x12, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02,
    0x02, 0x03, 0x12, 0x04, 0x8c, 0x02, 0x1c, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00,
    0x02, 0x02, 0x08, 0x12, 0x04, 0x8c, 0x02, 0x1e, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03,
    0x00, 0x02, 0x02, 0x07, 0x12, 0x04, 0x8c, 0x02, 0x29, 0x2d, 0x0a, 0xe0, 0x04, 0x0a, 0x06, 0x04,
    0x0a, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0x98, 0x02, 0x04, 0x1c, 0x1a, 0xcf, 0x04, 0x20, 0x49,
    0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20,
    0x22, 0x74, 0x72, 0x75, 0x65, 0x22, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x65, 0x74, 0x63,
    0x68, 0x65, 0x72, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62,
    0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x2c, 0x0a,
    0x20, 0x66, 0x65, 0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x62, 0x79, 0x70, 0x61, 0x73, 0x73,
    0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63,
    0x74, 0x6c, 0x79, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x61,
    0x6e, 0x64, 0x62, 0x6f, 0x78, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x2c,
    0x20, 0x6e, 0x6f, 0x20, 0x6d, 0x61, 0x74, 0x74, 0x65, 0x72, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68,
    0x65, 0x72, 0x20, 0x61, 0x20, 0x73, 0x75, 0x69, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x63, 0x61,
    0x63, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x61, 0x76, 0x61,
    0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x2e, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x65, 0x72, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74,
    0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x72, 0x20, 0x74, 0x6f,
    0x20, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x2c, 0x20, 0x74, 0x68,
    0x65, 0x6e, 0x20, 0x63, 0x6f, 0x70, 0x79, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65,
    0x72, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f,
    0x78, 0x2e, 0x20, 0x53, 0x75, 0x62, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x74, 0x0a, 0x20, 0x66,
    0x65, 0x74, 0x63, 0x68, 0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x55, 0x52, 0x49, 0x20,
    0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6f, 0x6d, 0x69, 0x74, 0x20, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f,
    0x61, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x63, 0x6f, 0x70, 0x79, 0x0a, 0x20,
    0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x61,
    0x73, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69,
    0x6c, 0x65, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x20, 0x74,
    0x68, 0x65, 0x72, 0x65, 0x2e, 0x20, 0x43, 0x61, 0x63, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6c, 0x65,
    0x73, 0x0a, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x67, 0x65, 0x74, 0x20, 0x65, 0x76, 0x69, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2c, 0x20,
    0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x6c, 0x65, 0x61, 0x64, 0x73,
    0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x6e, 0x65, 0x77, 0x65, 0x64, 0x0a, 0x20, 0x64, 0x6f, 0x77,
    0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x20, 0x53, 0x65, 0x65, 0x20, 0x61, 0x6c,
    0x73, 0x6f, 0x20, 0x22, 0x64, 0x6f, 0x63, 0x73, 0x2f, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x72,
    0x2e, 0x6d, 0x64, 0x22, 0x20, 0x61, 0x6e, 0x64, 0x0a, 0x20, 0x22, 0x64, 0x6f, 0x63, 0x73, 0x2f,
    0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x72, 0x2d, 0x63, 0x61, 0x63, 0x68, 0x65, 0x2d, 0x69, 0x6e,
    0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x73, 0x2e, 0x6d, 0x64, 0x22, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0x98, 0x02, 0x04, 0x0c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0x98, 0x02, 0x0d, 0x11, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0x98, 0x02, 0x12, 0x17,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0x98, 0x02, 0x1a,
    0x1b, 0x0a, 0xb3, 0x03, 0x0a, 0x04, 0x04, 0x0a, 0x03, 0x01, 0x12, 0x06, 0xa4, 0x02, 0x02, 0xaa,
    0x02, 0x03, 0x1a, 0xa2, 0x03, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20,
    0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e, 0x0a, 0x20, 0x4e, 0x6f,
    0x74, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x69,
    0x7a, 0x65, 0x72, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x69,
    0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
    0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2c, 0x20, 0x73, 0x6f, 0x20, 0x69, 0x74, 0x0a, 0x20, 0x69,
    0x73, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x61, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x65, 0x64, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20,
    0x77, 0x69, 0x6c, 0x6c, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x20, 0x64, 0x75, 0x65, 0x20, 0x74, 0x6f,
    0x20, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a,
    0x20, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54,
    0x45, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
    0x69, 0x7a, 0x65, 0x72, 0x20, 0x41, 0x50, 0x49, 0x20, 0x69, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72,
    0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x61, 0x72, 0x6c,
    0x79, 0x20, 0x62, 0x65, 0x74, 0x61, 0x20, 0x6f, 0x72, 0x0a, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x20,
    0x61, 0x6c, 0x70, 0x68, 0x61, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2e, 0x20, 0x53, 0x6f, 0x6d,
    0x65, 0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x2c, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x61, 0x63, 0x74, 0x20, 0x73, 0x65, 0x6d, 0x61, 0x6e, 0x74,
    0x69, 0x63, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x0a, 0x20, 0x22, 0x69, 0x6d, 0x61, 0x67,
    0x65, 0x22, 0x20, 0x6f, 0x72, 0x20, 0x22, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0x20,
    0x61, 0x72, 0x65, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x79, 0x65, 0x74, 0x20, 0x68, 0x61, 0x72, 0x64,
    0x65, 0x6e, 0x65, 0x64, 0x2e, 0x0a, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x74, 0x69, 0x6c, 0x6c,
    0x74, 0x29, 0x3a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x65, 0x78, 0x61, 0x63, 0x74, 0x20, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x73, 0x65, 0x6d, 0x61, 0x6e, 0x74, 0x69, 0x63, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x22,
    0x69, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x0a, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x22, 0x6f, 0x70, 0x74,
    0x69, 0x6f, 0x6e, 0x73, 0x22, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x03, 0x01, 0x01,
    0x12, 0x04, 0xa4, 0x02, 0x0a, 0x17, 0x0a, 0x3a, 0x0a, 0x06, 0x04, 0x0a, 0x03, 0x01, 0x02, 0x00,
    0x12, 0x04, 0xa6, 0x02, 0x04, 0x1e, 0x1a, 0x2a, 0x20, 0x55, 0x52, 0x49, 0x20, 0x64, 0x65, 0x73,
    0x63, 0x72, 0x69, 0x62, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74,
    0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65,
    0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa6,
    0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xa6, 0x02, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xa6, 0x02, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x01, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xa6, 0x02, 0x1c, 0x1d, 0x0a, 0x4b, 0x0a, 0x06, 0x04, 0x0a, 0x03, 0x01, 0x02, 0x01,
    0x12, 0x04, 0xa9, 0x02, 0x04, 0x20, 0x1a, 0x3b, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62,
    0x65, 0x73, 0x20, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x6f, 0x70,
    0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x69, 0x7a, 0x65,
    0x72, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xa9, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xa9, 0x02, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x01, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xa9, 0x02, 0x14, 0x1b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x01, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xa9, 0x02, 0x1e, 0x1f, 0x0a, 0x80, 0x01, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x00,
    0x12, 0x04, 0xae, 0x02, 0x02, 0x27, 0x1a, 0x72, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x4d,
    0x65, 0x73, 0x6f, 0x73, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x69, 0x7a, 0x65,
    0x72, 0x20, 0x64, 0x6f, 0x65, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79,
    0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x0a, 0x20, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x69, 0x6e, 0x67,
    0x20, 0x61, 0x20, 0x27, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x27, 0x20, 0x77,
    0x69, 0x6c, 0x6c, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xae, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x00, 0x06, 0x12, 0x04, 0xae, 0x02, 0x0b, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xae, 0x02, 0x19, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xae, 0x02, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x01, 0x12, 0x04,
    0xb0, 0x02, 0x02, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb0,
    0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x06, 0x12, 0x04, 0xb0, 0x02,
    0x0b, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb0, 0x02, 0x0f,
    0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb0, 0x02, 0x16, 0x17,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x02, 0x12, 0x04, 0xb2, 0x02, 0x02, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0a, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb2, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0a, 0x02, 0x02, 0x06, 0x12, 0x04, 0xb2, 0x02, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0a, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb2, 0x02, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb2, 0x02, 0x25, 0x26, 0x0a, 0xfb, 0x05, 0x0a, 0x04, 0x04,
    0x0a, 0x02, 0x03, 0x12, 0x04, 0xc1, 0x02, 0x02, 0x2b, 0x1a, 0xec, 0x05, 0x20, 0x54, 0x68, 0x65,
    0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x77, 0x6f, 0x20, 0x77, 0x61, 0x79, 0x73, 0x20,
    0x74, 0x6f, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x3a, 0x0a, 0x20, 0x31, 0x29, 0x20, 0x49, 0x66, 0x20, 0x27,
    0x73, 0x68, 0x65, 0x6c, 0x6c, 0x20, 0x3d, 0x3d, 0x20, 0x74, 0x72, 0x75, 0x65, 0x27, 0x2c, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c,
    0x20, 0x62, 0x65, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x65, 0x64, 0x20, 0x76, 0x69, 0x61,
    0x20, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x0a, 0x09, 0x09, 0x28, 0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x20,
    0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x20, 0x2d, 0x63, 0x20, 0x27, 0x76, 0x61, 0x6c, 0x75,
    0x65, 0x27, 0x29, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x27, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x27,
    0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x62, 0x65, 0x0a, 0x09, 0x09, 0x74, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
    0x64, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x27, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74,
    0x73, 0x27, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x69, 0x67, 0x6e, 0x6f, 0x72,
    0x65, 0x64, 0x2e, 0x0a, 0x20, 0x32, 0x29, 0x20, 0x49, 0x66, 0x20, 0x27, 0x73, 0x68, 0x65, 0x6c,
    0x6c, 0x20, 0x3d, 0x3d, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x27, 0x2c, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65,
    0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x70, 0x61, 0x73,
    0x73, 0x69, 0x6e, 0x67, 0x0a, 0x09, 0x09, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73,
    0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c,
    0x65, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x27, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x27, 0x20, 0x73,
    0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65,
    0x0a, 0x09, 0x09, 0x74, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x27, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x27, 0x0a, 0x09, 0x09,
    0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x74, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
    0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73,
    0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62,
    0x6c, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x0a, 0x09, 0x09, 0x73, 0x69,
    0x6d, 0x69, 0x6c, 0x61, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x50, 0x4f, 0x53,
    0x49, 0x58, 0x20, 0x65, 0x78, 0x65, 0x63, 0x20, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x69, 0x65, 0x73,
    0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65,
    0x73, 0x20, 0x28, 0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x0a, 0x09, 0x09, 0x65, 0x78, 0x65, 0x63, 0x6c,
    0x70, 0x28, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2c, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e,
    0x74, 0x73, 0x28, 0x30, 0x29, 0x2c, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73,
    0x28, 0x31, 0x29, 0x2c, 0x20, 0x2e, 0x2e, 0x2e, 0x29, 0x29, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54,
    0x45, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x27, 0x76, 0x61,
    0x6c, 0x75, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x20,
    0x66, 0x72, 0x6f, 0x6d, 0x20, 0x27, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x27, 0x20,
    0x74, 0x6f, 0x20, 0x27, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x27, 0x0a, 0x20, 0x69,
    0x6e, 0x20, 0x30, 0x2e, 0x32, 0x30, 0x2e, 0x30, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x77, 0x69, 0x6c,
    0x6c, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x69, 0x73, 0x73,
    0x75, 0x65, 0x73, 0x20, 0x69, 0x66, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65,
    0x63, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x6c, 0x64, 0x20,
    0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xc1, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xc1, 0x02, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xc1, 0x02, 0x10, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xc1, 0x02, 0x18, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x08, 0x12, 0x04, 0xc1,
    0x02, 0x1a, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x07, 0x12, 0x04, 0xc1, 0x02,
    0x25, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x04, 0x12, 0x04, 0xc2, 0x02, 0x02, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x04, 0xc2, 0x02, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x05, 0x12, 0x04, 0xc2, 0x02, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0xc2, 0x02, 0x12, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x04, 0xc2, 0x02, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x0a, 0x02, 0x05, 0x12, 0x04, 0xc3, 0x02, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x05, 0x04, 0x12, 0x04, 0xc3, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x05, 0x05, 0x12, 0x04, 0xc3, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x05,
    0x01, 0x12, 0x04, 0xc3, 0x02, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x05, 0x03,
    0x12, 0x04, 0xc3, 0x02, 0x1e, 0x1f, 0x0a, 0xb2, 0x01, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x06, 0x12,
    0x04, 0xc8, 0x02, 0x02, 0x1b, 0x1a, 0xa3, 0x01, 0x20, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x73,
    0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x61,
    0x73, 0x6b, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20,
    0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x20, 0x49,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x0a, 0x20, 0x66, 0x69, 0x65, 0x6c,
    0x64, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x6f, 0x74,
    0x68, 0x20, 0x69, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e,
    0x66, 0x6f, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x68, 0x65, 0x72, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x0a, 0x20, 0x75, 0x73,
    0x65, 0x72, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x73, 0x20, 0x70,
    0x72, 0x65, 0x63, 0x65, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x06, 0x04, 0x12, 0x04, 0xc8, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x06, 0x05, 0x12, 0x04, 0xc8, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x06, 0x01, 0x12, 0x04, 0xc8, 0x02, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x06,
    0x03, 0x12, 0x04, 0xc8, 0x02, 0x19, 0x1a, 0x0a, 0x80, 0x01, 0x0a, 0x02, 0x04, 0x0b, 0x12, 0x06,
    0xd0, 0x02, 0x00, 0xe9, 0x02, 0x01, 0x1a, 0x72, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72,
    0x69, 0x62, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x27, 0x64, 0x61, 0x74, 0x61, 0x27, 0x20, 0x66,
    0x69, 0x65, 0x6c, 0x64, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x75, 0x73, 0x65,
    0x64, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x61, 0x72, 0x62, 0x69, 0x74, 0x72,
    0x61, 0x72, 0x79, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0b,
    0x01, 0x12, 0x04, 0xd0, 0x02, 0x08, 0x14, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x00, 0x12,
    0x04, 0xd1, 0x02, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xd1, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd1,
    0x02, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd1, 0x02,
    0x16, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd1, 0x02, 0x24,
    0x25, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x01, 0x12, 0x04, 0xd2, 0x02, 0x02, 0x28, 0x22,
    0x21, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x62, 0x65, 0x6e, 0x68, 0x29, 0x3a, 0x20, 0x4d, 0x61,
    0x6b, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd2, 0x02, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x06, 0x12, 0x04, 0xd2, 0x02, 0x0b, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd2, 0x02, 0x17, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd2, 0x02, 0x26, 0x27, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x0b, 0x02, 0x02, 0x12, 0x04, 0xd3, 0x02, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd3, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0b, 0x02, 0x02, 0x06, 0x12, 0x04, 0xd3, 0x02, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xd3, 0x02, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xd3, 0x02, 0x21, 0x22, 0x0a, 0xa7, 0x01, 0x0a, 0x04, 0x04, 0x0b, 0x02,
    0x03, 0x12, 0x04, 0xd7, 0x02, 0x02, 0x28, 0x1a, 0x98, 0x01, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74,
    0x68, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x77, 0x69,
    0x6c, 0x6c, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f,
    0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x0a, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x27, 0x73, 0x20, 0x43, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x65, 0x20,
    0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x61, 0x63, 0x74, 0x20, 0x61, 0x73, 0x20,
    0x61, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x04, 0x12, 0x04, 0xd7, 0x02, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x06, 0x12, 0x04, 0xd7, 0x02, 0x0b, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd7, 0x02, 0x19, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd7, 0x02, 0x25, 0x27, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x0b, 0x02, 0x04, 0x12, 0x04, 0xd8, 0x02, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd8, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0b, 0x02, 0x04, 0x06, 0x12, 0x04, 0xd8, 0x02, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xd8, 0x02, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xd8, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x05,
    0x12, 0x04, 0xd9, 0x02, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x05, 0x04, 0x12,
    0x04, 0xd9, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x05, 0x05, 0x12, 0x04,
    0xd9, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x05, 0x01, 0x12, 0x04, 0xd9,
    0x02, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x05, 0x03, 0x12, 0x04, 0xd9, 0x02,
    0x19, 0x1a, 0x0a, 0x80, 0x03, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x06, 0x12, 0x04, 0xe1, 0x02, 0x02,
    0x1e, 0x1a, 0xf1, 0x02, 0x20, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61,
    0x6e, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0x73, 0x74, 0x79,
    0x6c, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62,
    0x79, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x74, 0x6f, 0x20,
    0x74, 0x72, 0x61, 0x63, 0x6b, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72,
    0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x66, 0x75, 0x6c,
    0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x27, 0x73, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69,
    0x62, 0x6c, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x0a, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65,
    0x6e, 0x74, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x69, 0x64, 0x73, 0x20,
    0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x20, 0x73, 0x65,
    0x6d, 0x61, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54,
    0x45, 0x3a, 0x20, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x65, 0x78, 0x70,
    0x6f, 0x73, 0x65, 0x64, 0x20, 0x61, 0x6c, 0x6f, 0x6e, 0x67, 0x73, 0x69, 0x64, 0x65, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x20, 0x76, 0x69, 0x61, 0x20, 0x4a, 0x53, 0x4f, 0x4e, 0x20, 0x6f, 0x6e, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x61,
    0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x75, 0x73, 0x65, 0x72, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x69,
    0x6d, 0x70, 0x6f, 0x72, 0x74, 0x0a, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x20, 0x69, 0x6e, 0x66,
    0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20, 0x61, 0x20,
    0x74, 0x69, 0x6d, 0x65, 0x20, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x20, 0x64, 0x61, 0x74, 0x61,
    0x62, 0x61, 0x73, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x6e, 0x69, 0x74, 0x6f, 0x72,
    0x69, 0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x06, 0x04, 0x12, 0x04,
    0xe1, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x06, 0x05, 0x12, 0x04, 0xe1,
    0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x06, 0x01, 0x12, 0x04, 0xe1, 0x02,
    0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x06, 0x03, 0x12, 0x04, 0xe1, 0x02, 0x1b,
    0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x07, 0x12, 0x04, 0xe2, 0x02, 0x02, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x07, 0x04, 0x12, 0x04, 0xe2, 0x02, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0b, 0x02, 0x07, 0x05, 0x12, 0x04, 0xe2, 0x02, 0x0b, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0b, 0x02, 0x07, 0x01, 0x12, 0x04, 0xe2, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x07, 0x03, 0x12, 0x04, 0xe2, 0x02, 0x18, 0x19, 0x0a, 0xf9, 0x01, 0x0a, 0x04,
    0x04, 0x0b, 0x02, 0x08, 0x12, 0x04, 0xe8, 0x02, 0x02, 0x28, 0x1a, 0xea, 0x01, 0x20, 0x53, 0x65,
    0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20,
    0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x20, 0x49, 0x74,
    0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x0a, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x72,
    0x65, 0x74, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70,
    0x6f, 0x6e, 0x20, 0x62, 0x79, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x20, 0x49, 0x74, 0x20,
    0x69, 0x73, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69,
    0x63, 0x65, 0x0a, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x73, 0x79,
    0x73, 0x74, 0x65, 0x6d, 0x20, 0x74, 0x6f, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x73, 0x20,
    0x6e, 0x65, 0x65, 0x64, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x68, 0x61,
    0x6e, 0x64, 0x6c, 0x65, 0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x20,
    0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20,
    0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x08, 0x04,
    0x12, 0x04, 0xe8, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x08, 0x06, 0x12,
    0x04, 0xe8, 0x02, 0x0b, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x08, 0x01, 0x12, 0x04,
    0xe8, 0x02, 0x19, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x08, 0x03, 0x12, 0x04, 0xe8,
    0x02, 0x25, 0x27, 0x0a, 0xa9, 0x01, 0x0a, 0x02, 0x04, 0x0c, 0x12, 0x06, 0xf1, 0x02, 0x00, 0x90,
    0x03, 0x01, 0x1a, 0x9a, 0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65,
    0x73, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73,
    0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x70, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x6c, 0x79, 0x20, 0x68,
    0x61, 0x76, 0x65, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20,
    0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x20, 0x77,
    0x68, 0x69, 0x63, 0x68, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73,
    0x65, 0x64, 0x2c, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2c,
    0x20, 0x74, 0x6f, 0x20, 0x6c, 0x69, 0x6e, 0x6b, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x20, 0x77, 0x65, 0x62, 0x75, 0x69, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x61,
    0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x77, 0x65, 0x62, 0x75, 0x69, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x0c, 0x01, 0x12, 0x04, 0xf1, 0x02, 0x08, 0x12, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x0c, 0x02, 0x00, 0x12, 0x04, 0xf2, 0x02, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xf2, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xf2, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xf2, 0x02, 0x12, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xf2, 0x02, 0x17, 0x18, 0x0a, 0x88, 0x01, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x01, 0x12,
    0x04, 0xf6, 0x02, 0x02, 0x19, 0x1a, 0x7a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x49, 0x50, 0x20, 0x61,
    0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x28, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x49, 0x50, 0x76,
    0x34, 0x29, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x64, 0x20, 0x34,
    0x2d, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2c, 0x0a,
    0x20, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f,
    0x72, 0x6b, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x2e, 0x20, 0x20, 0x44, 0x65, 0x70, 0x72, 0x65,
    0x63, 0x61, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x75, 0x73, 0x65, 0x20, 0x60, 0x61, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x2e, 0x69, 0x70, 0x60, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf6, 0x02, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf6, 0x02, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf6, 0x02, 0x12, 0x14, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf6, 0x02, 0x17, 0x18, 0x0a, 0x7c, 0x0a,
    0x04, 0x04, 0x0c, 0x02, 0x02, 0x12, 0x04, 0xfa, 0x02, 0x02, 0x2c, 0x1a, 0x6e, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x54, 0x43, 0x50, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4d,
    0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x69,
    0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69,
    0x6e, 0x67, 0x0a, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x73, 0x3b, 0x20, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x75,
    0x73, 0x65, 0x20, 0x60, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x6f, 0x72, 0x74,
    0x60, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0c, 0x02, 0x02, 0x04, 0x12, 0x04, 0xfa, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xfa, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xfa, 0x02, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xfa, 0x02, 0x19, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x08,
    0x12, 0x04, 0xfa, 0x02, 0x1b, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x07, 0x12,
    0x04, 0xfa, 0x02, 0x26, 0x2a, 0x0a, 0xfa, 0x01, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x03, 0x12, 0x04,
    0x80, 0x03, 0x02, 0x1a, 0x1a, 0xeb, 0x01, 0x20, 0x49, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64,
    0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c,
    0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20, 0x62, 0x6f, 0x74, 0x68,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2c,
    0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72,
    0x20, 0x6e, 0x61, 0x6d, 0x65, 0x3b, 0x20, 0x69, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64,
    0x20, 0x72, 0x65, 0x61, 0x6c, 0x6c, 0x79, 0x0a, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20,
    0x72, 0x65, 0x6c, 0x69, 0x65, 0x64, 0x20, 0x75, 0x70, 0x6f, 0x6e, 0x20, 0x62, 0x79, 0x20, 0x65,
    0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x20, 0x74, 0x6f, 0x6f, 0x6c, 0x69, 0x6e, 0x67, 0x2f,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x62,
    0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x6e,
    0x20, 0x22, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x22, 0x20, 0x69, 0x6d, 0x70, 0x6c,
    0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x04, 0x12, 0x04, 0x80, 0x03, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x05, 0x12, 0x04, 0x80, 0x03, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x01, 0x12, 0x04, 0x80, 0x03, 0x12, 0x15, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x03, 0x12, 0x04, 0x80, 0x03, 0x18, 0x19, 0x0a, 0xec,
    0x01, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x04, 0x12, 0x04, 0x86, 0x03, 0x02, 0x1f, 0x1a, 0xdd, 0x01,
    0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x27, 0x73, 0x20, 0x68, 0x6f,
    0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c,
    0x61, 0x62, 0x6c, 0x65, 0x3b, 0x20, 0x69, 0x74, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20,
    0x75, 0x6e, 0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x0a, 0x20, 0x69, 0x6e, 0x20, 0x65,
    0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x77, 0x68, 0x65, 0x72,
    0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x44, 0x4e, 0x53, 0x20, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
    0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x64, 0x6f, 0x65, 0x73, 0x20, 0x6e, 0x6f, 0x74,
    0x20, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x0a, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e,
    0x61, 0x6c, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x28, 0x65, 0x67,
    0x2c, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x63, 0x6c,
    0x6f, 0x75, 0x64, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x73, 0x29, 0x2e, 0x0a,
    0x20, 0x44, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x75, 0x73, 0x65,
    0x20, 0x60, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2e, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61,
    0x6d, 0x65, 0x60, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x04, 0x04, 0x12, 0x04, 0x86, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x04, 0x05, 0x12, 0x04, 0x86, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0c, 0x02, 0x04, 0x01, 0x12, 0x04, 0x86, 0x03, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x04, 0x03, 0x12, 0x04, 0x86, 0x03, 0x1d, 0x1e, 0x0a, 0x68, 0x0a, 0x04, 0x04, 0x0c, 0x02,
    0x05, 0x12, 0x04, 0x8a, 0x03, 0x02, 0x1e, 0x1a, 0x5a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x75,
    0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x76, 0x65, 0x72,
    0x73, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e,
    0x67, 0x3b, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x6e, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68,
    0x65, 0x0a, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x22, 0x6d, 0x61,
    0x73, 0x74, 0x65, 0x72, 0x2f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x68, 0x70, 0x70,
    0x22, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x04, 0x12, 0x04, 0x8a, 0x03,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x05, 0x12, 0x04, 0x8a, 0x03, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x01, 0x12, 0x04, 0x8a, 0x03, 0x12, 0x19,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x03, 0x12, 0x04, 0x8a, 0x03, 0x1c, 0x1d, 0x0a,
    0x95, 0x01, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x06, 0x12, 0x04, 0x8f, 0x03, 0x02, 0x1f, 0x1a, 0x86,
    0x01, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6c, 0x6c, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x28, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x20,
    0x62, 0x6f, 0x74, 0x68, 0x20, 0x49, 0x50, 0x76, 0x34, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x49, 0x50,
    0x76, 0x36, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x73, 0x29, 0x0a, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x73, 0x75, 0x70, 0x65, 0x72, 0x73, 0x65, 0x64, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x60, 0x69, 0x70, 0x60, 0x2c, 0x20, 0x60, 0x70, 0x6f,
    0x72, 0x74, 0x60, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x60, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d,
    0x65, 0x60, 0x2e, 0x0a, 0x20, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73,
    0x20, 0x30, 0x2e, 0x32, 0x34, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x04,
    0x12, 0x04, 0x8f, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x06, 0x12,
    0x04, 0x8f, 0x03, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x01, 0x12, 0x04,
    0x8f, 0x03, 0x13, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x03, 0x12, 0x04, 0x8f,
    0x03, 0x1d, 0x1e, 0x0a, 0xd5, 0x02, 0x0a, 0x02, 0x04, 0x0d, 0x12, 0x06, 0x9a, 0x03, 0x00, 0xa3,
    0x03, 0x01, 0x1a, 0xc6, 0x02, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65,
    0x73, 0x20, 0x61, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x2e, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x69, 0x64, 0x27, 0x20, 0x66, 0x69,
    0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x61, 0x76, 0x61, 0x69,
    0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x0a, 0x20, 0x61, 0x20, 0x73,
    0x6c, 0x61, 0x76, 0x65, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,
    0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74,
    0x65, 0x72, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65, 0x20,
    0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x68, 0x65, 0x72, 0x65, 0x0a, 0x20,
    0x74, 0x6f, 0x20, 0x66, 0x61, 0x63, 0x69, 0x6c, 0x69, 0x74, 0x61, 0x74, 0x65, 0x20, 0x72, 0x65,
    0x2d, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x20,
    0x49, 0x66, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x69, 0x73,
    0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x20,
    0x69, 0x73, 0x0a, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e,
    0x67, 0x20, 0x69, 0x74, 0x73, 0x20, 0x6f, 0x77, 0x6e, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x70, 0x6f, 0x74, 0x65, 0x6e, 0x74,
    0x69, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73,
    0x27, 0x0a, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28,
    0x69, 0x66, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x68,
    0x61, 0x73, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e, 0x67,
    0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x29, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x0d, 0x01, 0x12, 0x04, 0x9a, 0x03, 0x08, 0x11, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x00,
    0x12, 0x04, 0x9b, 0x03, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x9b, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x05, 0x12, 0x04,
    0x9b, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9b,
    0x03, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9b, 0x03,
    0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x01, 0x12, 0x04, 0x9c, 0x03, 0x02, 0x2b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9c, 0x03, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x05, 0x12, 0x04, 0x9c, 0x03, 0x0b, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x01, 0x12, 0x04, 0x9c, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x01, 0x03, 0x12, 0x04, 0x9c, 0x03, 0x18, 0x19, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x01, 0x08, 0x12, 0x04, 0x9c, 0x03, 0x1a, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x01, 0x07, 0x12, 0x04, 0x9c, 0x03, 0x25, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d,
    0x02, 0x02, 0x12, 0x04, 0x9d, 0x03, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02,
    0x04, 0x12, 0x04, 0x9d, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x06,
    0x12, 0x04, 0x9d, 0x03, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x01, 0x12,
    0x04, 0x9d, 0x03, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x9d, 0x03, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x03, 0x12, 0x04, 0x9e, 0x03,
    0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x04, 0x12, 0x04, 0x9e, 0x03, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x06, 0x12, 0x04, 0x9e, 0x03, 0x0b, 0x14,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9e, 0x03, 0x15, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x03, 0x12, 0x04, 0x9e, 0x03, 0x22, 0x23, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x0d, 0x02, 0x04, 0x12, 0x04, 0x9f, 0x03, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x04, 0x04, 0x12, 0x04, 0x9f, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x04, 0x06, 0x12, 0x04, 0x9f, 0x03, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x04, 0x01, 0x12, 0x04, 0x9f, 0x03, 0x13, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x04, 0x03, 0x12, 0x04, 0x9f, 0x03, 0x18, 0x19, 0x0a, 0x82, 0x01, 0x0a, 0x04, 0x04, 0x0d, 0x02,
    0x05, 0x12, 0x04, 0xa2, 0x03, 0x02, 0x31, 0x1a, 0x74, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x6a,
    0x6f, 0x65, 0x72, 0x67, 0x38, 0x34, 0x29, 0x3a, 0x20, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x20,
    0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64,
    0x20, 0x61, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x30, 0x2e, 0x32, 0x32, 0x2e, 0x30, 0x0a,
    0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e,
    0x74, 0x69, 0x6e, 0x67, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x73, 0x20, 0x28,
    0x4d, 0x45, 0x53, 0x4f, 0x53, 0x2d, 0x32, 0x33, 0x31, 0x37, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x05, 0x04, 0x12, 0x04, 0xa2, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x05, 0x05, 0x12, 0x04, 0xa2, 0x03, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x05, 0x01, 0x12, 0x04, 0xa2, 0x03, 0x10, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x05, 0x03, 0x12, 0x04, 0xa2, 0x03, 0x1d, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x05, 0x08, 0x12, 0x04, 0xa2, 0x03, 0x1f, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05,
    0x07, 0x12, 0x04, 0xa2, 0x03, 0x2a, 0x2f, 0x0a, 0x85, 0x01, 0x0a, 0x02, 0x04, 0x0e, 0x12, 0x06,
    0xaa, 0x03, 0x00, 0xcc, 0x03, 0x01, 0x1a, 0x77, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72,
    0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74,
    0x65, 0x20, 0x6f, 0x72, 0x20, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x22, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x22, 0x2e, 0x20, 0x41, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x69,
    0x73, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x64, 0x0a, 0x20, 0x75, 0x73, 0x69,
    0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x20,
    0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20,
    0x22, 0x75, 0x6e, 0x69, 0x6f, 0x6e, 0x22, 0x20, 0x74, 0x72, 0x69, 0x63, 0x6b, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x0e, 0x01, 0x12, 0x04, 0xaa, 0x03, 0x08, 0x0d, 0x0a, 0x0e, 0x0a, 0x04,
    0x04, 0x0e, 0x04, 0x00, 0x12, 0x06, 0xab, 0x03, 0x02, 0xb0, 0x03, 0x03, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x04, 0x00, 0x01, 0x12, 0x04, 0xab, 0x03, 0x07, 0x0b, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x0e, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xac, 0x03, 0x04, 0x0f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0e, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xac, 0x03, 0x04, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0e, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xac, 0x03, 0x0d, 0x0e, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x0e, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xad, 0x03, 0x04, 0x0f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0e, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xad, 0x03, 0x04, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0e, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xad, 0x03, 0x0d, 0x0e, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x0e, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xae, 0x03, 0x04, 0x0c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xae, 0x03, 0x04, 0x07,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04, 0xae, 0x03, 0x0a,
    0x0b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0e, 0x04, 0x00, 0x02, 0x03, 0x12, 0x04, 0xaf, 0x03, 0x04,
    0x0d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xaf, 0x03,
    0x04, 0x08, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x04, 0x00, 0x02, 0x03, 0x02, 0x12, 0x04, 0xaf,
    0x03, 0x0b, 0x0c, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0e, 0x03, 0x00, 0x12, 0x06, 0xb2, 0x03, 0x02,
    0xb4, 0x03, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x03, 0x00, 0x01, 0x12, 0x04, 0xb2, 0x03,
    0x0a, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb3, 0x03,
    0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb3,
    0x03, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xb3, 0x03, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xb3, 0x03, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xb3, 0x03, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0e, 0x03, 0x01, 0x12, 0x06,
    0xb6, 0x03, 0x02, 0xb9, 0x03, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x03, 0x01, 0x01, 0x12,
    0x04, 0xb6, 0x03, 0x0a, 0x0f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0e, 0x03, 0x01, 0x02, 0x00, 0x12,
    0x04, 0xb7, 0x03, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x01, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xb7, 0x03, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x01, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xb7, 0x03, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x01, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xb7, 0x03, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x01,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xb7, 0x03, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0e, 0x03,
    0x01, 0x02, 0x01, 0x12, 0x04, 0xb8, 0x03, 0x04, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03,
    0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb8, 0x03, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e,
    0x03, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb8, 0x03, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0e, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb8, 0x03, 0x14, 0x17, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0e, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb8, 0x03, 0x1a, 0x1b, 0x0a, 0x0e, 0x0a,
    0x04, 0x04, 0x0e, 0x03, 0x02, 0x12, 0x06, 0xbb, 0x03, 0x02, 0xbd, 0x03, 0x03, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0e, 0x03, 0x02, 0x01, 0x12, 0x04, 0xbb, 0x03, 0x0a, 0x10, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x0e, 0x03, 0x02, 0x02, 0x00, 0x12, 0x04, 0xbc, 0x03, 0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0e, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbc, 0x03, 0x04, 0x0c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0e, 0x03, 0x02, 0x02, 0x00, 0x06, 0x12, 0x04, 0xbc, 0x03, 0x0d, 0x12, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0e, 0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbc, 0x03, 0x13, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbc, 0x03, 0x1b, 0x1c,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0e, 0x03, 0x03, 0x12, 0x06, 0xbf, 0x03, 0x02, 0xc1, 0x03, 0x03,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x03, 0x03, 0x01, 0x12, 0x04, 0xbf, 0x03, 0x0a, 0x0d, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x0e, 0x03, 0x03, 0x02, 0x00, 0x12, 0x04, 0xc0, 0x03, 0x04, 0x1d, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc0, 0x03, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x03, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc0, 0x03, 0x0d,
    0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc0, 0x03,
    0x14, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x03, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc0,
    0x03, 0x1b, 0x1c, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0e, 0x03, 0x04, 0x12, 0x06, 0xc3, 0x03, 0x02,
    0xc5, 0x03, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x03, 0x04, 0x01, 0x12, 0x04, 0xc3, 0x03,
    0x0a, 0x0e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0e, 0x03, 0x04, 0x02, 0x00, 0x12, 0x04, 0xc4, 0x03,
    0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x04, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc4,
    0x03, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x04, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xc4, 0x03, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x04, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xc4, 0x03, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x04, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xc4, 0x03, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x00, 0x12, 0x04,
    0xc7, 0x03, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc7,
    0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc7, 0x03,
    0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc7, 0x03, 0x10,
    0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc7, 0x03, 0x17, 0x18,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x01, 0x12, 0x04, 0xc8, 0x03, 0x02, 0x1d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc8, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0e, 0x02, 0x01, 0x06, 0x12, 0x04, 0xc8, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc8, 0x03, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc8, 0x03, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e,
    0x02, 0x02, 0x12, 0x04, 0xc9, 0x03, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xc9, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02, 0x06,
    0x12, 0x04, 0xc9, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xc9, 0x03, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xc9, 0x03, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x03, 0x12, 0x04, 0xca, 0x03,
    0x02, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x04, 0x12, 0x04, 0xca, 0x03, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x06, 0x12, 0x04, 0xca, 0x03, 0x0b, 0x0e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x01, 0x12, 0x04, 0xca, 0x03, 0x0f, 0x12, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x03, 0x12, 0x04, 0xca, 0x03, 0x15, 0x16, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x0e, 0x02, 0x04, 0x12, 0x04, 0xcb, 0x03, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x04, 0x04, 0x12, 0x04, 0xcb, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0e, 0x02, 0x04, 0x06, 0x12, 0x04, 0xcb, 0x03, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xcb, 0x03, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xcb, 0x03, 0x17, 0x18, 0x0a, 0xd3, 0x01, 0x0a, 0x02, 0x04, 0x0f, 0x12,
    0x06, 0xd4, 0x03, 0x00, 0xdb, 0x03, 0x01, 0x1a, 0xc4, 0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73,
    0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62,
    0x75, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20,
    0x73, 0x65, 0x74, 0x20, 0x6f, 0x6e, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
    0x2e, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x77, 0x2c, 0x0a, 0x20, 0x61, 0x74, 0x74, 0x72,
    0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x73, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x61, 0x6d, 0x65, 0x20, 0x22, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x20, 0x74, 0x79, 0x70, 0x65,
    0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x0a, 0x20,
    0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75,
    0x74, 0x75, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75,
    0x74, 0x65, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x62, 0x65, 0x20,
    0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x62, 0x61, 0x73, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x0f, 0x01, 0x12, 0x04, 0xd4, 0x03, 0x08, 0x11, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0f, 0x02, 0x00, 0x12, 0x04, 0xd5, 0x03, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xd5, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xd5, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xd5, 0x03, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xd5, 0x03, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x01, 0x12, 0x04, 0xd6,
    0x03, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd6, 0x03,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x06, 0x12, 0x04, 0xd6, 0x03, 0x0b,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd6, 0x03, 0x16, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd6, 0x03, 0x1d, 0x1e, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x02, 0x12, 0x04, 0xd7, 0x03, 0x02, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd7, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x02, 0x06, 0x12, 0x04, 0xd7, 0x03, 0x0b, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0f, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd7, 0x03, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xd7, 0x03, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02,
    0x03, 0x12, 0x04, 0xd8, 0x03, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03, 0x04,
    0x12, 0x04, 0xd8, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03, 0x06, 0x12,
    0x04, 0xd8, 0x03, 0x0b, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xd8, 0x03, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd8,
    0x03, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x04, 0x12, 0x04, 0xd9, 0x03, 0x02,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd9, 0x03, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x04, 0x06, 0x12, 0x04, 0xd9, 0x03, 0x0b, 0x14, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd9, 0x03, 0x15, 0x18, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0f, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd9, 0x03, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x0f, 0x02, 0x05, 0x12, 0x04, 0xda, 0x03, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0f, 0x02, 0x05, 0x04, 0x12, 0x04, 0xda, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f,
    0x02, 0x05, 0x06, 0x12, 0x04, 0xda, 0x03, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02,
    0x05, 0x01, 0x12, 0x04, 0xda, 0x03, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x05,
    0x03, 0x12, 0x04, 0xda, 0x03, 0x1d, 0x1e, 0x0a, 0xed, 0x02, 0x0a, 0x02, 0x04, 0x10, 0x12, 0x06,
    0xe7, 0x03, 0x00, 0xb0, 0x04, 0x01, 0x1a, 0xde, 0x02, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63,
    0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x20, 0x6f, 0x6e, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2e, 0x20, 0x41,
    0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x74, 0x61,
    0x6b, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x6f, 0x66, 0x0a, 0x20, 0x74, 0x68,
    0x72, 0x65, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x3a, 0x20, 0x73, 0x63, 0x61, 0x6c, 0x61,
    0x72, 0x20, 0x28, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x29, 0x2c, 0x20, 0x61, 0x20, 0x6c, 0x69,
    0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x65, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x64, 0x69, 0x73, 0x63, 0x72, 0x65, 0x74, 0x65, 0x20, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73,
    0x0a, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x5b, 0x31, 0x2d, 0x31, 0x30, 0x2c, 0x20,
    0x32, 0x30, 0x2d, 0x33, 0x30, 0x5d, 0x29, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x73, 0x65,
    0x74, 0x20, 0x6f, 0x66, 0x20, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x2e, 0x20, 0x41, 0x20, 0x72, 0x65,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
    0x62, 0x65, 0x64, 0x0a, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
    0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x22, 0x75, 0x6e, 0x69, 0x6f, 0x6e, 0x22, 0x20,
    0x74, 0x72, 0x69, 0x63, 0x6b, 0x2e, 0x0a, 0x0a, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x62, 0x65,
    0x6e, 0x68, 0x29, 0x3a, 0x20, 0x41, 0x64, 0x64, 0x20, 0x62, 0x65, 0x74, 0x74, 0x65, 0x72, 0x20,
    0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x22, 0x65, 0x78, 0x70,
    0x65, 0x63, 0x74, 0x65, 0x64, 0x22, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73,
    0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x0a, 0x20, 0x63, 0x70, 0x75, 0x73, 0x2c, 0x20, 0x6d,
    0x65, 0x6d, 0x6f, 0x72, 0x79, 0x2c, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x2c, 0x20, 0x6e, 0x65, 0x74,
    0x77, 0x6f, 0x72, 0x6b, 0x29, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x10, 0x01, 0x12, 0x04,
    0xe7, 0x03, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x00, 0x12, 0x04, 0xe8, 0x03,
    0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe8, 0x03, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe8, 0x03, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe8, 0x03, 0x12, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe8, 0x03, 0x19, 0x1a, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x10, 0x02, 0x01, 0x12, 0x04, 0xe9, 0x03, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x10, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe9, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x10, 0x02, 0x01, 0x06, 0x12, 0x04, 0xe9, 0x03, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xe9, 0x03, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xe9, 0x03, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x02,
    0x12, 0x04, 0xea, 0x03, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xea, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x06, 0x12, 0x04,
    0xea, 0x03, 0x0b, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x01, 0x12, 0x04, 0xea,
    0x03, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x03, 0x12, 0x04, 0xea, 0x03,
    0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x03, 0x12, 0x04, 0xeb, 0x03, 0x02, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x03, 0x04, 0x12, 0x04, 0xeb, 0x03, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x03, 0x06, 0x12, 0x04, 0xeb, 0x03, 0x0b, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x10, 0x02, 0x03, 0x01, 0x12, 0x04, 0xeb, 0x03, 0x18, 0x1e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x03, 0x03, 0x12, 0x04, 0xeb, 0x03, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x10, 0x02, 0x04, 0x12, 0x04, 0xec, 0x03, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x04, 0x04, 0x12, 0x04, 0xec, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02,
    0x04, 0x06, 0x12, 0x04, 0xec, 0x03, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x04,
    0x01, 0x12, 0x04, 0xec, 0x03, 0x15, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x04, 0x03,
    0x12, 0x04, 0xec, 0x03, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x05, 0x12, 0x04,
    0xed, 0x03, 0x02, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x04, 0x12, 0x04, 0xed,
    0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x05, 0x12, 0x04, 0xed, 0x03,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x01, 0x12, 0x04, 0xed, 0x03, 0x12,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x03, 0x12, 0x04, 0xed, 0x03, 0x19, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x08, 0x12, 0x04, 0xed, 0x03, 0x1b, 0x2a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x07, 0x12, 0x04, 0xed, 0x03, 0x26, 0x29, 0x0a, 0xbf,
    0x02, 0x0a, 0x04, 0x04, 0x10, 0x03, 0x00, 0x12, 0x06, 0xef, 0x03, 0x02, 0xfe, 0x03, 0x03, 0x22,
    0xae, 0x02, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x64,
    0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x2e, 0x20, 0x41, 0x20, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x20, 0x72, 0x65,
    0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x61, 0x63,
    0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x70, 0x65,
    0x72, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x76, 0x69, 0x61, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x2f,
    0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x27, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x65, 0x6e,
    0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x62, 0x79, 0x0a, 0x20, 0x61, 0x20,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x76, 0x69, 0x61, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x20, 0x62, 0x79,
    0x20, 0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x20, 0x61, 0x6e,
    0x0a, 0x20, 0x27, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x3a, 0x3a, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x3a, 0x3a, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x27, 0x20, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x57, 0x65,
    0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x64, 0x6f, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x72, 0x6f, 0x6c, 0x65, 0x20, 0x22, 0x2a, 0x22,
    0x20, 0x74, 0x6f, 0x0a, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69,
    0x63, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x03, 0x00, 0x01, 0x12, 0x04, 0xef, 0x03, 0x0a, 0x19, 0x0a,
    0xec, 0x02, 0x0a, 0x06, 0x04, 0x10, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xfd, 0x03, 0x04, 0x22,
    0x1a, 0xdb, 0x02, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69,
    0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x69,
    0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x70,
    0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x6f, 0x72, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77,
    0x6f, 0x72, 0x6b, 0x0a, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x64, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20,
    0x63, 0x6f, 0x6e, 0x6a, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x22, 0x75, 0x6e, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x22, 0x20, 0x41, 0x43, 0x4c, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69,
    0x6e, 0x65, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65,
    0x6e, 0x74, 0x69, 0x74, 0x79, 0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x6e, 0x67,
    0x20, 0x74, 0x6f, 0x0a, 0x20, 0x75, 0x6e, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20,
    0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x6f, 0x20,
    0x73, 0x6f, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6d, 0x61, 0x74,
    0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b,
    0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x20, 0x6f,
    0x66, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x10, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfd, 0x03, 0x04, 0x0c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xfd, 0x03, 0x0d, 0x13,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfd, 0x03, 0x14,
    0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xfd, 0x03,
    0x20, 0x21, 0x0a, 0xd6, 0x01, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x06, 0x12, 0x04, 0x83, 0x04, 0x02,
    0x2b, 0x1a, 0xc7, 0x01, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
    0x73, 0x65, 0x74, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x20, 0x77, 0x61, 0x73, 0x20, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x61, 0x6c,
    0x6c, 0x79, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61,
    0x6e, 0x0a, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x6f, 0x72, 0x20, 0x61,
    0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x20, 0x4f, 0x74, 0x68, 0x65,
    0x72, 0x77, 0x69, 0x73, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x75,
    0x6e, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x0a, 0x20, 0x6f, 0x72, 0x20, 0x73, 0x74,
    0x61, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72,
    0x20, 0x76, 0x69, 0x61, 0x20, 0x74, 0x68, 0x65, 0x20, 0x2d, 0x2d, 0x72, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x73, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x10, 0x02, 0x06, 0x04, 0x12, 0x04, 0x83, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x06, 0x06, 0x12, 0x04, 0x83, 0x04, 0x0b, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02,
    0x06, 0x01, 0x12, 0x04, 0x83, 0x04, 0x1b, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x06,
    0x03, 0x12, 0x04, 0x83, 0x04, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x10, 0x03, 0x01, 0x12,
    0x06, 0x85, 0x04, 0x02, 0xa3, 0x04, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x03, 0x01, 0x01,
    0x12, 0x04, 0x85, 0x04, 0x0a, 0x12, 0x0a, 0x81, 0x05, 0x0a, 0x06, 0x04, 0x10, 0x03, 0x01, 0x03,
    0x00, 0x12, 0x06, 0x91, 0x04, 0x04, 0x95, 0x04, 0x05, 0x1a, 0xee, 0x04, 0x20, 0x44, 0x65, 0x73,
    0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74,
    0x65, 0x6e, 0x74, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x2e,
    0x0a, 0x20, 0x41, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x64,
    0x69, 0x73, 0x6b, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x69, 0x63,
    0x61, 0x6c, 0x6c, 0x79, 0x20, 0x67, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x0a, 0x20, 0x63, 0x6f,
    0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74,
    0x61, 0x73, 0x6b, 0x2f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2f, 0x73, 0x6c, 0x61,
    0x76, 0x65, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x62,
    0x75, 0x74, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x72, 0x65, 0x2d, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x65,
    0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x28, 0x73, 0x29, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x6e, 0x67, 0x20,
    0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x72, 0x6f, 0x6c, 0x65, 0x27, 0x2e, 0x0a, 0x20,
    0x41, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x63, 0x61, 0x6e, 0x20,
    0x73, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x49, 0x44, 0x20, 0x28, 0x69, 0x66, 0x20, 0x69,
    0x74, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x65, 0x74, 0x20, 0x79, 0x65, 0x74,
    0x29, 0x20, 0x74, 0x6f, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x0a, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x63,
    0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x70, 0x65, 0x72, 0x73,
    0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x76, 0x6f, 0x6c, 0x75,
    0x6d, 0x65, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x0a, 0x20, 0x72, 0x65, 0x67, 0x75, 0x6c,
    0x61, 0x72, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x2e, 0x20, 0x54, 0x6f, 0x20, 0x72, 0x65, 0x75, 0x73, 0x65, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65,
    0x76, 0x69, 0x6f, 0x75, 0x73, 0x6c, 0x79, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
    0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x2c, 0x20, 0x61, 0x0a, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x20,
    0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20,
    0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x73,
    0x20, 0x61, 0x6e, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x0a, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20,
    0x61, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x76, 0x6f, 0x6c,
    0x75, 0x6d, 0x65, 0x2c, 0x20, 0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x20, 0x49, 0x44, 0x20, 0x69, 0x73,
    0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x43, 0x75, 0x72,
    0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x2c, 0x20, 0x77, 0x65, 0x20, 0x64, 0x6f, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x20, 0x61, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73,
    0x74, 0x65, 0x6e, 0x74, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65,
    0x0a, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x61, 0x20, 0x72, 0x65, 0x73, 0x65,
    0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x20, 0x27,
    0x72, 0x6f, 0x6c, 0x65, 0x27, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74,
    0x20, 0x62, 0x65, 0x20, 0x27, 0x2a, 0x27, 0x29, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10,
    0x03, 0x01, 0x03, 0x00, 0x01, 0x12, 0x04, 0x91, 0x04, 0x0c, 0x17, 0x0a, 0x78, 0x0a, 0x08, 0x04,
    0x10, 0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0x94, 0x04, 0x06, 0x1d, 0x1a, 0x66, 0x20,
    0x41, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49, 0x44, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x64,
    0x69, 0x73, 0x6b, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54,
    0x45, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x49, 0x44, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x73, 0x20,
    0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x70, 0x65, 0x72,
    0x20, 0x72, 0x6f, 0x6c, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x73, 0x6c,
    0x61, 0x76, 0x65, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x10, 0x03, 0x01, 0x03, 0x00, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x94, 0x04, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x10, 0x03, 0x01,
    0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0x94, 0x04, 0x0f, 0x15, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x10, 0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94, 0x04, 0x16, 0x18, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x10, 0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94, 0x04, 0x1b,
    0x1c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x10, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0x97, 0x04, 0x04,
    0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x97, 0x04,
    0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x01, 0x02, 0x00, 0x06, 0x12, 0x04, 0x97,
    0x04, 0x0d, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04,
    0x97, 0x04, 0x19, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12,
    0x04, 0x97, 0x04, 0x27, 0x28, 0x0a, 0xd9, 0x03, 0x0a, 0x06, 0x04, 0x10, 0x03, 0x01, 0x02, 0x01,
    0x12, 0x04, 0xa2, 0x04, 0x04, 0x1f, 0x1a, 0xc8, 0x03, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69,
    0x62, 0x65, 0x73, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73,
    0x6b, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x62, 0x65, 0x20, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68,
    0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e, 0x20, 0x49, 0x66,
    0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69,
    0x73, 0x6b, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c,
    0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x0a,
    0x20, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x2e, 0x20, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x77,
    0x69, 0x73, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20,
    0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x61, 0x63, 0x63, 0x6f, 0x72, 0x64, 0x69, 0x6e,
    0x67, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x27, 0x63, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x65, 0x72, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x27, 0x20, 0x69, 0x6e, 0x73, 0x69, 0x64,
    0x65, 0x20, 0x27, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x27, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x27, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x27, 0x20, 0x69, 0x6e, 0x73, 0x69,
    0x64, 0x65, 0x0a, 0x20, 0x27, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20,
    0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20,
    0x49, 0x66, 0x20, 0x27, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x73,
    0x65, 0x74, 0x20, 0x62, 0x75, 0x74, 0x20, 0x27, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65,
    0x6e, 0x63, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x65, 0x74, 0x2c,
    0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x20, 0x77, 0x69, 0x6c,
    0x6c, 0x20, 0x62, 0x65, 0x20, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x69, 0x63, 0x61, 0x6c,
    0x6c, 0x79, 0x20, 0x67, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
    0x63, 0x74, 0x65, 0x64, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x0a, 0x20, 0x74, 0x61, 0x73, 0x6b,
    0x2f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e,
    0x61, 0x74, 0x65, 0x73, 0x2e, 0x20, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x2c,
    0x20, 0x69, 0x66, 0x20, 0x27, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65,
    0x27, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x0a, 0x20, 0x27, 0x76, 0x6f, 0x6c, 0x75,
    0x6d, 0x65, 0x27, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa2, 0x04,
    0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x01, 0x02, 0x01, 0x06, 0x12, 0x04, 0xa2,
    0x04, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xa2, 0x04, 0x14, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xa2, 0x04, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x07, 0x12, 0x04, 0xa5,
    0x04, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x07, 0x04, 0x12, 0x04, 0xa5, 0x04,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x07, 0x06, 0x12, 0x04, 0xa5, 0x04, 0x0b,
    0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x07, 0x01, 0x12, 0x04, 0xa5, 0x04, 0x14, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x07, 0x03, 0x12, 0x04, 0xa5, 0x04, 0x1b, 0x1c, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x10, 0x03, 0x02, 0x12, 0x04, 0xa7, 0x04, 0x02, 0x1a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x03, 0x02, 0x01, 0x12, 0x04, 0xa7, 0x04, 0x0a, 0x17, 0x0a, 0xe1, 0x02, 0x0a,
    0x04, 0x04, 0x10, 0x02, 0x08, 0x12, 0x04, 0xaf, 0x04, 0x02, 0x27, 0x1a, 0xd2, 0x02, 0x20, 0x49,
    0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65,
    0x20, 0x72, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x2c, 0x20, 0x69, 0x2e, 0x65, 0x2e,
    0x2c, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x6f, 0x72, 0x0a, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68,
    0x65, 0x64, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x72,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x67,
    0x65, 0x74, 0x20, 0x70, 0x72, 0x65, 0x65, 0x6d, 0x70, 0x74, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x0a,
    0x20, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x61, 0x6e,
    0x79, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x75,
    0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x75, 0x6e, 0x0a,
    0x20, 0x62, 0x65, 0x73, 0x74, 0x20, 0x65, 0x66, 0x66, 0x6f, 0x72, 0x74, 0x20, 0x74, 0x61, 0x73,
    0x6b, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6f, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6e,
    0x65, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x20, 0x75, 0x70, 0x74, 0x69, 0x6d,
    0x65, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x6e, 0x63, 0x65,
    0x0a, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x73, 0x2e, 0x20, 0x4e, 0x6f,
    0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20,
    0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x27, 0x64, 0x69, 0x73, 0x6b, 0x27, 0x20, 0x6f,
    0x72, 0x20, 0x27, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x27, 0x0a,
    0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x08, 0x04, 0x12, 0x04, 0xaf, 0x04, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x08, 0x06, 0x12, 0x04, 0xaf, 0x04, 0x0b, 0x18, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x10, 0x02, 0x08, 0x01, 0x12, 0x04, 0xaf, 0x04, 0x19, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x08, 0x03, 0x12, 0x04, 0xaf, 0x04, 0x25, 0x26, 0x0a, 0x80, 0x09, 0x0a,
    0x02, 0x04, 0x11, 0x12, 0x06, 0xcb, 0x04, 0x00, 0xd6, 0x04, 0x01, 0x1a, 0xf1, 0x08, 0x2a, 0x0a,
    0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
    0x6b, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x20, 0x63, 0x61, 0x70, 0x73,
    0x20, 0x61, 0x72, 0x65, 0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x0a, 0x20,
    0x69, 0x73, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x69, 0x74, 0x73, 0x20, 0x6c, 0x69, 0x6d, 0x69,
    0x74, 0x2c, 0x20, 0x6f, 0x75, 0x74, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x70, 0x61, 0x63, 0x6b,
    0x65, 0x74, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65,
    0x72, 0x20, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x0a, 0x20, 0x64, 0x72,
    0x6f, 0x70, 0x70, 0x65, 0x64, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x6c, 0x79,
    0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x62, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20,
    0x69, 0x74, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d,
    0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68,
    0x0a, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x61, 0x20, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69,
    0x6e, 0x65, 0x72, 0x20, 0x28, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x70, 0x29, 0x20, 0x6f, 0x72,
    0x20, 0x62, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d,
    0x62, 0x69, 0x6e, 0x65, 0x64, 0x0a, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x74,
    0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70,
    0x6c, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x20, 0x6f, 0x6e,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64,
    0x73, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6d, 0x69, 0x74, 0x20,
    0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x68, 0x6f, 0x73, 0x74, 0x20, 0x28, 0x74, 0x68, 0x65, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x29,
    0x2e, 0x20, 0x57, 0x65, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x20,
    0x74, 0x68, 0x65, 0x0a, 0x20, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x73,
    0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x61,
    0x63, 0x68, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x64,
    0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20,
    0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6c, 0x79, 0x0a, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x20, 0x54, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63,
    0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x20, 0x51, 0x75, 0x65, 0x75, 0x65, 0x69, 0x6e,
    0x67, 0x20, 0x44, 0x69, 0x73, 0x63, 0x69, 0x70, 0x6c, 0x69, 0x6e, 0x65, 0x2e, 0x0a, 0x0a, 0x20,
    0x69, 0x64, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x6e, 0x61, 0x6d,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72,
    0x2c, 0x20, 0x65, 0x2e, 0x67, 0x2e, 0x20, 0x27, 0x74, 0x78, 0x5f, 0x62, 0x77, 0x5f, 0x63, 0x61,
    0x70, 0x27, 0x0a, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x6c, 0x6f, 0x67, 0x20, 0x20, 0x20, 0x20, 0x3a,
    0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65,
    0x74, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x64, 0x65, 0x6c,
    0x61, 0x79, 0x65, 0x64, 0x0a, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x3a, 0x20, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x73,
    0x65, 0x65, 0x6e, 0x0a, 0x20, 0x64, 0x72, 0x6f, 0x70, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x3a, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x63, 0x6b,
    0x65, 0x74, 0x73, 0x20, 0x64, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74,
    0x6f, 0x74, 0x61, 0x6c, 0x0a, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73,
    0x20, 0x3a, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x63,
    0x6b, 0x65, 0x74, 0x73, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65,
    0x64, 0x65, 0x64, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20,
    0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x74, 0x6f, 0x74,
    0x61, 0x6c, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x73, 0x65, 0x65, 0x6e, 0x0a,
    0x20, 0x71, 0x6c, 0x65, 0x6e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x6e, 0x75,
    0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20,
    0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64,
    0x0a, 0x20, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x62, 0x70, 0x73, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x74,
    0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x70, 0x75, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x62, 0x79, 0x74,
    0x65, 0x73, 0x2f, 0x73, 0x65, 0x63, 0x0a, 0x20, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x70, 0x73,
    0x20, 0x20, 0x20, 0x3a, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x70, 0x75, 0x74, 0x20,
    0x69, 0x6e, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x2f, 0x73, 0x65, 0x63, 0x0a, 0x20,
    0x72, 0x65, 0x71, 0x75, 0x65, 0x75, 0x65, 0x73, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x6e, 0x75, 0x6d,
    0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x20, 0x61, 0x20, 0x70,
    0x61, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x64,
    0x65, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x20, 0x64, 0x75, 0x65, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x6b,
    0x69, 0x6e, 0x67, 0x20, 0x6f, 0x72, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x63, 0x6f,
    0x6e, 0x74, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x73, 0x75, 0x65, 0x73, 0x0a,
    0x0a, 0x20, 0x4d, 0x6f, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x20, 0x54, 0x72, 0x61,
    0x66, 0x66, 0x69, 0x63, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x20, 0x63, 0x61, 0x6e,
    0x20, 0x62, 0x65, 0x0a, 0x20, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74,
    0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x6c, 0x61, 0x72, 0x74, 0x63, 0x2e, 0x6f,
    0x72, 0x67, 0x2f, 0x6c, 0x61, 0x72, 0x74, 0x63, 0x2e, 0x68, 0x74, 0x6d, 0x6c, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x11, 0x01, 0x12, 0x04, 0xcb, 0x04, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x11, 0x02, 0x00, 0x12, 0x04, 0xcc, 0x04, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xcc, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xcc, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xcc, 0x04, 0x12, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xcc, 0x04, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x01, 0x12, 0x04,
    0xcd, 0x04, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcd,
    0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x05, 0x12, 0x04, 0xcd, 0x04,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcd, 0x04, 0x12,
    0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcd, 0x04, 0x1c, 0x1d,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x02, 0x12, 0x04, 0xce, 0x04, 0x02, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x11, 0x02, 0x02, 0x04, 0x12, 0x04, 0xce, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x11, 0x02, 0x02, 0x05, 0x12, 0x04, 0xce, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x11, 0x02, 0x02, 0x01, 0x12, 0x04, 0xce, 0x04, 0x12, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x11, 0x02, 0x02, 0x03, 0x12, 0x04, 0xce, 0x04, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11,
    0x02, 0x03, 0x12, 0x04, 0xcf, 0x04, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xcf, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xcf, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xcf, 0x04, 0x12, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xcf, 0x04, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x04, 0x12, 0x04, 0xd0, 0x04,
    0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd0, 0x04, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x04, 0x05, 0x12, 0x04, 0xd0, 0x04, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd0, 0x04, 0x12, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd0, 0x04, 0x1f, 0x20, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x11, 0x02, 0x05, 0x12, 0x04, 0xd1, 0x04, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x11, 0x02, 0x05, 0x04, 0x12, 0x04, 0xd1, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x11, 0x02, 0x05, 0x05, 0x12, 0x04, 0xd1, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11,
    0x02, 0x05, 0x01, 0x12, 0x04, 0xd1, 0x04, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x05, 0x03, 0x12, 0x04, 0xd1, 0x04, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x06,
    0x12, 0x04, 0xd2, 0x04, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x06, 0x04, 0x12,
    0x04, 0xd2, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x06, 0x05, 0x12, 0x04,
    0xd2, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x06, 0x01, 0x12, 0x04, 0xd2,
    0x04, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x06, 0x03, 0x12, 0x04, 0xd2, 0x04,
    0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x07, 0x12, 0x04, 0xd3, 0x04, 0x02, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x07, 0x04, 0x12, 0x04, 0xd3, 0x04, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x07, 0x05, 0x12, 0x04, 0xd3, 0x04, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x11, 0x02, 0x07, 0x01, 0x12, 0x04, 0xd3, 0x04, 0x12, 0x19, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x11, 0x02, 0x07, 0x03, 0x12, 0x04, 0xd3, 0x04, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x11, 0x02, 0x08, 0x12, 0x04, 0xd4, 0x04, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11,
    0x02, 0x08, 0x04, 0x12, 0x04, 0xd4, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x08, 0x05, 0x12, 0x04, 0xd4, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x08,
    0x01, 0x12, 0x04, 0xd4, 0x04, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x08, 0x03,
    0x12, 0x04, 0xd4, 0x04, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x09, 0x12, 0x04,
    0xd5, 0x04, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x09, 0x04, 0x12, 0x04, 0xd5,
    0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x09, 0x05, 0x12, 0x04, 0xd5, 0x04,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x09, 0x01, 0x12, 0x04, 0xd5, 0x04, 0x12,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x09, 0x03, 0x12, 0x04, 0xd5, 0x04, 0x1d, 0x1f,
    0x0a, 0x3a, 0x0a, 0x02, 0x04, 0x12, 0x12, 0x06, 0xdc, 0x04, 0x00, 0xbd, 0x05, 0x01, 0x1a, 0x2c,
    0x2a, 0x0a, 0x20, 0x41, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x20, 0x6f, 0x66,
    0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x20,
    0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x12, 0x01, 0x12, 0x04, 0xdc, 0x04, 0x08, 0x1a, 0x0a, 0x3a, 0x0a, 0x04, 0x04, 0x12, 0x02,
    0x00, 0x12, 0x04, 0xdd, 0x04, 0x02, 0x20, 0x22, 0x2c, 0x20, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68,
    0x6f, 0x74, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2c, 0x20, 0x69, 0x6e, 0x20, 0x73, 0x65, 0x63, 0x6f,
    0x6e, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x45, 0x70,
    0x6f, 0x63, 0x68, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xdd, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x05, 0x12, 0x04, 0xdd,
    0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdd, 0x04,
    0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdd, 0x04, 0x1e,
    0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x01, 0x12, 0x04, 0xdf, 0x04, 0x02, 0x21, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdf, 0x04, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x05, 0x12, 0x04, 0xdf, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x01, 0x01, 0x12, 0x04, 0xdf, 0x04, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x01, 0x03, 0x12, 0x04, 0xdf, 0x04, 0x1e, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x12, 0x02, 0x02, 0x12, 0x04, 0xe0, 0x04, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xe0, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xe0, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xe0, 0x04, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xe0, 0x04, 0x1c, 0x1e, 0x0a, 0x5b, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x03, 0x12, 0x04, 0xe4,
    0x04, 0x02, 0x2a, 0x1a, 0x4d, 0x20, 0x43, 0x50, 0x55, 0x20, 0x55, 0x73, 0x61, 0x67, 0x65, 0x20,
    0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x0a, 0x20, 0x54, 0x6f,
    0x74, 0x61, 0x6c, 0x20, 0x43, 0x50, 0x55, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x73, 0x70, 0x65,
    0x6e, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x2c,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x20, 0x6d, 0x6f, 0x64, 0x65,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe4, 0x04, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x05, 0x12, 0x04, 0xe4, 0x04, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x01, 0x12, 0x04, 0xe4, 0x04, 0x12, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x03, 0x12, 0x04, 0xe4, 0x04, 0x28, 0x29, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x12, 0x02, 0x04, 0x12, 0x04, 0xe5, 0x04, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x04, 0x04, 0x12, 0x04, 0xe5, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x04, 0x05, 0x12, 0x04, 0xe5, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xe5, 0x04, 0x12, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xe5, 0x04, 0x2a, 0x2b, 0x0a, 0x29, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x05,
    0x12, 0x04, 0xe8, 0x04, 0x02, 0x21, 0x1a, 0x1b, 0x20, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20,
    0x6f, 0x66, 0x20, 0x43, 0x50, 0x55, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65,
    0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x05, 0x04, 0x12, 0x04, 0xe8, 0x04,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x05, 0x05, 0x12, 0x04, 0xe8, 0x04, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x05, 0x01, 0x12, 0x04, 0xe8, 0x04, 0x12, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x05, 0x03, 0x12, 0x04, 0xe8, 0x04, 0x1f, 0x20, 0x0a,
    0x47, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x06, 0x12, 0x04, 0xeb, 0x04, 0x02, 0x26, 0x1a, 0x39, 0x20,
    0x63, 0x70, 0x75, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x20, 0x6f, 0x6e, 0x20, 0x70, 0x72, 0x6f, 0x63,
    0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x69, 0x6e, 0x67, 0x20, 0x28,
    0x66, 0x6f, 0x72, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69,
    0x73, 0x73, 0x75, 0x65, 0x73, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x06,
    0x04, 0x12, 0x04, 0xeb, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x06, 0x05,
    0x12, 0x04, 0xeb, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x06, 0x01, 0x12,
    0x04, 0xeb, 0x04, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x06, 0x03, 0x12, 0x04,
    0xeb, 0x04, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x07, 0x12, 0x04, 0xec, 0x04,
    0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x07, 0x04, 0x12, 0x04, 0xec, 0x04, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x07, 0x05, 0x12, 0x04, 0xec, 0x04, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x07, 0x01, 0x12, 0x04, 0xec, 0x04, 0x12, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x07, 0x03, 0x12, 0x04, 0xec, 0x04, 0x26, 0x27, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x12, 0x02, 0x08, 0x12, 0x04, 0xed, 0x04, 0x02, 0x2f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x08, 0x04, 0x12, 0x04, 0xed, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x08, 0x05, 0x12, 0x04, 0xed, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x08, 0x01, 0x12, 0x04, 0xed, 0x04, 0x12, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x08, 0x03, 0x12, 0x04, 0xed, 0x04, 0x2d, 0x2e, 0x0a, 0xce, 0x02, 0x0a, 0x04, 0x04, 0x12, 0x02,
    0x09, 0x12, 0x04, 0xf6, 0x04, 0x02, 0x27, 0x1a, 0xbf, 0x02, 0x20, 0x6d, 0x65, 0x6d, 0x5f, 0x74,
    0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x77, 0x61, 0x73, 0x20, 0x61,
    0x64, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x30, 0x2e, 0x32, 0x33, 0x2e, 0x30, 0x20, 0x74,
    0x6f, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x74, 0x6f, 0x74, 0x61, 0x6c, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x0a, 0x20, 0x6f, 0x66,
    0x20, 0x61, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x52, 0x41,
    0x4d, 0x20, 0x28, 0x61, 0x73, 0x20, 0x6f, 0x70, 0x70, 0x6f, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x69, 0x6e, 0x20, 0x53, 0x77, 0x61, 0x70, 0x29, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x77, 0x61, 0x73, 0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x6c, 0x79, 0x0a, 0x20,
    0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x6d, 0x65, 0x6d, 0x5f,
    0x72, 0x73, 0x73, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68,
    0x20, 0x77, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x73, 0x6f, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65,
    0x64, 0x20, 0x69, 0x6e, 0x20, 0x30, 0x2e, 0x32, 0x33, 0x2e, 0x30, 0x20, 0x74, 0x6f, 0x0a, 0x20,
    0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x61, 0x6e, 0x6f, 0x6e, 0x79, 0x6d, 0x6f, 0x75, 0x73, 0x20, 0x6d, 0x65, 0x6d,
    0x6f, 0x72, 0x79, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2c, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x65,
    0x65, 0x70, 0x20, 0x69, 0x6e, 0x20, 0x73, 0x79, 0x6e, 0x63, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a,
    0x20, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x20, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x27, 0x73, 0x20,
    0x28, 0x61, 0x72, 0x67, 0x75, 0x61, 0x62, 0x6c, 0x79, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x6e, 0x65,
    0x6f, 0x75, 0x73, 0x29, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x65, 0x72, 0x6d,
    0x69, 0x6e, 0x6f, 0x6c, 0x6f, 0x67, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x09, 0x04, 0x12, 0x04, 0xf6, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x09,
    0x05, 0x12, 0x04, 0xf6, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x09, 0x01,
    0x12, 0x04, 0xf6, 0x04, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x09, 0x03, 0x12,
    0x04, 0xf6, 0x04, 0x24, 0x26, 0x0a, 0x4a, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x0a, 0x12, 0x04, 0xf9,
    0x04, 0x02, 0x2d, 0x1a, 0x3c, 0x20, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x20, 0x6d, 0x65, 0x6d, 0x6f,
    0x72, 0x79, 0x20, 0x2b, 0x20, 0x73, 0x77, 0x61, 0x70, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2e,
    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x66, 0x20,
    0x73, 0x77, 0x61, 0x70, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xf9, 0x04, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xf9, 0x04, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xf9, 0x04, 0x12, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xf9, 0x04, 0x2a, 0x2c, 0x0a, 0x32, 0x0a,
    0x04, 0x04, 0x12, 0x02, 0x0b, 0x12, 0x04, 0xfc, 0x04, 0x02, 0x26, 0x1a, 0x24, 0x20, 0x48, 0x61,
    0x72, 0x64, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xfc, 0x04, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xfc, 0x04, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xfc, 0x04, 0x12, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xfc, 0x04, 0x24, 0x25, 0x0a, 0x32, 0x0a,
    0x04, 0x04, 0x12, 0x02, 0x0c, 0x12, 0x04, 0xff, 0x04, 0x02, 0x2c, 0x1a, 0x24, 0x20, 0x53, 0x6f,
    0x66, 0x74, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xff, 0x04, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xff, 0x04, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xff, 0x04, 0x12, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xff, 0x04, 0x29, 0x2b, 0x0a, 0x77, 0x0a,
    0x04, 0x04, 0x12, 0x02, 0x0d, 0x12, 0x04, 0x86, 0x05, 0x02, 0x26, 0x1a, 0x69, 0x20, 0x54, 0x4f,
    0x44, 0x4f, 0x28, 0x63, 0x68, 0x7a, 0x68, 0x63, 0x6e, 0x29, 0x20, 0x6d, 0x65, 0x6d, 0x5f, 0x66,
    0x69, 0x6c, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x65,
    0x6d, 0x5f, 0x61, 0x6e, 0x6f, 0x6e, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65,
    0x20, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x0a, 0x20,
    0x30, 0x2e, 0x32, 0x33, 0x2e, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x62, 0x65, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x30, 0x2e,
    0x32, 0x34, 0x2e, 0x30, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0d, 0x04, 0x12,
    0x04, 0x86, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0d, 0x05, 0x12, 0x04,
    0x86, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0d, 0x01, 0x12, 0x04, 0x86,
    0x05, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0d, 0x03, 0x12, 0x04, 0x86, 0x05,
    0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x0e, 0x12, 0x04, 0x87, 0x05, 0x02, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0e, 0x04, 0x12, 0x04, 0x87, 0x05, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0e, 0x05, 0x12, 0x04, 0x87, 0x05, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x0e, 0x01, 0x12, 0x04, 0x87, 0x05, 0x12, 0x20, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x0e, 0x03, 0x12, 0x04, 0x87, 0x05, 0x23, 0x25, 0x0a, 0x51, 0x0a, 0x04,
    0x04, 0x12, 0x02, 0x0f, 0x12, 0x04, 0x8a, 0x05, 0x02, 0x27, 0x1a, 0x43, 0x20, 0x6d, 0x65, 0x6d,
    0x5f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x73, 0x20,
    0x61, 0x64, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x30, 0x2e, 0x32, 0x33, 0x2e, 0x30, 0x20,
    0x74, 0x6f, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x70, 0x61, 0x67,
    0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x0f, 0x04, 0x12, 0x04, 0x8a, 0x05, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x0f, 0x05, 0x12, 0x04, 0x8a, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x0f, 0x01, 0x12, 0x04, 0x8a, 0x05, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x0f, 0x03, 0x12, 0x04, 0x8a, 0x05, 0x24, 0x26, 0x0a, 0xb4, 0x01, 0x0a, 0x04,
    0x04, 0x12, 0x02, 0x10, 0x12, 0x04, 0x8f, 0x05, 0x02, 0x24, 0x1a, 0xa5, 0x01, 0x20, 0x53, 0x69,
    0x6e, 0x63, 0x65, 0x20, 0x30, 0x2e, 0x32, 0x33, 0x2e, 0x30, 0x2c, 0x20, 0x6d, 0x65, 0x6d, 0x5f,
    0x72, 0x73, 0x73, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x73, 0x20, 0x63, 0x68, 0x61,
    0x6e, 0x67, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e,
    0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x0a, 0x20, 0x61, 0x6e, 0x6f, 0x6e, 0x79, 0x6d, 0x6f, 0x75,
    0x73, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x20,
    0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6e, 0x65, 0x69, 0x74, 0x68, 0x65,
    0x72, 0x20, 0x69, 0x74, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x6e, 0x65,
    0x73, 0x73, 0x2c, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2c, 0x0a, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20,
    0x6e, 0x6f, 0x72, 0x20, 0x6e, 0x75, 0x6d, 0x65, 0x72, 0x69, 0x63, 0x20, 0x74, 0x61, 0x67, 0x20,
    0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x10, 0x04, 0x12, 0x04, 0x8f, 0x05, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x10, 0x05, 0x12, 0x04, 0x8f, 0x05, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x10, 0x01, 0x12, 0x04, 0x8f, 0x05, 0x12, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x10, 0x03, 0x12, 0x04, 0x8f, 0x05, 0x22, 0x23, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x12, 0x02, 0x11, 0x12, 0x04, 0x91, 0x05, 0x02, 0x2d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x11, 0x04, 0x12, 0x04, 0x91, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x11, 0x05, 0x12, 0x04, 0x91, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x11, 0x01, 0x12, 0x04, 0x91, 0x05, 0x12, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x11, 0x03, 0x12, 0x04, 0x91, 0x05, 0x2a, 0x2c, 0x0a, 0x34, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x12,
    0x12, 0x04, 0x93, 0x05, 0x02, 0x26, 0x1a, 0x26, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73,
    0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x66, 0x20, 0x73, 0x77, 0x61,
    0x70, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x12, 0x04, 0x12, 0x04, 0x93, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x12, 0x05, 0x12, 0x04, 0x93, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x12, 0x01, 0x12, 0x04, 0x93, 0x05, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x12, 0x03, 0x12, 0x04, 0x93, 0x05, 0x23, 0x25, 0x0a, 0x95, 0x02, 0x0a, 0x04, 0x04,
    0x12, 0x02, 0x13, 0x12, 0x04, 0x9a, 0x05, 0x02, 0x30, 0x1a, 0x86, 0x02, 0x20, 0x4e, 0x75, 0x6d,
    0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x6f, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63,
    0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20,
    0x6c, 0x65, 0x76, 0x65, 0x6c, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79,
    0x20, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x0a, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74,
    0x73, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x6d, 0x65,
    0x6d, 0x6f, 0x72, 0x79, 0x20, 0x63, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x2e, 0x20, 0x50, 0x72, 0x65,
    0x73, 0x73, 0x75, 0x72, 0x65, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x69, 0x6e, 0x67, 0x20,
    0x28, 0x72, 0x65, 0x29, 0x73, 0x74, 0x61, 0x72, 0x74, 0x73, 0x0a, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x73, 0x65,
    0x74, 0x20, 0x74, 0x6f, 0x20, 0x30, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x73, 0x6c, 0x61, 0x76,
    0x65, 0x20, 0x28, 0x72, 0x65, 0x29, 0x73, 0x74, 0x61, 0x72, 0x74, 0x73, 0x2e, 0x20, 0x53, 0x65,
    0x65, 0x0a, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x6b,
    0x65, 0x72, 0x6e, 0x65, 0x6c, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x64, 0x6f, 0x63, 0x2f, 0x44, 0x6f,
    0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x63, 0x67, 0x72, 0x6f,
    0x75, 0x70, 0x73, 0x2f, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x2e, 0x74, 0x78, 0x74, 0x20, 0x66,
    0x6f, 0x72, 0x0a, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x13, 0x04, 0x12, 0x04, 0x9a, 0x05, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x13, 0x05, 0x12, 0x04, 0x9a, 0x05, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x13, 0x01, 0x12, 0x04, 0x9a, 0x05, 0x12, 0x2a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x13, 0x03, 0x12, 0x04, 0x9a, 0x05, 0x2d, 0x2f, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x12, 0x02, 0x14, 0x12, 0x04, 0x9b, 0x05, 0x02, 0x33, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x14, 0x04, 0x12, 0x04, 0x9b, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x14, 0x05, 0x12, 0x04, 0x9b, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x14, 0x01, 0x12, 0x04, 0x9b, 0x05, 0x12, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x14, 0x03, 0x12, 0x04, 0x9b, 0x05, 0x30, 0x32, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x15,
    0x12, 0x04, 0x9c, 0x05, 0x02, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x15, 0x04, 0x12,
    0x04, 0x9c, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x15, 0x05, 0x12, 0x04,
    0x9c, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x15, 0x01, 0x12, 0x04, 0x9c,
    0x05, 0x12, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x15, 0x03, 0x12, 0x04, 0x9c, 0x05,
    0x32, 0x34, 0x0a, 0x46, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x16, 0x12, 0x04, 0x9f, 0x05, 0x02, 0x28,
    0x1a, 0x38, 0x20, 0x44, 0x69, 0x73, 0x6b, 0x20, 0x55, 0x73, 0x61, 0x67, 0x65, 0x20, 0x49, 0x6e,
    0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x78,
    0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x77, 0x6f, 0x72, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x64,
    0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x16, 0x04, 0x12, 0x04, 0x9f, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x16, 0x05, 0x12, 0x04, 0x9f, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x16,
    0x01, 0x12, 0x04, 0x9f, 0x05, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x16, 0x03,
    0x12, 0x04, 0x9f, 0x05, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x17, 0x12, 0x04,
    0xa0, 0x05, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x17, 0x04, 0x12, 0x04, 0xa0,
    0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x17, 0x05, 0x12, 0x04, 0xa0, 0x05,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x17, 0x01, 0x12, 0x04, 0xa0, 0x05, 0x12,
    0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x17, 0x03, 0x12, 0x04, 0xa0, 0x05, 0x24, 0x26,
    0x0a, 0x20, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x18, 0x12, 0x04, 0xa3, 0x05, 0x02, 0x24, 0x1a, 0x12,
    0x20, 0x50, 0x65, 0x72, 0x66, 0x20, 0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x18, 0x04, 0x12, 0x04, 0xa3, 0x05, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x18, 0x06, 0x12, 0x04, 0xa3, 0x05, 0x0b, 0x19,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x18, 0x01, 0x12, 0x04, 0xa3, 0x05, 0x1a, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x18, 0x03, 0x12, 0x04, 0xa3, 0x05, 0x21, 0x23, 0x0a, 0x2a,
    0x0a, 0x04, 0x04, 0x12, 0x02, 0x19, 0x12, 0x04, 0xa6, 0x05, 0x02, 0x26, 0x1a, 0x1c, 0x20, 0x4e,
    0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x55, 0x73, 0x61, 0x67, 0x65, 0x20, 0x49, 0x6e, 0x66,
    0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x19, 0x04, 0x12, 0x04, 0xa6, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x19, 0x05, 0x12, 0x04, 0xa6, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x19,
    0x01, 0x12, 0x04, 0xa6, 0x05, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x19, 0x03,
    0x12, 0x04, 0xa6, 0x05, 0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x1a, 0x12, 0x04,
    0xa7, 0x05, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1a, 0x04, 0x12, 0x04, 0xa7,
    0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1a, 0x05, 0x12, 0x04, 0xa7, 0x05,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1a, 0x01, 0x12, 0x04, 0xa7, 0x05, 0x12,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1a, 0x03, 0x12, 0x04, 0xa7, 0x05, 0x21, 0x23,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x1b, 0x12, 0x04, 0xa8, 0x05, 0x02, 0x25, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x1b, 0x04, 0x12, 0x04, 0xa8, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x1b, 0x05, 0x12, 0x04, 0xa8, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x1b, 0x01, 0x12, 0x04, 0xa8, 0x05, 0x12, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x1b, 0x03, 0x12, 0x04, 0xa8, 0x05, 0x22, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12,
    0x02, 0x1c, 0x12, 0x04, 0xa9, 0x05, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1c,
    0x04, 0x12, 0x04, 0xa9, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1c, 0x05,
    0x12, 0x04, 0xa9, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1c, 0x01, 0x12,
    0x04, 0xa9, 0x05, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1c, 0x03, 0x12, 0x04,
    0xa9, 0x05, 0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x1d, 0x12, 0x04, 0xaa, 0x05,
    0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1d, 0x04, 0x12, 0x04, 0xaa, 0x05, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1d, 0x05, 0x12, 0x04, 0xaa, 0x05, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1d, 0x01, 0x12, 0x04, 0xaa, 0x05, 0x12, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1d, 0x03, 0x12, 0x04, 0xaa, 0x05, 0x23, 0x25, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x12, 0x02, 0x1e, 0x12, 0x04, 0xab, 0x05, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x1e, 0x04, 0x12, 0x04, 0xab, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x1e, 0x05, 0x12, 0x04, 0xab, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x1e, 0x01, 0x12, 0x04, 0xab, 0x05, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x1e, 0x03, 0x12, 0x04, 0xab, 0x05, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x1f,
    0x12, 0x04, 0xac, 0x05, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1f, 0x04, 0x12,
    0x04, 0xac, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1f, 0x05, 0x12, 0x04,
    0xac, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1f, 0x01, 0x12, 0x04, 0xac,
    0x05, 0x12, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x1f, 0x03, 0x12, 0x04, 0xac, 0x05,
    0x22, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x20, 0x12, 0x04, 0xad, 0x05, 0x02, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x20, 0x04, 0x12, 0x04, 0xad, 0x05, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x20, 0x05, 0x12, 0x04, 0xad, 0x05, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x20, 0x01, 0x12, 0x04, 0xad, 0x05, 0x12, 0x20, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x20, 0x03, 0x12, 0x04, 0xad, 0x05, 0x23, 0x25, 0x0a, 0x86, 0x01, 0x0a,
    0x04, 0x04, 0x12, 0x02, 0x21, 0x12, 0x04, 0xb1, 0x05, 0x02, 0x31, 0x1a, 0x78, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x20, 0x6b, 0x65, 0x65, 0x70, 0x73, 0x20, 0x74,
    0x72, 0x61, 0x63, 0x6b, 0x20, 0x6f, 0x66, 0x20, 0x52, 0x54, 0x54, 0x20, 0x28, 0x72, 0x6f, 0x75,
    0x6e, 0x64, 0x2d, 0x74, 0x72, 0x69, 0x70, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x29, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x69, 0x74, 0x73, 0x20, 0x54, 0x43, 0x50, 0x0a, 0x20, 0x73, 0x6f, 0x63, 0x6b, 0x65,
    0x74, 0x73, 0x2e, 0x20, 0x52, 0x54, 0x54, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x77, 0x61, 0x79,
    0x20, 0x74, 0x6f, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x74,
    0x65, 0x6e, 0x63, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69,
    0x6e, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x21, 0x04, 0x12, 0x04,
    0xb1, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x21, 0x05, 0x12, 0x04, 0xb1,
    0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x21, 0x01, 0x12, 0x04, 0xb1, 0x05,
    0x12, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x21, 0x03, 0x12, 0x04, 0xb1, 0x05, 0x2e,
    0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x22, 0x12, 0x04, 0xb2, 0x05, 0x02, 0x31, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x22, 0x04, 0x12, 0x04, 0xb2, 0x05, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x22, 0x05, 0x12, 0x04, 0xb2, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x22, 0x01, 0x12, 0x04, 0xb2, 0x05, 0x12, 0x2b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x22, 0x03, 0x12, 0x04, 0xb2, 0x05, 0x2e, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x12, 0x02, 0x23, 0x12, 0x04, 0xb3, 0x05, 0x02, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x23, 0x04, 0x12, 0x04, 0xb3, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x23,
    0x05, 0x12, 0x04, 0xb3, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x23, 0x01,
    0x12, 0x04, 0xb3, 0x05, 0x12, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x23, 0x03, 0x12,
    0x04, 0xb3, 0x05, 0x2e, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x24, 0x12, 0x04, 0xb4,
    0x05, 0x02, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x24, 0x04, 0x12, 0x04, 0xb4, 0x05,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x24, 0x05, 0x12, 0x04, 0xb4, 0x05, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x24, 0x01, 0x12, 0x04, 0xb4, 0x05, 0x12, 0x2b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x24, 0x03, 0x12, 0x04, 0xb4, 0x05, 0x2e, 0x30, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x25, 0x12, 0x04, 0xb6, 0x05, 0x02, 0x32, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x25, 0x04, 0x12, 0x04, 0xb6, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x25, 0x05, 0x12, 0x04, 0xb6, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x25, 0x01, 0x12, 0x04, 0xb6, 0x05, 0x12, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x25, 0x03, 0x12, 0x04, 0xb6, 0x05, 0x2f, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02,
    0x26, 0x12, 0x04, 0xb7, 0x05, 0x02, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x26, 0x04,
    0x12, 0x04, 0xb7, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x26, 0x05, 0x12,
    0x04, 0xb7, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x26, 0x01, 0x12, 0x04,
    0xb7, 0x05, 0x12, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x26, 0x03, 0x12, 0x04, 0xb7,
    0x05, 0x32, 0x34, 0x0a, 0x9d, 0x01, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x27, 0x12, 0x04, 0xbc, 0x05,
    0x02, 0x48, 0x1a, 0x8e, 0x01, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x74, 0x72,
    0x61, 0x66, 0x66, 0x69, 0x63, 0x20, 0x66, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x69, 0x6e,
    0x74, 0x6f, 0x20, 0x6f, 0x72, 0x20, 0x6f, 0x75, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20,
    0x64, 0x65, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x0a, 0x20, 0x6f, 0x72, 0x20, 0x64, 0x72, 0x6f, 0x70,
    0x70, 0x65, 0x64, 0x20, 0x64, 0x75, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x67, 0x65,
    0x73, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x20,
    0x69, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6f, 0x75, 0x74, 0x73, 0x69,
    0x64, 0x65, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
    0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x27, 0x04, 0x12, 0x04, 0xbc, 0x05,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x27, 0x06, 0x12, 0x04, 0xbc, 0x05, 0x0b,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x27, 0x01, 0x12, 0x04, 0xbc, 0x05, 0x24, 0x42,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x27, 0x03, 0x12, 0x04, 0xbc, 0x05, 0x45, 0x47, 0x0a,
    0x4b, 0x0a, 0x02, 0x04, 0x13, 0x12, 0x06, 0xc3, 0x05, 0x00, 0xd5, 0x05, 0x01, 0x1a, 0x3d, 0x2a,
    0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x6e,
    0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x13, 0x01, 0x12, 0x04, 0xc3, 0x05, 0x08, 0x15, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x13, 0x03,
    0x00, 0x12, 0x06, 0xc4, 0x05, 0x02, 0xce, 0x05, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x03,
    0x00, 0x01, 0x12, 0x04, 0xc4, 0x05, 0x0a, 0x12, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x00,
    0x02, 0x00, 0x12, 0x04, 0xc5, 0x05, 0x04, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xc5, 0x05, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03,
    0x00, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc5, 0x05, 0x0d, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13,
    0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc5, 0x05, 0x1a, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x13, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc5, 0x05, 0x2a, 0x2b, 0x0a, 0x63, 0x0a, 0x06,
    0x04, 0x13, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xc9, 0x05, 0x04, 0x24, 0x1a, 0x53, 0x20, 0x54,
    0x68, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x73, 0x20, 0x72, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x69, 0x74, 0x73, 0x65,
    0x6c, 0x66, 0x0a, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61, 0x73, 0x20, 0x69,
    0x74, 0x73, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc9, 0x05,
    0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x01, 0x06, 0x12, 0x04, 0xc9,
    0x05, 0x0d, 0x15, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xc9, 0x05, 0x16, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xc9, 0x05, 0x22, 0x23, 0x0a, 0x66, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x00, 0x02, 0x02, 0x12,
    0x04, 0xcd, 0x05, 0x04, 0x2f, 0x1a, 0x56, 0x20, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20,
    0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x20,
    0x49, 0x66, 0x20, 0x61, 0x62, 0x73, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x69, 0x7a, 0x65, 0x72, 0x0a, 0x20, 0x63, 0x61,
    0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x20, 0x72, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xcd, 0x05, 0x04, 0x0c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x02, 0x06, 0x12, 0x04, 0xcd, 0x05, 0x0d, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xcd, 0x05, 0x20, 0x2a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xcd, 0x05, 0x2d,
    0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x13, 0x02, 0x00, 0x12, 0x04, 0xd0, 0x05, 0x02, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd0, 0x05, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x13, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd0, 0x05, 0x0b, 0x13, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x13, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd0, 0x05, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x13, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd0, 0x05, 0x20, 0x21, 0x0a, 0x6c, 0x0a, 0x04, 0x04,
    0x13, 0x02, 0x01, 0x12, 0x04, 0xd4, 0x05, 0x02, 0x1e, 0x1a, 0x5e, 0x20, 0x53, 0x6c, 0x61, 0x76,
    0x65, 0x27, 0x73, 0x20, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x63, 0x68,
    0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x64, 0x79, 0x6e, 0x61, 0x6d,
    0x69, 0x63, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20,
    0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xd4, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x01,
    0x06, 0x12, 0x04, 0xd4, 0x05, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xd4, 0x05, 0x14, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xd4, 0x05, 0x1c, 0x1d, 0x0a, 0xa8, 0x03, 0x0a, 0x02, 0x04, 0x14, 0x12, 0x06, 0xe4, 0x05,
    0x00, 0xa0, 0x06, 0x01, 0x1a, 0x99, 0x03, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69,
    0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20,
    0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x22, 0x70, 0x65, 0x72,
    0x66, 0x20, 0x73, 0x74, 0x61, 0x74, 0x22, 0x2e, 0x20, 0x4f, 0x6e, 0x6c, 0x79, 0x20, 0x61, 0x76,
    0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x6f, 0x6e, 0x0a, 0x20, 0x4c, 0x69, 0x6e, 0x75,
    0x78, 0x2e, 0x0a, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20,
    0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x6d,
    0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20,
    0x6f, 0x66, 0x20, 0x61, 0x20, 0x70, 0x65, 0x72, 0x66, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x20,
    0x28, 0x73, 0x65, 0x65, 0x0a, 0x20, 0x22, 0x70, 0x65, 0x72, 0x66, 0x20, 0x6c, 0x69, 0x73, 0x74,
    0x22, 0x29, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x6c, 0x6c,
    0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x3a, 0x0a, 0x20,
    0x31, 0x2e, 0x20, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x64, 0x6f, 0x77,
    0x6e, 0x63, 0x61, 0x73, 0x65, 0x64, 0x2e, 0x0a, 0x20, 0x32, 0x2e, 0x20, 0x48, 0x79, 0x70, 0x68,
    0x65, 0x6e, 0x73, 0x20, 0x28, 0x27, 0x2d, 0x27, 0x29, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65,
    0x70, 0x6c, 0x61, 0x63, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x75, 0x6e, 0x64, 0x65,
    0x72, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x73, 0x20, 0x28, 0x27, 0x5f, 0x27, 0x29, 0x2e, 0x0a, 0x20,
    0x33, 0x2e, 0x20, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61,
    0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x75,
    0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x22, 0x70, 0x65, 0x72,
    0x66, 0x20, 0x73, 0x74, 0x61, 0x74, 0x22, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x73, 0x2c,
    0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x20, 0x22, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73,
    0x20, 0x4f, 0x52, 0x20, 0x63, 0x70, 0x75, 0x2d, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x22, 0x20,
    0x70, 0x65, 0x72, 0x66, 0x20, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x20, 0x72, 0x65, 0x74, 0x75,
    0x72, 0x6e, 0x73, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x2e, 0x0a,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x14, 0x01, 0x12, 0x04, 0xe4, 0x05, 0x08, 0x16, 0x0a, 0x45, 0x0a,
    0x04, 0x04, 0x14, 0x02, 0x00, 0x12, 0x04, 0xe5, 0x05, 0x02, 0x20, 0x22, 0x37, 0x20, 0x53, 0x74,
    0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x69, 0x6e,
    0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2c, 0x20, 0x69, 0x6e, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e,
    0x64, 0x73, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x45, 0x70, 0x6f,
    0x63, 0x68, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe5,
    0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe5, 0x05,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe5, 0x05, 0x12,
    0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe5, 0x05, 0x1e, 0x1f,
    0x0a, 0x38, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x01, 0x12, 0x04, 0xe6, 0x05, 0x02, 0x1f, 0x22, 0x2a,
    0x20, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x61, 0x6d,
    0x70, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2c, 0x20, 0x69, 0x6e,
    0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xe6, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xe6, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xe6, 0x05, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xe6, 0x05, 0x1d, 0x1e, 0x0a, 0x1f, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x02, 0x12, 0x04,
    0xe9, 0x05, 0x02, 0x1d, 0x1a, 0x11, 0x20, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x20,
    0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xe9, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xe9, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xe9, 0x05, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe9,
    0x05, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x03, 0x12, 0x04, 0xea, 0x05, 0x02,
    0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x03, 0x04, 0x12, 0x04, 0xea, 0x05, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x03, 0x05, 0x12, 0x04, 0xea, 0x05, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x03, 0x01, 0x12, 0x04, 0xea, 0x05, 0x12, 0x29, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x03, 0x03, 0x12, 0x04, 0xea, 0x05, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x14, 0x02, 0x04, 0x12, 0x04, 0xeb, 0x05, 0x02, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x04, 0x04, 0x12, 0x04, 0xeb, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x04, 0x05, 0x12, 0x04, 0xeb, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xeb, 0x05, 0x12, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04,
    0x03, 0x12, 0x04, 0xeb, 0x05, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x05, 0x12,
    0x04, 0xec, 0x05, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xec, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x05, 0x05, 0x12, 0x04, 0xec,
    0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x05, 0x01, 0x12, 0x04, 0xec, 0x05,
    0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x05, 0x03, 0x12, 0x04, 0xec, 0x05, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x06, 0x12, 0x04, 0xed, 0x05, 0x02, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x06, 0x04, 0x12, 0x04, 0xed, 0x05, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x06, 0x05, 0x12, 0x04, 0xed, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x06, 0x01, 0x12, 0x04, 0xed, 0x05, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x06, 0x03, 0x12, 0x04, 0xed, 0x05, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x14, 0x02, 0x07, 0x12, 0x04, 0xee, 0x05, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x07, 0x04, 0x12, 0x04, 0xee, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x07,
    0x05, 0x12, 0x04, 0xee, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x07, 0x01,
    0x12, 0x04, 0xee, 0x05, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x07, 0x03, 0x12,
    0x04, 0xee, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x08, 0x12, 0x04, 0xef,
    0x05, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x08, 0x04, 0x12, 0x04, 0xef, 0x05,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x08, 0x05, 0x12, 0x04, 0xef, 0x05, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x08, 0x01, 0x12, 0x04, 0xef, 0x05, 0x12, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x08, 0x03, 0x12, 0x04, 0xef, 0x05, 0x1d, 0x1e, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x09, 0x12, 0x04, 0xf0, 0x05, 0x02, 0x25, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x09, 0x04, 0x12, 0x04, 0xf0, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x09, 0x05, 0x12, 0x04, 0xf0, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x09, 0x01, 0x12, 0x04, 0xf0, 0x05, 0x12, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x09, 0x03, 0x12, 0x04, 0xf0, 0x05, 0x22, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02,
    0x0a, 0x12, 0x04, 0xf1, 0x05, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0a, 0x04,
    0x12, 0x04, 0xf1, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0a, 0x05, 0x12,
    0x04, 0xf1, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0a, 0x01, 0x12, 0x04,
    0xf1, 0x05, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xf1,
    0x05, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x0b, 0x12, 0x04, 0xf2, 0x05, 0x02,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xf2, 0x05, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xf2, 0x05, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xf2, 0x05, 0x12, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xf2, 0x05, 0x1f, 0x21, 0x0a, 0x1f, 0x0a,
    0x04, 0x04, 0x14, 0x02, 0x0c, 0x12, 0x04, 0xf5, 0x05, 0x02, 0x21, 0x1a, 0x11, 0x20, 0x53, 0x6f,
    0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xf5, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xf5, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xf5, 0x05, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xf5, 0x05, 0x1e, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14,
    0x02, 0x0d, 0x12, 0x04, 0xf6, 0x05, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0d,
    0x04, 0x12, 0x04, 0xf6, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0d, 0x05,
    0x12, 0x04, 0xf6, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0d, 0x01, 0x12,
    0x04, 0xf6, 0x05, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0d, 0x03, 0x12, 0x04,
    0xf6, 0x05, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x0e, 0x12, 0x04, 0xf7, 0x05,
    0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0e, 0x04, 0x12, 0x04, 0xf7, 0x05, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0e, 0x05, 0x12, 0x04, 0xf7, 0x05, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xf7, 0x05, 0x12, 0x1d, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x0e, 0x03, 0x12, 0x04, 0xf7, 0x05, 0x20, 0x22, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x14, 0x02, 0x0f, 0x12, 0x04, 0xf8, 0x05, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xf8, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xf8, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x0f, 0x01, 0x12, 0x04, 0xf8, 0x05, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x0f, 0x03, 0x12, 0x04, 0xf8, 0x05, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x10,
    0x12, 0x04, 0xf9, 0x05, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x10, 0x04, 0x12,
    0x04, 0xf9, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x10, 0x05, 0x12, 0x04,
    0xf9, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x10, 0x01, 0x12, 0x04, 0xf9,
    0x05, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x10, 0x03, 0x12, 0x04, 0xf9, 0x05,
    0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x11, 0x12, 0x04, 0xfa, 0x05, 0x02, 0x28,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x11, 0x04, 0x12, 0x04, 0xfa, 0x05, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x11, 0x05, 0x12, 0x04, 0xfa, 0x05, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x11, 0x01, 0x12, 0x04, 0xfa, 0x05, 0x12, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x11, 0x03, 0x12, 0x04, 0xfa, 0x05, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x14, 0x02, 0x12, 0x12, 0x04, 0xfb, 0x05, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x12, 0x04, 0x12, 0x04, 0xfb, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x12, 0x05, 0x12, 0x04, 0xfb, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x12,
    0x01, 0x12, 0x04, 0xfb, 0x05, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x12, 0x03,
    0x12, 0x04, 0xfb, 0x05, 0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x13, 0x12, 0x04,
    0xfc, 0x05, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x13, 0x04, 0x12, 0x04, 0xfc,
    0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x13, 0x05, 0x12, 0x04, 0xfc, 0x05,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x13, 0x01, 0x12, 0x04, 0xfc, 0x05, 0x12,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x13, 0x03, 0x12, 0x04, 0xfc, 0x05, 0x25, 0x27,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x14, 0x12, 0x04, 0xfd, 0x05, 0x02, 0x28, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x14, 0x04, 0x12, 0x04, 0xfd, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x14, 0x05, 0x12, 0x04, 0xfd, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x14, 0x01, 0x12, 0x04, 0xfd, 0x05, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x14, 0x03, 0x12, 0x04, 0xfd, 0x05, 0x25, 0x27, 0x0a, 0x25, 0x0a, 0x04, 0x04, 0x14,
    0x02, 0x15, 0x12, 0x04, 0x80, 0x06, 0x02, 0x27, 0x1a, 0x17, 0x20, 0x48, 0x61, 0x72, 0x64, 0x77,
    0x61, 0x72, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x15, 0x04, 0x12, 0x04, 0x80, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x15, 0x05, 0x12, 0x04, 0x80, 0x06, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x15, 0x01, 0x12, 0x04, 0x80, 0x06, 0x12, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x15, 0x03, 0x12, 0x04, 0x80, 0x06, 0x24, 0x26, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x14, 0x02, 0x16, 0x12, 0x04, 0x81, 0x06, 0x02, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x16, 0x04, 0x12, 0x04, 0x81, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x16, 0x05, 0x12, 0x04, 0x81, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x16, 0x01, 0x12, 0x04, 0x81, 0x06, 0x12, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x16,
    0x03, 0x12, 0x04, 0x81, 0x06, 0x2a, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x17, 0x12,
    0x04, 0x82, 0x06, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x17, 0x04, 0x12, 0x04,
    0x82, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x17, 0x05, 0x12, 0x04, 0x82,
    0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x17, 0x01, 0x12, 0x04, 0x82, 0x06,
    0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x17, 0x03, 0x12, 0x04, 0x82, 0x06, 0x25,
    0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x18, 0x12, 0x04, 0x83, 0x06, 0x02, 0x2e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x18, 0x04, 0x12, 0x04, 0x83, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x18, 0x05, 0x12, 0x04, 0x83, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x18, 0x01, 0x12, 0x04, 0x83, 0x06, 0x12, 0x28, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x18, 0x03, 0x12, 0x04, 0x83, 0x06, 0x2b, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x14, 0x02, 0x19, 0x12, 0x04, 0x84, 0x06, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x19, 0x04, 0x12, 0x04, 0x84, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x19,
    0x05, 0x12, 0x04, 0x84, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x19, 0x01,
    0x12, 0x04, 0x84, 0x06, 0x12, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x19, 0x03, 0x12,
    0x04, 0x84, 0x06, 0x29, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x1a, 0x12, 0x04, 0x85,
    0x06, 0x02, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1a, 0x04, 0x12, 0x04, 0x85, 0x06,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1a, 0x05, 0x12, 0x04, 0x85, 0x06, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1a, 0x01, 0x12, 0x04, 0x85, 0x06, 0x12, 0x2b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1a, 0x03, 0x12, 0x04, 0x85, 0x06, 0x2e, 0x30, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x1b, 0x12, 0x04, 0x86, 0x06, 0x02, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x1b, 0x04, 0x12, 0x04, 0x86, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x1b, 0x05, 0x12, 0x04, 0x86, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x1b, 0x01, 0x12, 0x04, 0x86, 0x06, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x1b, 0x03, 0x12, 0x04, 0x86, 0x06, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02,
    0x1c, 0x12, 0x04, 0x87, 0x06, 0x02, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1c, 0x04,
    0x12, 0x04, 0x87, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1c, 0x05, 0x12,
    0x04, 0x87, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1c, 0x01, 0x12, 0x04,
    0x87, 0x06, 0x12, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1c, 0x03, 0x12, 0x04, 0x87,
    0x06, 0x2a, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x1d, 0x12, 0x04, 0x88, 0x06, 0x02,
    0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1d, 0x04, 0x12, 0x04, 0x88, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1d, 0x05, 0x12, 0x04, 0x88, 0x06, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1d, 0x01, 0x12, 0x04, 0x88, 0x06, 0x12, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x1d, 0x03, 0x12, 0x04, 0x88, 0x06, 0x29, 0x2b, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x14, 0x02, 0x1e, 0x12, 0x04, 0x89, 0x06, 0x02, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x1e, 0x04, 0x12, 0x04, 0x89, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x1e, 0x05, 0x12, 0x04, 0x89, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x1e, 0x01, 0x12, 0x04, 0x89, 0x06, 0x12, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1e,
    0x03, 0x12, 0x04, 0x89, 0x06, 0x2e, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x1f, 0x12,
    0x04, 0x8a, 0x06, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1f, 0x04, 0x12, 0x04,
    0x8a, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1f, 0x05, 0x12, 0x04, 0x8a,
    0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1f, 0x01, 0x12, 0x04, 0x8a, 0x06,
    0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x1f, 0x03, 0x12, 0x04, 0x8a, 0x06, 0x1e,
    0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x20, 0x12, 0x04, 0x8b, 0x06, 0x02, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x20, 0x04, 0x12, 0x04, 0x8b, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x20, 0x05, 0x12, 0x04, 0x8b, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x20, 0x01, 0x12, 0x04, 0x8b, 0x06, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x20, 0x03, 0x12, 0x04, 0x8b, 0x06, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x14, 0x02, 0x21, 0x12, 0x04, 0x8c, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x21, 0x04, 0x12, 0x04, 0x8c, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x21,
    0x05, 0x12, 0x04, 0x8c, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x21, 0x01,
    0x12, 0x04, 0x8c, 0x06, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x21, 0x03, 0x12,
    0x04, 0x8c, 0x06, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x22, 0x12, 0x04, 0x8d,
    0x06, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x22, 0x04, 0x12, 0x04, 0x8d, 0x06,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x22, 0x05, 0x12, 0x04, 0x8d, 0x06, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x22, 0x01, 0x12, 0x04, 0x8d, 0x06, 0x12, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x22, 0x03, 0x12, 0x04, 0x8d, 0x06, 0x25, 0x27, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x23, 0x12, 0x04, 0x8e, 0x06, 0x02, 0x26, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x23, 0x04, 0x12, 0x04, 0x8e, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x23, 0x05, 0x12, 0x04, 0x8e, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x23, 0x01, 0x12, 0x04, 0x8e, 0x06, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x23, 0x03, 0x12, 0x04, 0x8e, 0x06, 0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02,
    0x24, 0x12, 0x04, 0x8f, 0x06, 0x02, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x24, 0x04,
    0x12, 0x04, 0x8f, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x24, 0x05, 0x12,
    0x04, 0x8f, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x24, 0x01, 0x12, 0x04,
    0x8f, 0x06, 0x12, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x24, 0x03, 0x12, 0x04, 0x8f,
    0x06, 0x28, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x25, 0x12, 0x04, 0x90, 0x06, 0x02,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x25, 0x04, 0x12, 0x04, 0x90, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x25, 0x05, 0x12, 0x04, 0x90, 0x06, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x25, 0x01, 0x12, 0x04, 0x90, 0x06, 0x12, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x25, 0x03, 0x12, 0x04, 0x90, 0x06, 0x1f, 0x21, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x14, 0x02, 0x26, 0x12, 0x04, 0x91, 0x06, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x26, 0x04, 0x12, 0x04, 0x91, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x26, 0x05, 0x12, 0x04, 0x91, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x26, 0x01, 0x12, 0x04, 0x91, 0x06, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x26,
    0x03, 0x12, 0x04, 0x91, 0x06, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x27, 0x12,
    0x04, 0x92, 0x06, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x27, 0x04, 0x12, 0x04,
    0x92, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x27, 0x05, 0x12, 0x04, 0x92,
    0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x27, 0x01, 0x12, 0x04, 0x92, 0x06,
    0x12, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x27, 0x03, 0x12, 0x04, 0x92, 0x06, 0x20,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x28, 0x12, 0x04, 0x93, 0x06, 0x02, 0x29, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x28, 0x04, 0x12, 0x04, 0x93, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x28, 0x05, 0x12, 0x04, 0x93, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x28, 0x01, 0x12, 0x04, 0x93, 0x06, 0x12, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x28, 0x03, 0x12, 0x04, 0x93, 0x06, 0x26, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x14, 0x02, 0x29, 0x12, 0x04, 0x94, 0x06, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x29, 0x04, 0x12, 0x04, 0x94, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x29,
    0x05, 0x12, 0x04, 0x94, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x29, 0x01,
    0x12, 0x04, 0x94, 0x06, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x29, 0x03, 0x12,
    0x04, 0x94, 0x06, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x2a, 0x12, 0x04, 0x95,
    0x06, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2a, 0x04, 0x12, 0x04, 0x95, 0x06,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2a, 0x05, 0x12, 0x04, 0x95, 0x06, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2a, 0x01, 0x12, 0x04, 0x95, 0x06, 0x12, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2a, 0x03, 0x12, 0x04, 0x95, 0x06, 0x29, 0x2b, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x2b, 0x12, 0x04, 0x96, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x2b, 0x04, 0x12, 0x04, 0x96, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x2b, 0x05, 0x12, 0x04, 0x96, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x2b, 0x01, 0x12, 0x04, 0x96, 0x06, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x2b, 0x03, 0x12, 0x04, 0x96, 0x06, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02,
    0x2c, 0x12, 0x04, 0x97, 0x06, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2c, 0x04,
    0x12, 0x04, 0x97, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2c, 0x05, 0x12,
    0x04, 0x97, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2c, 0x01, 0x12, 0x04,
    0x97, 0x06, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2c, 0x03, 0x12, 0x04, 0x97,
    0x06, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x2d, 0x12, 0x04, 0x98, 0x06, 0x02,
    0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2d, 0x04, 0x12, 0x04, 0x98, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2d, 0x05, 0x12, 0x04, 0x98, 0x06, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2d, 0x01, 0x12, 0x04, 0x98, 0x06, 0x12, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x2d, 0x03, 0x12, 0x04, 0x98, 0x06, 0x21, 0x23, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x14, 0x02, 0x2e, 0x12, 0x04, 0x99, 0x06, 0x02, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x2e, 0x04, 0x12, 0x04, 0x99, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x2e, 0x05, 0x12, 0x04, 0x99, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x2e, 0x01, 0x12, 0x04, 0x99, 0x06, 0x12, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2e,
    0x03, 0x12, 0x04, 0x99, 0x06, 0x27, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x2f, 0x12,
    0x04, 0x9a, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2f, 0x04, 0x12, 0x04,
    0x9a, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2f, 0x05, 0x12, 0x04, 0x9a,
    0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2f, 0x01, 0x12, 0x04, 0x9a, 0x06,
    0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x2f, 0x03, 0x12, 0x04, 0x9a, 0x06, 0x1f,
    0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x30, 0x12, 0x04, 0x9b, 0x06, 0x02, 0x28, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x30, 0x04, 0x12, 0x04, 0x9b, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x30, 0x05, 0x12, 0x04, 0x9b, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x30, 0x01, 0x12, 0x04, 0x9b, 0x06, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x30, 0x03, 0x12, 0x04, 0x9b, 0x06, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x14, 0x02, 0x31, 0x12, 0x04, 0x9c, 0x06, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x31, 0x04, 0x12, 0x04, 0x9c, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x31,
    0x05, 0x12, 0x04, 0x9c, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x31, 0x01,
    0x12, 0x04, 0x9c, 0x06, 0x12, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x31, 0x03, 0x12,
    0x04, 0x9c, 0x06, 0x20, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x32, 0x12, 0x04, 0x9d,
    0x06, 0x02, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x32, 0x04, 0x12, 0x04, 0x9d, 0x06,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x32, 0x05, 0x12, 0x04, 0x9d, 0x06, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x32, 0x01, 0x12, 0x04, 0x9d, 0x06, 0x12, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x32, 0x03, 0x12, 0x04, 0x9d, 0x06, 0x26, 0x28, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x33, 0x12, 0x04, 0x9e, 0x06, 0x02, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x33, 0x04, 0x12, 0x04, 0x9e, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x33, 0x05, 0x12, 0x04, 0x9e, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x33, 0x01, 0x12, 0x04, 0x9e, 0x06, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x33, 0x03, 0x12, 0x04, 0x9e, 0x06, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02,
    0x34, 0x12, 0x04, 0x9f, 0x06, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x34, 0x04,
    0x12, 0x04, 0x9f, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x34, 0x05, 0x12,
    0x04, 0x9f, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x34, 0x01, 0x12, 0x04,
    0x9f, 0x06, 0x12, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x34, 0x03, 0x12, 0x04, 0x9f,
    0x06, 0x29, 0x2b, 0x0a, 0xe1, 0x01, 0x0a, 0x02, 0x04, 0x15, 0x12, 0x06, 0xa9, 0x06, 0x00, 0xac,
    0x06, 0x01, 0x1a, 0xd2, 0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65,
    0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63,
    0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x72,
    0x6f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6c, 0x79, 0x20, 0x69, 0x6e, 0x66, 0x6c, 0x75, 0x65,
    0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x6f,
    0x72, 0x2e, 0x20, 0x20, 0x49, 0x66, 0x20, 0x27, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x5f, 0x69, 0x64,
    0x27, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x64, 0x0a, 0x20, 0x74,
    0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x20, 0x69, 0x73, 0x20, 0x61, 0x73, 0x73, 0x75, 0x6d, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x6f,
    0x6e, 0x6c, 0x79, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x61, 0x74, 0x0a, 0x20,
    0x73, 0x6c, 0x61, 0x76, 0x65, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x15, 0x01, 0x12, 0x04,
    0xa9, 0x06, 0x08, 0x0f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x00, 0x12, 0x04, 0xaa, 0x06,
    0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x04, 0x12, 0x04, 0xaa, 0x06, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x06, 0x12, 0x04, 0xaa, 0x06, 0x0b, 0x12,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaa, 0x06, 0x13, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaa, 0x06, 0x1e, 0x1f, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x15, 0x02, 0x01, 0x12, 0x04, 0xab, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x15, 0x02, 0x01, 0x04, 0x12, 0x04, 0xab, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x15, 0x02, 0x01, 0x06, 0x12, 0x04, 0xab, 0x06, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xab, 0x06, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xab, 0x06, 0x20, 0x21, 0x0a, 0x77, 0x0a, 0x02, 0x04, 0x16, 0x12, 0x06,
    0xb3, 0x06, 0x00, 0xe5, 0x06, 0x01, 0x1a, 0x69, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72,
    0x69, 0x62, 0x65, 0x73, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x73, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x6f, 0x6e,
    0x20, 0x61, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x2e, 0x20, 0x41, 0x6e, 0x20, 0x6f, 0x66, 0x66,
    0x65, 0x72, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
    0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6f, 0x6d,
    0x20, 0x61, 0x20, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x2e,
    0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x16, 0x01, 0x12, 0x04, 0xb3, 0x06, 0x08, 0x0d, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x16, 0x02, 0x00, 0x12, 0x04, 0xb4, 0x06, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb4, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x00, 0x06, 0x12, 0x04, 0xb4, 0x06, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xb4, 0x06, 0x13, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xb4, 0x06, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x01,
    0x12, 0x04, 0xb5, 0x06, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xb5, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x06, 0x12, 0x04,
    0xb5, 0x06, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb5,
    0x06, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb5, 0x06,
    0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x02, 0x12, 0x04, 0xb6, 0x06, 0x02, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb6, 0x06, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x06, 0x12, 0x04, 0xb6, 0x06, 0x0b, 0x12, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb6, 0x06, 0x13, 0x1b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb6, 0x06, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x16, 0x02, 0x03, 0x12, 0x04, 0xb7, 0x06, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xb7, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x03, 0x05, 0x12, 0x04, 0xb7, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xb7, 0x06, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x03,
    0x12, 0x04, 0xb7, 0x06, 0x1d, 0x1e, 0x0a, 0x3f, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x04, 0x12, 0x04,
    0xba, 0x06, 0x02, 0x17, 0x1a, 0x31, 0x20, 0x55, 0x52, 0x4c, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x72,
    0x65, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6c, 0x61, 0x76,
    0x65, 0x20, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x68, 0x6f, 0x73, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xba, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x06, 0x12,
    0x04, 0xba, 0x06, 0x0b, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xba, 0x06, 0x0f, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x03, 0x12, 0x04, 0xba,
    0x06, 0x15, 0x16, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x05, 0x12, 0x04, 0xbc, 0x06, 0x02,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x05, 0x04, 0x12, 0x04, 0xbc, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x05, 0x06, 0x12, 0x04, 0xbc, 0x06, 0x0b, 0x13, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x05, 0x01, 0x12, 0x04, 0xbc, 0x06, 0x14, 0x1d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x05, 0x03, 0x12, 0x04, 0xbc, 0x06, 0x20, 0x21, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x16, 0x02, 0x06, 0x12, 0x04, 0xbd, 0x06, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x06, 0x04, 0x12, 0x04, 0xbd, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x06, 0x06, 0x12, 0x04, 0xbd, 0x06, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x06, 0x01, 0x12, 0x04, 0xbd, 0x06, 0x15, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06,
    0x03, 0x12, 0x04, 0xbd, 0x06, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x07, 0x12,
    0x04, 0xbe, 0x06, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x04, 0x12, 0x04,
    0xbe, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x06, 0x12, 0x04, 0xbe,
    0x06, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x01, 0x12, 0x04, 0xbe, 0x06,
    0x16, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x03, 0x12, 0x04, 0xbe, 0x06, 0x25,
    0x26, 0x0a, 0x4c, 0x0a, 0x04, 0x04, 0x16, 0x03, 0x00, 0x12, 0x06, 0xc1, 0x06, 0x02, 0xe4, 0x06,
    0x03, 0x1a, 0x3c, 0x20, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x6f,
    0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61,
    0x6e, 0x20, 0x62, 0x65, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x65, 0x64, 0x20, 0x61,
    0x67, 0x61, 0x69, 0x6e, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x03, 0x00, 0x01, 0x12, 0x04, 0xc1, 0x06, 0x0a, 0x13, 0x0a, 0x10,
    0x0a, 0x06, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00, 0x12, 0x06, 0xc2, 0x06, 0x04, 0xc8, 0x06, 0x05,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00, 0x01, 0x12, 0x04, 0xc2, 0x06, 0x09,
    0x0d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xc3,
    0x06, 0x06, 0x11, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xc3, 0x06, 0x06, 0x0c, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00,
    0x02, 0x00, 0x02, 0x12, 0x04, 0xc3, 0x06, 0x0f, 0x10, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x16, 0x03,
    0x00, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xc4, 0x06, 0x06, 0x12, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x16, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc4, 0x06, 0x06, 0x0d, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xc4, 0x06, 0x10,
    0x11, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xc5,
    0x06, 0x06, 0x14, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xc5, 0x06, 0x06, 0x0f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00,
    0x02, 0x02, 0x02, 0x12, 0x04, 0xc5, 0x06, 0x12, 0x13, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x16, 0x03,
    0x00, 0x04, 0x00, 0x02, 0x03, 0x12, 0x04, 0xc6, 0x06, 0x06, 0x11, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x16, 0x03, 0x00, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc6, 0x06, 0x06, 0x0c, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00, 0x02, 0x03, 0x02, 0x12, 0x04, 0xc6, 0x06, 0x0f,
    0x10, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00, 0x02, 0x04, 0x12, 0x04, 0xc7,
    0x06, 0x06, 0x12, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00, 0x02, 0x04, 0x01,
    0x12, 0x04, 0xc7, 0x06, 0x06, 0x0d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x04, 0x00,
    0x02, 0x04, 0x02, 0x12, 0x04, 0xc7, 0x06, 0x10, 0x11, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x16, 0x03,
    0x00, 0x03, 0x00, 0x12, 0x06, 0xca, 0x06, 0x04, 0xcc, 0x06, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x16, 0x03, 0x00, 0x03, 0x00, 0x01, 0x12, 0x04, 0xca, 0x06, 0x0c, 0x12, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x16, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xcb, 0x06, 0x06, 0x27, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcb, 0x06, 0x06,
    0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x06, 0x12, 0x04,
    0xcb, 0x06, 0x0f, 0x17, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xcb, 0x06, 0x18, 0x22, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03,
    0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcb, 0x06, 0x25, 0x26, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x16,
    0x03, 0x00, 0x03, 0x01, 0x12, 0x06, 0xce, 0x06, 0x04, 0xd0, 0x06, 0x05, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x16, 0x03, 0x00, 0x03, 0x01, 0x01, 0x12, 0x04, 0xce, 0x06, 0x0c, 0x13, 0x0a, 0x10, 0x0a,
    0x08, 0x04, 0x16, 0x03, 0x00, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xcf, 0x06, 0x06, 0x26, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcf, 0x06,
    0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x01, 0x02, 0x00, 0x06, 0x12,
    0x04, 0xcf, 0x06, 0x0f, 0x17, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x01, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xcf, 0x06, 0x18, 0x21, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00,
    0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcf, 0x06, 0x24, 0x25, 0x0a, 0x10, 0x0a, 0x06, 0x04,
    0x16, 0x03, 0x00, 0x03, 0x02, 0x12, 0x06, 0xd2, 0x06, 0x04, 0xd4, 0x06, 0x05, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x16, 0x03, 0x00, 0x03, 0x02, 0x01, 0x12, 0x04, 0xd2, 0x06, 0x0c, 0x15, 0x0a, 0x10,
    0x0a, 0x08, 0x04, 0x16, 0x03, 0x00, 0x03, 0x02, 0x02, 0x00, 0x12, 0x04, 0xd3, 0x06, 0x06, 0x26,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd3,
    0x06, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x02, 0x02, 0x00, 0x06,
    0x12, 0x04, 0xd3, 0x06, 0x0f, 0x17, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x02,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xd3, 0x06, 0x18, 0x21, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03,
    0x00, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd3, 0x06, 0x24, 0x25, 0x0a, 0x10, 0x0a, 0x06,
    0x04, 0x16, 0x03, 0x00, 0x03, 0x03, 0x12, 0x06, 0xd6, 0x06, 0x04, 0xd8, 0x06, 0x05, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x03, 0x03, 0x01, 0x12, 0x04, 0xd6, 0x06, 0x0c, 0x12, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x16, 0x03, 0x00, 0x03, 0x03, 0x02, 0x00, 0x12, 0x04, 0xd7, 0x06, 0x06,
    0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xd7, 0x06, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x03, 0x02, 0x00,
    0x06, 0x12, 0x04, 0xd7, 0x06, 0x0f, 0x17, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03,
    0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd7, 0x06, 0x18, 0x1f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16,
    0x03, 0x00, 0x03, 0x03, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd7, 0x06, 0x22, 0x23, 0x0a, 0x10, 0x0a,
    0x06, 0x04, 0x16, 0x03, 0x00, 0x03, 0x04, 0x12, 0x06, 0xda, 0x06, 0x04, 0xdc, 0x06, 0x05, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x03, 0x04, 0x01, 0x12, 0x04, 0xda, 0x06, 0x0c, 0x13,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x16, 0x03, 0x00, 0x03, 0x04, 0x02, 0x00, 0x12, 0x04, 0xdb, 0x06,
    0x06, 0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x04, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xdb, 0x06, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00, 0x03, 0x04, 0x02,
    0x00, 0x06, 0x12, 0x04, 0xdb, 0x06, 0x0f, 0x17, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x16, 0x03, 0x00,
    0x03, 0x04, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdb, 0x06, 0x18, 0x1f, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x16, 0x03, 0x00, 0x03, 0x04, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdb, 0x06, 0x22, 0x23, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x16, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xde, 0x06, 0x04, 0x1b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xde, 0x06, 0x04, 0x0c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x00, 0x06, 0x12, 0x04, 0xde, 0x06, 0x0d, 0x11,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xde, 0x06, 0x12,
    0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xde, 0x06,
    0x19, 0x1a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x16, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xdf, 0x06,
    0x04, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdf,
    0x06, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x01, 0x06, 0x12, 0x04,
    0xdf, 0x06, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xdf, 0x06, 0x14, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xdf, 0x06, 0x1d, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x16, 0x03, 0x00, 0x02, 0x02,
    0x12, 0x04, 0xe0, 0x06, 0x04, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xe0, 0x06, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02,
    0x02, 0x06, 0x12, 0x04, 0xe0, 0x06, 0x0d, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xe0, 0x06, 0x15, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03,
    0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe0, 0x06, 0x1f, 0x20, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x16,
    0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xe1, 0x06, 0x04, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16,
    0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe1, 0x06, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x16, 0x03, 0x00, 0x02, 0x03, 0x06, 0x12, 0x04, 0xe1, 0x06, 0x0d, 0x16, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x16, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xe1, 0x06, 0x17, 0x20, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xe1, 0x06, 0x23, 0x24, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x16, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xe2, 0x06, 0x04, 0x1f, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0xe2, 0x06, 0x04, 0x0c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x04, 0x06, 0x12, 0x04, 0xe2, 0x06, 0x0d, 0x13,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xe2, 0x06, 0x14,
    0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xe2, 0x06,
    0x1d, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x16, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xe3, 0x06,
    0x04, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0xe3,
    0x06, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x05, 0x06, 0x12, 0x04,
    0xe3, 0x06, 0x0d, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12,
    0x04, 0xe3, 0x06, 0x15, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x05, 0x03,
    0x12, 0x04, 0xe3, 0x06, 0x1f, 0x20, 0x0a, 0xdb, 0x02, 0x0a, 0x02, 0x04, 0x17, 0x12, 0x06, 0xef,
    0x06, 0x00, 0x8a, 0x07, 0x01, 0x1a, 0xcc, 0x02, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72,
    0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2e, 0x20, 0x50, 0x61, 0x73,
    0x73, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68,
    0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77,
    0x61, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x20, 0x28, 0x73, 0x65, 0x65, 0x20, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
    0x72, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x3a, 0x3a, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x54,
    0x61, 0x73, 0x6b, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x0a, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x3a, 0x3a, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x54, 0x61, 0x73, 0x6b, 0x29, 0x2e,
    0x20, 0x45, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72,
    0x49, 0x6e, 0x66, 0x6f, 0x20, 0x6f, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49,
    0x6e, 0x66, 0x6f, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65,
    0x74, 0x2e, 0x0a, 0x20, 0x41, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20,
    0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73, 0x75,
    0x62, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x0a, 0x20,
    0x6d, 0x65, 0x61, 0x6e, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61,
    0x6d, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x63, 0x61, 0x6e, 0x20,
    0x72, 0x65, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x45,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x73, 0x74, 0x72, 0x75,
    0x63, 0x74, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x17, 0x01, 0x12, 0x04, 0xef, 0x06, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x00, 0x12, 0x04, 0xf0, 0x06, 0x02, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf0, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf0, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf0, 0x06, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf0, 0x06, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x17, 0x02, 0x01, 0x12, 0x04, 0xf1, 0x06, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xf1, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01,
    0x06, 0x12, 0x04, 0xf1, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xf1, 0x06, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xf1, 0x06, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x02, 0x12, 0x04, 0xf2,
    0x06, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf2, 0x06,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x06, 0x12, 0x04, 0xf2, 0x06, 0x0b,
    0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf2, 0x06, 0x13, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf2, 0x06, 0x1e, 0x1f, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x03, 0x12, 0x04, 0xf3, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf3, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x03, 0x06, 0x12, 0x04, 0xf3, 0x06, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf3, 0x06, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xf3, 0x06, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02,
    0x04, 0x12, 0x04, 0xf4, 0x06, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xf4, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x04, 0x06, 0x12,
    0x04, 0xf4, 0x06, 0x0b, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xf4, 0x06, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x04, 0x03, 0x12, 0x04, 0xf4,
    0x06, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x05, 0x12, 0x04, 0xf5, 0x06, 0x02,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x05, 0x04, 0x12, 0x04, 0xf5, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x05, 0x06, 0x12, 0x04, 0xf5, 0x06, 0x0b, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x05, 0x01, 0x12, 0x04, 0xf5, 0x06, 0x17, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x05, 0x03, 0x12, 0x04, 0xf5, 0x06, 0x21, 0x22, 0x0a, 0x82, 0x01,
    0x0a, 0x04, 0x04, 0x17, 0x02, 0x06, 0x12, 0x04, 0xf8, 0x06, 0x02, 0x27, 0x1a, 0x74, 0x20, 0x54,
    0x61, 0x73, 0x6b, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74,
    0x68, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x77, 0x69,
    0x6c, 0x6c, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f,
    0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x61, 0x73, 0x20, 0x70, 0x61, 0x72, 0x74, 0x0a,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x70, 0x61,
    0x69, 0x72, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61,
    0x73, 0x6b, 0x27, 0x73, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x04, 0x12, 0x04, 0xf8, 0x06, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x06, 0x12, 0x04, 0xf8, 0x06, 0x0b, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x01, 0x12, 0x04, 0xf8, 0x06, 0x19, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x03, 0x12, 0x04, 0xf8, 0x06, 0x25, 0x26, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x17, 0x02, 0x07, 0x12, 0x04, 0xf9, 0x06, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x07, 0x04, 0x12, 0x04, 0xf9, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x07, 0x05, 0x12, 0x04, 0xf9, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x07, 0x01, 0x12, 0x04, 0xf9, 0x06, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x07, 0x03, 0x12, 0x04, 0xf9, 0x06, 0x18, 0x19, 0x0a, 0x8c, 0x01, 0x0a, 0x04, 0x04, 0x17, 0x02,
    0x08, 0x12, 0x04, 0xfc, 0x06, 0x02, 0x28, 0x1a, 0x7e, 0x20, 0x41, 0x20, 0x68, 0x65, 0x61, 0x6c,
    0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x28, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79,
    0x20, 0x69, 0x6e, 0x20, 0x2a, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2a, 0x20, 0x61, 0x6e, 0x64, 0x20,
    0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x0a, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74,
    0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x62, 0x65, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x54, 0x61, 0x73, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x27, 0x73, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x61, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64,
    0x49, 0x6e, 0x66, 0x6f, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x08, 0x04,
    0x12, 0x04, 0xfc, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x08, 0x06, 0x12,
    0x04, 0xfc, 0x06, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x08, 0x01, 0x12, 0x04,
    0xfc, 0x06, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x08, 0x03, 0x12, 0x04, 0xfc,
    0x06, 0x26, 0x27, 0x0a, 0xd3, 0x02, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x09, 0x12, 0x04, 0x83, 0x07,
    0x02, 0x1e, 0x1a, 0xc4, 0x02, 0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x61, 0x72, 0x65,
    0x20, 0x66, 0x72, 0x65, 0x65, 0x2d, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68,
    0x20, 0x61, 0x72, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6f, 0x73, 0x65, 0x64, 0x20, 0x74, 0x68, 0x72,
    0x6f, 0x75, 0x67, 0x68, 0x0a, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x20, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73,
    0x2e, 0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x65, 0x64,
    0x20, 0x6f, 0x72, 0x0a, 0x20, 0x61, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x6f, 0x6e, 0x20,
    0x62, 0x79, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x69, 0x74, 0x73, 0x65, 0x6c, 0x66, 0x2e,
    0x20, 0x41, 0x73, 0x20, 0x6f, 0x70, 0x70, 0x6f, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x2c, 0x20, 0x6c,
    0x61, 0x62, 0x65, 0x6c, 0x73, 0x0a, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x6b,
    0x65, 0x70, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x6f, 0x6e,
    0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73, 0x6c, 0x61, 0x76,
    0x65, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65,
    0x72, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x2c, 0x0a, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20,
    0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74,
    0x6f, 0x20, 0x74, 0x61, 0x67, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x20, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x2d, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x6d, 0x65,
    0x74, 0x61, 0x2d, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x09, 0x04, 0x12, 0x04, 0x83, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x09,
    0x06, 0x12, 0x04, 0x83, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x09, 0x01,
    0x12, 0x04, 0x83, 0x07, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x09, 0x03, 0x12,
    0x04, 0x83, 0x07, 0x1b, 0x1d, 0x0a, 0xf1, 0x01, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x0a, 0x12, 0x04,
    0x89, 0x07, 0x02, 0x28, 0x1a, 0xe2, 0x01, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20,
    0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61,
    0x73, 0x6b, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x69, 0x6e,
    0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x65, 0x64, 0x0a, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x63,
    0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x6f, 0x6e, 0x20, 0x62, 0x79, 0x20, 0x4d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6f, 0x20, 0x61,
    0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65,
    0x72, 0x79, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x75, 0x73,
    0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x61, 0x73, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73,
    0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x0a, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
    0x65, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x66, 0x6f,
    0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x0a, 0x04, 0x12, 0x04, 0x89, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0a,
    0x06, 0x12, 0x04, 0x89, 0x07, 0x0b, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0a, 0x01,
    0x12, 0x04, 0x89, 0x07, 0x19, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0a, 0x03, 0x12,
    0x04, 0x89, 0x07, 0x25, 0x27, 0x0a, 0xa6, 0x02, 0x0a, 0x02, 0x05, 0x01, 0x12, 0x06, 0x94, 0x07,
    0x00, 0x9d, 0x07, 0x01, 0x1a, 0x97, 0x02, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69,
    0x62, 0x65, 0x73, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x74, 0x61, 0x73,
    0x6b, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x73, 0x2e, 0x20, 0x49, 0x4d, 0x50, 0x4f, 0x52, 0x54,
    0x41, 0x4e, 0x54, 0x3a, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x61, 0x73, 0x73, 0x75, 0x6d,
    0x65, 0x73, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x0a, 0x20, 0x65,
    0x6e, 0x74, 0x65, 0x72, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x20, 0x73, 0x74,
    0x61, 0x74, 0x65, 0x73, 0x20, 0x28, 0x73, 0x65, 0x65, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x29,
    0x20, 0x69, 0x6d, 0x70, 0x6c, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20,
    0x69, 0x73, 0x20, 0x6e, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x65, 0x72, 0x0a, 0x20, 0x72, 0x75,
    0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x75, 0x73, 0x20, 0x63,
    0x6c, 0x65, 0x61, 0x6e, 0x20, 0x75, 0x70, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x68, 0x69, 0x6e,
    0x67, 0x20, 0x61, 0x73, 0x73, 0x6f, 0x63, 0x69, 0x61, 0x74, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74,
    0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x0a, 0x20, 0x28, 0x75, 0x6c, 0x74,
    0x69, 0x6d, 0x61, 0x74, 0x65, 0x6c, 0x79, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x69, 0x6e, 0x67,
    0x20, 0x61, 0x6e, 0x79, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x62,
    0x65, 0x69, 0x6e, 0x67, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x64, 0x20, 0x62, 0x79,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x61,
    0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x29, 0x2e, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x05, 0x01, 0x01, 0x12, 0x04, 0x94, 0x07, 0x05, 0x0e, 0x0a, 0x47, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x00, 0x12, 0x04, 0x95, 0x07, 0x02, 0x13, 0x22, 0x39, 0x20, 0x49, 0x6e, 0x69, 0x74,
    0x69, 0x61, 0x6c, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2e, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61,
    0x74, 0x65, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x75,
    0x73, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x95,
    0x07, 0x02, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x00, 0x02, 0x12, 0x04, 0x95, 0x07,
    0x11, 0x12, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x01, 0x12, 0x04, 0x96, 0x07, 0x02, 0x14,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0x96, 0x07, 0x02, 0x0f, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x02, 0x12, 0x04, 0x96, 0x07, 0x12, 0x13, 0x0a, 0x0c,
    0x0a, 0x04, 0x05, 0x01, 0x02, 0x02, 0x12, 0x04, 0x97, 0x07, 0x02, 0x13, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0x97, 0x07, 0x02, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x01, 0x02, 0x02, 0x02, 0x12, 0x04, 0x97, 0x07, 0x11, 0x12, 0x0a, 0x39, 0x0a, 0x04, 0x05, 0x01,
    0x02, 0x03, 0x12, 0x04, 0x98, 0x07, 0x02, 0x14, 0x22, 0x2b, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49,
    0x4e, 0x41, 0x4c, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x66, 0x69,
    0x6e, 0x69, 0x73, 0x68, 0x65, 0x64, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75,
    0x6c, 0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04,
    0x98, 0x07, 0x02, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03, 0x02, 0x12, 0x04, 0x98,
    0x07, 0x12, 0x13, 0x0a, 0x41, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x04, 0x12, 0x04, 0x99, 0x07, 0x02,
    0x12, 0x22, 0x33, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x4c, 0x2e, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66,
    0x75, 0x6c, 0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x04, 0x01, 0x12,
    0x04, 0x99, 0x07, 0x02, 0x0d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x04, 0x02, 0x12, 0x04,
    0x99, 0x07, 0x10, 0x11, 0x0a, 0x3e, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x05, 0x12, 0x04, 0x9a, 0x07,
    0x02, 0x12, 0x22, 0x30, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x4c, 0x2e, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x77, 0x61, 0x73, 0x20, 0x6b, 0x69, 0x6c, 0x6c,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x05, 0x01, 0x12, 0x04, 0x9a,
    0x07, 0x02, 0x0d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x05, 0x02, 0x12, 0x04, 0x9a, 0x07,
    0x10, 0x11, 0x0a, 0x41, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x06, 0x12, 0x04, 0x9b, 0x07, 0x02, 0x10,
    0x22, 0x33, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x4c, 0x2e, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x62, 0x75, 0x74,
    0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75,
    0x6c, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x06, 0x01, 0x12, 0x04,
    0x9b, 0x07, 0x02, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x06, 0x02, 0x12, 0x04, 0x9b,
    0x07, 0x0e, 0x0f, 0x0a, 0x41, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x07, 0x12, 0x04, 0x9c, 0x07, 0x02,
    0x11, 0x22, 0x33, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x4c, 0x2e, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65,
    0x72, 0x72, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x07, 0x01, 0x12,
    0x04, 0x9c, 0x07, 0x02, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x07, 0x02, 0x12, 0x04,
    0x9c, 0x07, 0x0f, 0x10, 0x0a, 0x39, 0x0a, 0x02, 0x04, 0x18, 0x12, 0x06, 0xa3, 0x07, 0x00, 0xe6,
    0x07, 0x01, 0x1a, 0x2b, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x73, 0x74, 0x61,
    0x74, 0x75, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x18, 0x01, 0x12, 0x04, 0xa3, 0x07, 0x08, 0x12, 0x0a, 0x41, 0x0a, 0x04,
    0x04, 0x18, 0x04, 0x00, 0x12, 0x06, 0xa5, 0x07, 0x02, 0xa9, 0x07, 0x03, 0x1a, 0x31, 0x20, 0x44,
    0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20,
    0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x04, 0x00, 0x01, 0x12, 0x04, 0xa5, 0x07, 0x07, 0x0d, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x18, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xa6, 0x07, 0x04, 0x16, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x18, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa6, 0x07, 0x04, 0x11, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xa6, 0x07, 0x14, 0x15,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xa7, 0x07, 0x04, 0x15,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa7, 0x07, 0x04,
    0x10, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xa7, 0x07,
    0x13, 0x14, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xa8, 0x07,
    0x04, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa8,
    0x07, 0x04, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04,
    0xa8, 0x07, 0x16, 0x17, 0x0a, 0xaf, 0x01, 0x0a, 0x04, 0x04, 0x18, 0x04, 0x01, 0x12, 0x06, 0xaf,
    0x07, 0x02, 0xc3, 0x07, 0x03, 0x1a, 0x9e, 0x01, 0x20, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x65,
    0x64, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64,
    0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x62, 0x6d, 0x61, 0x68,
    0x6c, 0x65, 0x72, 0x29, 0x3a, 0x20, 0x44, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x69,
    0x61, 0x74, 0x65, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x73, 0x6c, 0x61, 0x76,
    0x65, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e,
    0x73, 0x0a, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x20, 0x75, 0x6e, 0x68, 0x65, 0x61, 0x6c, 0x74,
    0x68, 0x79, 0x20, 0x76, 0x73, 0x2e, 0x20, 0x75, 0x6e, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
    0x72, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x61,
    0x6e, 0x63, 0x65, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x04, 0x01, 0x01, 0x12,
    0x04, 0xaf, 0x07, 0x07, 0x0d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x00, 0x12,
    0x04, 0xb0, 0x07, 0x04, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xb0, 0x07, 0x04, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x00,
    0x02, 0x12, 0x04, 0xb0, 0x07, 0x25, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02,
    0x01, 0x12, 0x04, 0xb1, 0x07, 0x04, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xb1, 0x07, 0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01,
    0x02, 0x01, 0x02, 0x12, 0x04, 0xb1, 0x07, 0x20, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04,
    0x01, 0x02, 0x02, 0x12, 0x04, 0xb2, 0x07, 0x04, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04,
    0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb2, 0x07, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18,
    0x04, 0x01, 0x02, 0x02, 0x02, 0x12, 0x04, 0xb2, 0x07, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x18, 0x04, 0x01, 0x02, 0x03, 0x12, 0x04, 0xb3, 0x07, 0x04, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x18, 0x04, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb3, 0x07, 0x04, 0x20, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x18, 0x04, 0x01, 0x02, 0x03, 0x02, 0x12, 0x04, 0xb3, 0x07, 0x23, 0x24, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x04, 0x12, 0x04, 0xb4, 0x07, 0x04, 0x21, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x04, 0x01, 0x12, 0x04, 0xb4, 0x07, 0x04, 0x1c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x04, 0x02, 0x12, 0x04, 0xb4, 0x07, 0x1f, 0x20, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x05, 0x12, 0x04, 0xb5, 0x07, 0x04, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x05, 0x01, 0x12, 0x04, 0xb5, 0x07, 0x04, 0x13,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x05, 0x02, 0x12, 0x04, 0xb5, 0x07, 0x16,
    0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x06, 0x12, 0x04, 0xb6, 0x07, 0x04,
    0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x06, 0x01, 0x12, 0x04, 0xb6, 0x07,
    0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x06, 0x02, 0x12, 0x04, 0xb6,
    0x07, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x07, 0x12, 0x04, 0xb7,
    0x07, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x07, 0x01, 0x12, 0x04,
    0xb7, 0x07, 0x04, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x07, 0x02, 0x12,
    0x04, 0xb7, 0x07, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x08, 0x12,
    0x04, 0xb8, 0x07, 0x04, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x08, 0x01,
    0x12, 0x04, 0xb8, 0x07, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x08,
    0x02, 0x12, 0x04, 0xb8, 0x07, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02,
    0x09, 0x12, 0x04, 0xb9, 0x07, 0x04, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02,
    0x09, 0x01, 0x12, 0x04, 0xb9, 0x07, 0x04, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01,
    0x02, 0x09, 0x02, 0x12, 0x04, 0xb9, 0x07, 0x1a, 0x1b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04,
    0x01, 0x02, 0x0a, 0x12, 0x04, 0xba, 0x07, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04,
    0x01, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xba, 0x07, 0x04, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18,
    0x04, 0x01, 0x02, 0x0a, 0x02, 0x12, 0x04, 0xba, 0x07, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x18, 0x04, 0x01, 0x02, 0x0b, 0x12, 0x04, 0xbb, 0x07, 0x04, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x18, 0x04, 0x01, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xbb, 0x07, 0x04, 0x1c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x18, 0x04, 0x01, 0x02, 0x0b, 0x02, 0x12, 0x04, 0xbb, 0x07, 0x1f, 0x21, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0c, 0x12, 0x04, 0xbc, 0x07, 0x04, 0x23, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xbc, 0x07, 0x04, 0x1d, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0c, 0x02, 0x12, 0x04, 0xbc, 0x07, 0x20, 0x22, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0d, 0x12, 0x04, 0xbd, 0x07, 0x04, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0d, 0x01, 0x12, 0x04, 0xbd, 0x07, 0x04, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0d, 0x02, 0x12, 0x04, 0xbd, 0x07, 0x1b,
    0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0e, 0x12, 0x04, 0xbe, 0x07, 0x04,
    0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xbe, 0x07,
    0x04, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0e, 0x02, 0x12, 0x04, 0xbe,
    0x07, 0x1d, 0x1f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0f, 0x12, 0x04, 0xbf,
    0x07, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0f, 0x01, 0x12, 0x04,
    0xbf, 0x07, 0x04, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x0f, 0x02, 0x12,
    0x04, 0xbf, 0x07, 0x1b, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02, 0x10, 0x12,
    0x04, 0xc0, 0x07, 0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x10, 0x01,
    0x12, 0x04, 0xc0, 0x07, 0x04, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02, 0x10,
    0x02, 0x12, 0x04, 0xc0, 0x07, 0x1a, 0x1c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04, 0x01, 0x02,
    0x11, 0x12, 0x04, 0xc1, 0x07, 0x04, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01, 0x02,
    0x11, 0x01, 0x12, 0x04, 0xc1, 0x07, 0x04, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04, 0x01,
    0x02, 0x11, 0x02, 0x12, 0x04, 0xc1, 0x07, 0x1f, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x18, 0x04,
    0x01, 0x02, 0x12, 0x12, 0x04, 0xc2, 0x07, 0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18, 0x04,
    0x01, 0x02, 0x12, 0x01, 0x12, 0x04, 0xc2, 0x07, 0x04, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x18,
    0x04, 0x01, 0x02, 0x12, 0x02, 0x12, 0x04, 0xc2, 0x07, 0x1a, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x18, 0x02, 0x00, 0x12, 0x04, 0xc5, 0x07, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xc5, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00,
    0x06, 0x12, 0x04, 0xc5, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xc5, 0x07, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xc5, 0x07, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x01, 0x12, 0x04, 0xc6,
    0x07, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc6, 0x07,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x06, 0x12, 0x04, 0xc6, 0x07, 0x0b,
    0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc6, 0x07, 0x15, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc6, 0x07, 0x1d, 0x1e, 0x0a,
    0x32, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x02, 0x12, 0x04, 0xc7, 0x07, 0x02, 0x1e, 0x22, 0x24, 0x20,
    0x50, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x20, 0x65, 0x78, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x74, 0x61, 0x74,
    0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc7, 0x07,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc7, 0x07, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc7, 0x07, 0x12, 0x19,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc7, 0x07, 0x1c, 0x1d, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x03, 0x12, 0x04, 0xc8, 0x07, 0x02, 0x1d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc8, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x03, 0x06, 0x12, 0x04, 0xc8, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc8, 0x07, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xc8, 0x07, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02,
    0x04, 0x12, 0x04, 0xc9, 0x07, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xc9, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x04, 0x06, 0x12,
    0x04, 0xc9, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xc9, 0x07, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x04, 0x03, 0x12, 0x04, 0xc9,
    0x07, 0x1b, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x05, 0x12, 0x04, 0xca, 0x07, 0x02,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x05, 0x04, 0x12, 0x04, 0xca, 0x07, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x05, 0x05, 0x12, 0x04, 0xca, 0x07, 0x0b, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x05, 0x01, 0x12, 0x04, 0xca, 0x07, 0x11, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x05, 0x03, 0x12, 0x04, 0xca, 0x07, 0x18, 0x19, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x18, 0x02, 0x06, 0x12, 0x04, 0xcb, 0x07, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x06, 0x04, 0x12, 0x04, 0xcb, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x06, 0x06, 0x12, 0x04, 0xcb, 0x07, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x06, 0x01, 0x12, 0x04, 0xcb, 0x07, 0x13, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x06,
    0x03, 0x12, 0x04, 0xcb, 0x07, 0x1e, 0x1f, 0x0a, 0x30, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x07, 0x12,
    0x04, 0xcc, 0x07, 0x02, 0x26, 0x22, 0x22, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x62, 0x65, 0x6e,
    0x68, 0x29, 0x3a, 0x20, 0x55, 0x73, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65,
    0x72, 0x2f, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x07, 0x04, 0x12, 0x04, 0xcc, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x07,
    0x06, 0x12, 0x04, 0xcc, 0x07, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x07, 0x01,
    0x12, 0x04, 0xcc, 0x07, 0x16, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x07, 0x03, 0x12,
    0x04, 0xcc, 0x07, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x08, 0x12, 0x04, 0xcd,
    0x07, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x08, 0x04, 0x12, 0x04, 0xcd, 0x07,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x08, 0x05, 0x12, 0x04, 0xcd, 0x07, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x08, 0x01, 0x12, 0x04, 0xcd, 0x07, 0x12, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x08, 0x03, 0x12, 0x04, 0xcd, 0x07, 0x1e, 0x1f, 0x0a,
    0xde, 0x03, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x09, 0x12, 0x04, 0xd8, 0x07, 0x02, 0x1b, 0x1a, 0xcf,
    0x03, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x61, 0x72, 0x65, 0x20, 0x64, 0x65, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x65, 0x64, 0x20, 0x72, 0x65,
    0x6c, 0x69, 0x61, 0x62, 0x6c, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63,
    0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x0a, 0x20, 0x69, 0x6e,
    0x63, 0x6c, 0x75, 0x64, 0x65, 0x20, 0x61, 0x20, 0x27, 0x75, 0x75, 0x69, 0x64, 0x27, 0x2e, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6f,
    0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x65, 0x64, 0x20, 0x64, 0x65, 0x6c, 0x69, 0x76, 0x65, 0x72,
    0x65, 0x64, 0x20, 0x6f, 0x6e, 0x63, 0x65, 0x0a, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61,
    0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x20, 0x53, 0x63,
    0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x73, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x63, 0x68, 0x6f,
    0x6f, 0x73, 0x65, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x65,
    0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x6c, 0x79, 0x20, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77,
    0x6c, 0x65, 0x64, 0x67, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65, 0x73, 0x20, 0x6f,
    0x72, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75,
    0x6c, 0x65, 0x72, 0x0a, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x69, 0x6d, 0x70, 0x6c,
    0x69, 0x63, 0x69, 0x74, 0x6c, 0x79, 0x20, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64,
    0x67, 0x65, 0x20, 0x28, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x29, 0x2e, 0x0a, 0x0a, 0x20,
    0x54, 0x4f, 0x44, 0x4f, 0x28, 0x62, 0x6d, 0x61, 0x68, 0x6c, 0x65, 0x72, 0x29, 0x3a, 0x20, 0x54,
    0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79,
    0x20, 0x6f, 0x76, 0x65, 0x72, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x69, 0x6e, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x0a, 0x20, 0x64,
    0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x65,
    0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x20,
    0x74, 0x6f, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x52, 0x46, 0x43, 0x2d, 0x34,
    0x31, 0x32, 0x32, 0x20, 0x55, 0x55, 0x49, 0x44, 0x20, 0x69, 0x66, 0x20, 0x75, 0x73, 0x69, 0x6e,
    0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x41, 0x50, 0x49, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x09, 0x04, 0x12, 0x04, 0xd8, 0x07, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x09, 0x05, 0x12, 0x04, 0xd8, 0x07, 0x0b, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x09, 0x01, 0x12, 0x04, 0xd8, 0x07, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x09, 0x03, 0x12, 0x04, 0xd8, 0x07, 0x18, 0x1a, 0x0a, 0xa3, 0x01, 0x0a,
    0x04, 0x04, 0x18, 0x02, 0x0a, 0x12, 0x04, 0xdd, 0x07, 0x02, 0x1c, 0x1a, 0x94, 0x01, 0x20, 0x44,
    0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65,
    0x65, 0x6e, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x62, 0x65, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x0a, 0x20, 0x28, 0x74, 0x72,
    0x75, 0x65, 0x29, 0x20, 0x6f, 0x72, 0x20, 0x75, 0x6e, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79,
    0x20, 0x28, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x29, 0x20, 0x61, 0x63, 0x63, 0x6f, 0x72, 0x64, 0x69,
    0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68,
    0x43, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x6e, 0x0a, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x6e, 0x66, 0x6f,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xdd, 0x07, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xdd, 0x07, 0x0b, 0x0f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xdd, 0x07, 0x10, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xdd, 0x07, 0x1a, 0x1b, 0x0a, 0xe1,
    0x02, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x0b, 0x12, 0x04, 0xe5, 0x07, 0x02, 0x1e, 0x1a, 0xd2, 0x02,
    0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x72, 0x65, 0x65,
    0x2d, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20,
    0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x65, 0x78, 0x70, 0x6f, 0x73, 0x65, 0x64, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x0a,
    0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73, 0x6c, 0x61, 0x76,
    0x65, 0x20, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x2e, 0x20, 0x4c, 0x61, 0x62,
    0x65, 0x6c, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20,
    0x69, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x0a, 0x20,
    0x61, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x6f, 0x6e, 0x20, 0x62, 0x79, 0x20, 0x4d, 0x65,
    0x73, 0x6f, 0x73, 0x20, 0x69, 0x74, 0x73, 0x65, 0x6c, 0x66, 0x2e, 0x20, 0x41, 0x73, 0x20, 0x6f,
    0x70, 0x70, 0x6f, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61,
    0x74, 0x61, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x2c, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73,
    0x0a, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x6b, 0x65, 0x70, 0x74, 0x20, 0x69,
    0x6e, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x6d, 0x61, 0x73, 0x74,
    0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x20, 0x70, 0x72, 0x6f,
    0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65, 0x66, 0x6f, 0x72,
    0x65, 0x2c, 0x0a, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c,
    0x64, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x61, 0x67,
    0x20, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x2d, 0x77,
    0x65, 0x69, 0x67, 0x68, 0x74, 0x0a, 0x20, 0x6d, 0x65, 0x74, 0x61, 0x2d, 0x64, 0x61, 0x74, 0x61,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xe5, 0x07, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0b, 0x06, 0x12, 0x04, 0xe5, 0x07, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xe5, 0x07, 0x12, 0x18, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xe5, 0x07, 0x1b, 0x1d, 0x0a, 0x95,
    0x01, 0x0a, 0x02, 0x04, 0x19, 0x12, 0x06, 0xed, 0x07, 0x00, 0xf5, 0x07, 0x01, 0x1a, 0x86, 0x01,
    0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x70, 0x6f, 0x73,
    0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x65,
    0x64, 0x20, 0x74, 0x6f, 0x20, 0x75, 0x6e, 0x75, 0x73, 0x65, 0x64, 0x20, 0x72, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x73, 0x0a, 0x20, 0x28, 0x73, 0x65, 0x65, 0x20, 0x53, 0x63, 0x68, 0x65,
    0x64, 0x75, 0x6c, 0x65, 0x72, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x3a, 0x3a, 0x6c, 0x61, 0x75,
    0x6e, 0x63, 0x68, 0x54, 0x61, 0x73, 0x6b, 0x73, 0x29, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x66,
    0x6c, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63,
    0x61, 0x74, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x19, 0x01, 0x12, 0x04, 0xed,
    0x07, 0x08, 0x0f, 0x0a, 0x84, 0x03, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x00, 0x12, 0x04, 0xf4, 0x07,
    0x02, 0x35, 0x1a, 0xf5, 0x02, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f,
    0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 0x75, 0x6e, 0x75, 0x73, 0x65, 0x64, 0x20, 0x72, 0x65,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x72, 0x65, 0x66, 0x75, 0x73, 0x65, 0x64, 0x2e,
    0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x75,
    0x6e, 0x75, 0x73, 0x65, 0x64, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73,
    0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65,
    0x72, 0x65, 0x64, 0x20, 0x72, 0x65, 0x66, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20,
    0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x0a, 0x20, 0x28, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x29, 0x20, 0x72,
    0x65, 0x67, 0x61, 0x72, 0x64, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x77, 0x68, 0x65,
    0x74, 0x68, 0x65, 0x72, 0x20, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x20, 0x77, 0x61, 0x73,
    0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x53, 0x63, 0x68, 0x65,
    0x64, 0x75, 0x6c, 0x65, 0x72, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x3a, 0x3a, 0x6c, 0x61, 0x75,
    0x6e, 0x63, 0x68, 0x54, 0x61, 0x73, 0x6b, 0x73, 0x2e, 0x20, 0x59, 0x6f, 0x75, 0x20, 0x4d, 0x55,
    0x53, 0x54, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x20,
    0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64,
    0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x20, 0x28, 0x69, 0x2e,
    0x65, 0x2e, 0x2c, 0x20, 0x67, 0x65, 0x74, 0x20, 0x61, 0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20,
    0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x0a, 0x20, 0x69, 0x6e, 0x63,
    0x6c, 0x75, 0x64, 0x65, 0x73, 0x20, 0x75, 0x6e, 0x75, 0x73, 0x65, 0x64, 0x20, 0x72, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x73, 0x6f, 0x6f, 0x6e, 0x65, 0x72, 0x20, 0x6f, 0x72,
    0x20, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xf4, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xf4, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xf4, 0x07, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xf4, 0x07, 0x23, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x08, 0x12,
    0x04, 0xf4, 0x07, 0x25, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x07, 0x12, 0x04,
    0xf4, 0x07, 0x30, 0x33, 0x0a, 0xa3, 0x01, 0x0a, 0x02, 0x04, 0x1a, 0x12, 0x06, 0xfd, 0x07, 0x00,
    0x84, 0x08, 0x01, 0x1a, 0x94, 0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62,
    0x65, 0x73, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x6f, 0x66, 0x20, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x76,
    0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69,
    0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a, 0x20, 0x43, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x69, 0x6e, 0x20, 0x6f, 0x72, 0x64, 0x65,
    0x72, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x74, 0x20, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e,
    0x6d, 0x65, 0x6e, 0x74, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x20, 0x62,
    0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x0a,
    0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1a,
    0x01, 0x12, 0x04, 0xfd, 0x07, 0x08, 0x13, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a, 0x03, 0x00, 0x12,
    0x06, 0xfe, 0x07, 0x02, 0x81, 0x08, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x03, 0x00, 0x01,
    0x12, 0x04, 0xfe, 0x07, 0x0a, 0x12, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x00, 0x02, 0x00,
    0x12, 0x04, 0xff, 0x07, 0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x00, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xff, 0x07, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x00, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xff, 0x07, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x00,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xff, 0x07, 0x14, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03,
    0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xff, 0x07, 0x1b, 0x1c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a,
    0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0x80, 0x08, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a,
    0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x80, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1a, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x80, 0x08, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1a, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x80, 0x08, 0x14, 0x19, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1a, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x80, 0x08, 0x1c, 0x1d, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x1a, 0x02, 0x00, 0x12, 0x04, 0x83, 0x08, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1a, 0x02, 0x00, 0x04, 0x12, 0x04, 0x83, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1a, 0x02, 0x00, 0x06, 0x12, 0x04, 0x83, 0x08, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a,
    0x02, 0x00, 0x01, 0x12, 0x04, 0x83, 0x08, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x83, 0x08, 0x20, 0x21, 0x0a, 0x54, 0x0a, 0x02, 0x04, 0x1b, 0x12, 0x06,
    0x8a, 0x08, 0x00, 0x8d, 0x08, 0x01, 0x1a, 0x46, 0x2a, 0x0a, 0x20, 0x41, 0x20, 0x67, 0x65, 0x6e,
    0x65, 0x72, 0x69, 0x63, 0x20, 0x28, 0x6b, 0x65, 0x79, 0x2c, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65,
    0x29, 0x20, 0x70, 0x61, 0x69, 0x72, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x76,
    0x61, 0x72, 0x69, 0x6f, 0x75, 0x73, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x1b, 0x01, 0x12, 0x04, 0x8a, 0x08, 0x08, 0x11, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1b, 0x02, 0x00, 0x12, 0x04, 0x8b, 0x08, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x8b, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00,
    0x05, 0x12, 0x04, 0x8b, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x01,
    0x12, 0x04, 0x8b, 0x08, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x03, 0x12,
    0x04, 0x8b, 0x08, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x01, 0x12, 0x04, 0x8c,
    0x08, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8c, 0x08,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8c, 0x08, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8c, 0x08, 0x12, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8c, 0x08, 0x1a, 0x1b, 0x0a,
    0x2a, 0x0a, 0x02, 0x04, 0x1c, 0x12, 0x06, 0x93, 0x08, 0x00, 0x95, 0x08, 0x01, 0x1a, 0x1c, 0x2a,
    0x0a, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20,
    0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x1c, 0x01, 0x12, 0x04, 0x93, 0x08, 0x08, 0x12, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x00,
    0x12, 0x04, 0x94, 0x08, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x94, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x06, 0x12, 0x04,
    0x94, 0x08, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94,
    0x08, 0x15, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94, 0x08,
    0x21, 0x22, 0x0a, 0xc0, 0x02, 0x0a, 0x02, 0x04, 0x1d, 0x12, 0x06, 0xa1, 0x08, 0x00, 0xa4, 0x08,
    0x01, 0x1a, 0xb1, 0x02, 0x2a, 0x0a, 0x20, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61,
    0x6c, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x61, 0x72, 0x69, 0x6f, 0x75,
    0x73, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x75, 0x74,
    0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x0a,
    0x20, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a,
    0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x41, 0x20, 0x27, 0x70, 0x72, 0x69, 0x6e, 0x63,
    0x69, 0x70, 0x61, 0x6c, 0x27, 0x20, 0x69, 0x73, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65,
    0x6e, 0x74, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x27, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x27, 0x2e, 0x20, 0x54, 0x68,
    0x65, 0x0a, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65,
    0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,
    0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x68, 0x69, 0x6c, 0x65, 0x20, 0x74, 0x68, 0x65,
    0x0a, 0x20, 0x6c, 0x61, 0x74, 0x74, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x75,
    0x6e, 0x64, 0x65, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x27, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63,
    0x75, 0x74, 0x6f, 0x72, 0x73, 0x2f, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x72, 0x75, 0x6e, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1d, 0x01, 0x12, 0x04, 0xa1, 0x08,
    0x08, 0x12, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1d, 0x02, 0x00, 0x12, 0x04, 0xa2, 0x08, 0x02, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa2, 0x08, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa2, 0x08, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa2, 0x08, 0x12, 0x1b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa2, 0x08, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x1d, 0x02, 0x01, 0x12, 0x04, 0xa3, 0x08, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xa3, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xa3, 0x08, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xa3, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xa3, 0x08, 0x1a, 0x1b, 0x0a, 0xc0, 0x01, 0x0a, 0x02, 0x04, 0x1e, 0x12, 0x06, 0xac,
    0x08, 0x00, 0xae, 0x08, 0x01, 0x1a, 0xb1, 0x01, 0x2a, 0x0a, 0x20, 0x43, 0x72, 0x65, 0x64, 0x65,
    0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e,
    0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x61,
    0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x28,
    0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
    0x20, 0x27, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x27, 0x20, 0x61, 0x6e, 0x64, 0x20,
    0x27, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x27, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63,
    0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x64, 0x20, 0x61, 0x73, 0x0a, 0x20, 0x27, 0x70, 0x72, 0x69,
    0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x27, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x27, 0x73, 0x65, 0x63,
    0x72, 0x65, 0x74, 0x27, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6c,
    0x79, 0x29, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1e, 0x01,
    0x12, 0x04, 0xac, 0x08, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x00, 0x12, 0x04,
    0xad, 0x08, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xad,
    0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x06, 0x12, 0x04, 0xad, 0x08,
    0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xad, 0x08, 0x16,
    0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xad, 0x08, 0x24, 0x25,
    0x0a, 0x2e, 0x0a, 0x02, 0x04, 0x1f, 0x12, 0x06, 0xb4, 0x08, 0x00, 0xde, 0x08, 0x01, 0x1a, 0x20,
    0x2a, 0x0a, 0x20, 0x41, 0x43, 0x4c, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1f, 0x01, 0x12, 0x04, 0xb4, 0x08, 0x08, 0x0b, 0x0a, 0xcf, 0x01,
    0x0a, 0x04, 0x04, 0x1f, 0x03, 0x00, 0x12, 0x06, 0xba, 0x08, 0x02, 0xc2, 0x08, 0x03, 0x1a, 0xbe,
    0x01, 0x20, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x20, 0x61, 0x20, 0x73,
    0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x28, 0x73, 0x29, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x20,
    0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x28, 0x73, 0x29, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20,
    0x41, 0x43, 0x4c, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x0a, 0x20, 0x54, 0x6f, 0x20,
    0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x61,
    0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x45, 0x6e, 0x74, 0x69,
    0x74, 0x79, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x74, 0x73, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20,
    0x74, 0x6f, 0x20, 0x27, 0x41, 0x4e, 0x59, 0x27, 0x2e, 0x0a, 0x20, 0x54, 0x6f, 0x20, 0x64, 0x65,
    0x6e, 0x79, 0x20, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20,
    0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x74, 0x73, 0x20, 0x74,
    0x79, 0x70, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x27, 0x4e, 0x4f, 0x4e, 0x45, 0x27, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x03, 0x00, 0x01, 0x12, 0x04, 0xba, 0x08, 0x0a, 0x10, 0x0a, 0x10,
    0x0a, 0x06, 0x04, 0x1f, 0x03, 0x00, 0x04, 0x00, 0x12, 0x06, 0xbb, 0x08, 0x04, 0xbf, 0x08, 0x05,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03, 0x00, 0x04, 0x00, 0x01, 0x12, 0x04, 0xbb, 0x08, 0x09,
    0x0d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x1f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xbc,
    0x08, 0x06, 0x0f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x1f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xbc, 0x08, 0x06, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x1f, 0x03, 0x00, 0x04, 0x00,
    0x02, 0x00, 0x02, 0x12, 0x04, 0xbc, 0x08, 0x0d, 0x0e, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x1f, 0x03,
    0x00, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xbd, 0x08, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x1f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbd, 0x08, 0x06, 0x09, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x1f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xbd, 0x08, 0x0c,
    0x0d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x1f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xbe,
    0x08, 0x06, 0x0f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x1f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xbe, 0x08, 0x06, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x1f, 0x03, 0x00, 0x04, 0x00,
    0x02, 0x02, 0x02, 0x12, 0x04, 0xbe, 0x08, 0x0d, 0x0e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1f, 0x03,
    0x00, 0x02, 0x00, 0x12, 0x04, 0xc0, 0x08, 0x04, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03,
    0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc0, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f,
    0x03, 0x00, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc0, 0x08, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1f, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc0, 0x08, 0x12, 0x16, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1f, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc0, 0x08, 0x19, 0x1a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1f, 0x03, 0x00, 0x02, 0x00, 0x08, 0x12, 0x04, 0xc0, 0x08, 0x1b, 0x2b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1f, 0x03, 0x00, 0x02, 0x00, 0x07, 0x12, 0x04, 0xc0, 0x08, 0x26, 0x2a, 0x0a,
    0x27, 0x0a, 0x06, 0x04, 0x1f, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xc1, 0x08, 0x04, 0x1f, 0x22,
    0x17, 0x20, 0x49, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x4e,
    0x59, 0x2f, 0x4e, 0x4f, 0x4e, 0x45, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03, 0x00,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xc1, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03,
    0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc1, 0x08, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f,
    0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc1, 0x08, 0x14, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1f, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc1, 0x08, 0x1d, 0x1e, 0x0a, 0x17, 0x0a, 0x04,
    0x04, 0x1f, 0x03, 0x01, 0x12, 0x06, 0xc5, 0x08, 0x02, 0xcb, 0x08, 0x03, 0x1a, 0x07, 0x20, 0x41,
    0x43, 0x4c, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x03, 0x01, 0x01, 0x12, 0x04,
    0xc5, 0x08, 0x0a, 0x1b, 0x0a, 0x34, 0x0a, 0x06, 0x04, 0x1f, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04,
    0xc7, 0x08, 0x04, 0x23, 0x1a, 0x0b, 0x20, 0x53, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x2e,
    0x0a, 0x22, 0x17, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x70, 0x72,
    0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f,
    0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc7, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1f, 0x03, 0x01, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc7, 0x08, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1f, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc7, 0x08, 0x14, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1f, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc7, 0x08, 0x21, 0x22, 0x0a, 0x38,
    0x0a, 0x06, 0x04, 0x1f, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0xca, 0x08, 0x04, 0x1e, 0x1a, 0x0a,
    0x20, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x2e, 0x0a, 0x22, 0x1c, 0x20, 0x52, 0x6f, 0x6c,
    0x65, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20,
    0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03, 0x01,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xca, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03,
    0x01, 0x02, 0x01, 0x06, 0x12, 0x04, 0xca, 0x08, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f,
    0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xca, 0x08, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1f, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xca, 0x08, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x04,
    0x04, 0x1f, 0x03, 0x02, 0x12, 0x06, 0xcd, 0x08, 0x02, 0xd3, 0x08, 0x03, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1f, 0x03, 0x02, 0x01, 0x12, 0x04, 0xcd, 0x08, 0x0a, 0x11, 0x0a, 0x34, 0x0a, 0x06, 0x04,
    0x1f, 0x03, 0x02, 0x02, 0x00, 0x12, 0x04, 0xcf, 0x08, 0x04, 0x23, 0x1a, 0x0b, 0x20, 0x53, 0x75,
    0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x2e, 0x0a, 0x22, 0x17, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x73, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcf, 0x08,
    0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03, 0x02, 0x02, 0x00, 0x06, 0x12, 0x04, 0xcf,
    0x08, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xcf, 0x08, 0x14, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xcf, 0x08, 0x21, 0x22, 0x0a, 0x42, 0x0a, 0x06, 0x04, 0x1f, 0x03, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xd2, 0x08, 0x04, 0x1e, 0x1a, 0x0a, 0x20, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x2e,
    0x0a, 0x22, 0x26, 0x20, 0x55, 0x73, 0x65, 0x72, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x75, 0x6e,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x2f, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x73, 0x20, 0x61, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03,
    0x02, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd2, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f,
    0x03, 0x02, 0x02, 0x01, 0x06, 0x12, 0x04, 0xd2, 0x08, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1f, 0x03, 0x02, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd2, 0x08, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1f, 0x03, 0x02, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd2, 0x08, 0x1c, 0x1d, 0x0a, 0x5e, 0x0a,
    0x04, 0x04, 0x1f, 0x03, 0x03, 0x12, 0x06, 0xd7, 0x08, 0x02, 0xdd, 0x08, 0x03, 0x1a, 0x4e, 0x20,
    0x57, 0x68, 0x69, 0x63, 0x68, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x73,
    0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x20,
    0x74, 0x6f, 0x20, 0x73, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x0a,
    0x20, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1f, 0x03, 0x03, 0x01, 0x12, 0x04, 0xd7, 0x08, 0x0a, 0x1b, 0x0a, 0x1b, 0x0a, 0x06,
    0x04, 0x1f, 0x03, 0x03, 0x02, 0x00, 0x12, 0x04, 0xd9, 0x08, 0x04, 0x23, 0x1a, 0x0b, 0x20, 0x53,
    0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03,
    0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd9, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f,
    0x03, 0x03, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd9, 0x08, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1f, 0x03, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd9, 0x08, 0x14, 0x1e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1f, 0x03, 0x03, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd9, 0x08, 0x21, 0x22, 0x0a, 0x1a, 0x0a,
    0x06, 0x04, 0x1f, 0x03, 0x03, 0x02, 0x01, 0x12, 0x04, 0xdc, 0x08, 0x04, 0x2d, 0x1a, 0x0a, 0x20,
    0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03,
    0x03, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdc, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f,
    0x03, 0x03, 0x02, 0x01, 0x06, 0x12, 0x04, 0xdc, 0x08, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1f, 0x03, 0x03, 0x02, 0x01, 0x01, 0x12, 0x04, 0xdc, 0x08, 0x14, 0x28, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1f, 0x03, 0x03, 0x02, 0x01, 0x03, 0x12, 0x04, 0xdc, 0x08, 0x2b, 0x2c, 0x0a, 0x97, 0x05,
    0x0a, 0x02, 0x04, 0x20, 0x12, 0x06, 0xf4, 0x08, 0x00, 0xf9, 0x08, 0x01, 0x1a, 0x88, 0x05, 0x2a,
    0x0a, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20,
    0x41, 0x43, 0x4c, 0x2e, 0x0a, 0x0a, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x61, 0x75, 0x74, 0x68,
    0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x20, 0x69, 0x73, 0x20, 0x65, 0x76, 0x61, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61,
    0x67, 0x61, 0x69, 0x6e, 0x73, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x43, 0x4c, 0x73, 0x20,
    0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x0a, 0x20, 0x74, 0x68,
    0x65, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x2e, 0x0a,
    0x0a, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x6d, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x79,
    0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x43, 0x4c, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61,
    0x20, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x20, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x72,
    0x65, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64,
    0x20, 0x65, 0x76, 0x65, 0x6e, 0x0a, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x79,
    0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x73,
    0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63,
    0x74, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x41, 0x43,
    0x4c, 0x20, 0x74, 0x68, 0x61, 0x74, 0x0a, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x64, 0x65, 0x74, 0x65,
    0x72, 0x6d, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74,
    0x68, 0x61, 0x74, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75,
    0x6c, 0x64, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64,
    0x20, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x2e, 0x20, 0x41, 0x6e, 0x20, 0x41, 0x43, 0x4c, 0x20,
    0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x20, 0x69, 0x66, 0x66, 0x20, 0x62, 0x6f, 0x74, 0x68,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x0a, 0x20, 0x28,
    0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x2c, 0x20, 0x70,
    0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x73, 0x29, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e,
    0x2c, 0x20, 0x75, 0x72, 0x6c, 0x73, 0x2c, 0x20, 0x75, 0x73, 0x65, 0x72, 0x73, 0x2c, 0x0a, 0x20,
    0x72, 0x6f, 0x6c, 0x65, 0x73, 0x29, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x43,
    0x4c, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x2e, 0x0a, 0x0a, 0x20, 0x49, 0x66, 0x20, 0x6e, 0x6f, 0x6e, 0x65, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x43, 0x4c, 0x73, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2c, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x27, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x76, 0x65, 0x27, 0x20, 0x66,
    0x69, 0x65, 0x6c, 0x64, 0x0a, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x73,
    0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x70,
    0x65, 0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x2e,
    0x0a, 0x0a, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x76, 0x69, 0x6e, 0x6f, 0x64, 0x29, 0x3a, 0x20,
    0x44, 0x6f, 0x20, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f,
    0x66, 0x20, 0x41, 0x43, 0x4c, 0x73, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x70, 0x6f, 0x73, 0x73,
    0x69, 0x62, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x20, 0x01, 0x12, 0x04,
    0xf4, 0x08, 0x08, 0x0c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x00, 0x12, 0x04, 0xf5, 0x08,
    0x02, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf5, 0x08, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf5, 0x08, 0x0b, 0x0f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf5, 0x08, 0x10, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf5, 0x08, 0x1d, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x08, 0x12, 0x04, 0xf5, 0x08, 0x1f, 0x2f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x20, 0x02, 0x00, 0x07, 0x12, 0x04, 0xf5, 0x08, 0x2a, 0x2e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x20, 0x02, 0x01, 0x12, 0x04, 0xf6, 0x08, 0x02, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xf6, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02,
    0x01, 0x06, 0x12, 0x04, 0xf6, 0x08, 0x0b, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xf6, 0x08, 0x21, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xf6, 0x08, 0x37, 0x38, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x02, 0x12, 0x04,
    0xf7, 0x08, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf7,
    0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x06, 0x12, 0x04, 0xf7, 0x08,
    0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf7, 0x08, 0x17,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf7, 0x08, 0x23, 0x24,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x03, 0x12, 0x04, 0xf8, 0x08, 0x02, 0x39, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x20, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf8, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x20, 0x02, 0x03, 0x06, 0x12, 0x04, 0xf8, 0x08, 0x0b, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x20, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf8, 0x08, 0x21, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x20, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf8, 0x08, 0x37, 0x38, 0x0a, 0xba, 0x01, 0x0a, 0x02, 0x04,
    0x21, 0x12, 0x06, 0x81, 0x09, 0x00, 0x91, 0x09, 0x01, 0x1a, 0xab, 0x01, 0x2a, 0x0a, 0x20, 0x52,
    0x61, 0x74, 0x65, 0x20, 0x28, 0x71, 0x75, 0x65, 0x72, 0x69, 0x65, 0x73, 0x20, 0x70, 0x65, 0x72,
    0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x2c, 0x20, 0x51, 0x50, 0x53, 0x29, 0x20, 0x6c, 0x69,
    0x6d, 0x69, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73,
    0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2e, 0x0a, 0x20, 0x53, 0x74,
    0x72, 0x69, 0x63, 0x74, 0x6c, 0x79, 0x20, 0x73, 0x70, 0x65, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0x20,
    0x74, 0x68, 0x65, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d,
    0x62, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20,
    0x61, 0x6c, 0x6c, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x0a, 0x20, 0x70, 0x72, 0x69, 0x6e,
    0x63, 0x69, 0x70, 0x61, 0x6c, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x21, 0x01, 0x12, 0x04,
    0x81, 0x09, 0x08, 0x11, 0x0a, 0x78, 0x0a, 0x04, 0x04, 0x21, 0x02, 0x00, 0x12, 0x04, 0x84, 0x09,
    0x02, 0x1a, 0x1a, 0x6a, 0x20, 0x4c, 0x65, 0x61, 0x76, 0x69, 0x6e, 0x67, 0x20, 0x51, 0x50, 0x53,
    0x20, 0x75, 0x6e, 0x73, 0x65, 0x74, 0x20, 0x67, 0x69, 0x76, 0x65, 0x73, 0x20, 0x69, 0x74, 0x20,
    0x75, 0x6e, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20, 0x28,
    0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74,
    0x6c, 0x65, 0x64, 0x29, 0x2c, 0x0a, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61, 0x6c, 0x73,
    0x6f, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x69, 0x65, 0x73, 0x20, 0x75, 0x6e, 0x6c, 0x69, 0x6d, 0x69,
    0x74, 0x65, 0x64, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x04, 0x12, 0x04, 0x84, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x21, 0x02, 0x00, 0x05, 0x12, 0x04, 0x84, 0x09, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x21, 0x02, 0x00, 0x01, 0x12, 0x04, 0x84, 0x09, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x21, 0x02, 0x00, 0x03, 0x12, 0x04, 0x84, 0x09, 0x18, 0x19, 0x0a, 0x94, 0x01, 0x0a, 0x04, 0x04,
    0x21, 0x02, 0x01, 0x12, 0x04, 0x88, 0x09, 0x02, 0x20, 0x1a, 0x85, 0x01, 0x20, 0x50, 0x72, 0x69,
    0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x20, 0x6f, 0x66, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77,
    0x6f, 0x72, 0x6b, 0x28, 0x73, 0x29, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x72,
    0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x2e, 0x20, 0x53, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6d,
    0x61, 0x74, 0x63, 0x68, 0x0a, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49,
    0x6e, 0x66, 0x6f, 0x2e, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x70, 0x61, 0x6c, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x2e, 0x70, 0x72, 0x69, 0x6e,
    0x63, 0x69, 0x70, 0x61, 0x6c, 0x20, 0x28, 0x69, 0x66, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20,
    0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x29, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x01, 0x04, 0x12, 0x04, 0x88, 0x09, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x01, 0x05, 0x12, 0x04, 0x88, 0x09, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x01, 0x01, 0x12, 0x04, 0x88, 0x09, 0x12, 0x1b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x21, 0x02, 0x01, 0x03, 0x12, 0x04, 0x88, 0x09, 0x1e, 0x1f, 0x0a, 0x92, 0x03,
    0x0a, 0x04, 0x04, 0x21, 0x02, 0x02, 0x12, 0x04, 0x90, 0x09, 0x02, 0x1f, 0x1a, 0x83, 0x03, 0x20,
    0x4d, 0x61, 0x78, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x6f, 0x75,
    0x74, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
    0x65, 0x73, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x63,
    0x69, 0x70, 0x61, 0x6c, 0x0a, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x20, 0x62, 0x79,
    0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x6e, 0x65, 0x78, 0x74, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
    0x69, 0x73, 0x20, 0x64, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61,
    0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x0a,
    0x20, 0x62, 0x61, 0x63, 0x6b, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6e,
    0x64, 0x65, 0x72, 0x2e, 0x20, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x72, 0x65,
    0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65,
    0x61, 0x63, 0x68, 0x65, 0x64, 0x20, 0x61, 0x72, 0x65, 0x0a, 0x20, 0x73, 0x74, 0x69, 0x6c, 0x6c,
    0x20, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 0x6f,
    0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x2e, 0x0a,
    0x20, 0x49, 0x66, 0x20, 0x75, 0x6e, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2c,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x20,
    0x69, 0x73, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20, 0x75, 0x6e, 0x6c, 0x69,
    0x6d, 0x69, 0x74, 0x65, 0x64, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x2e, 0x0a,
    0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x76, 0x61, 0x6c, 0x75,
    0x65, 0x20, 0x69, 0x73, 0x20, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x20, 0x69, 0x66, 0x20,
    0x27, 0x71, 0x70, 0x73, 0x27, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x65, 0x74,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x02, 0x04, 0x12, 0x04, 0x90, 0x09, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x02, 0x05, 0x12, 0x04, 0x90, 0x09, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x02, 0x01, 0x12, 0x04, 0x90, 0x09, 0x12, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x02, 0x03, 0x12, 0x04, 0x90, 0x09, 0x1d, 0x1e, 0x0a, 0x98,
    0x01, 0x0a, 0x02, 0x04, 0x22, 0x12, 0x06, 0x99, 0x09, 0x00, 0xa5, 0x09, 0x01, 0x1a, 0x89, 0x01,
    0x2a, 0x0a, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66,
    0x20, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x2e, 0x0a, 0x20, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20,
    0x72, 0x61, 0x74, 0x65, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x20, 0x64, 0x65, 0x66, 0x69,
    0x6e, 0x65, 0x64, 0x20, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6e, 0x6f, 0x74,
    0x20, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x20, 0x75, 0x6e, 0x6c, 0x65, 0x73,
    0x73, 0x0a, 0x20, 0x27, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x5f, 0x64, 0x65,
    0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x71, 0x70, 0x73, 0x27, 0x20, 0x69, 0x73, 0x20, 0x73, 0x70,
    0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x22, 0x01,
    0x12, 0x04, 0x99, 0x09, 0x08, 0x12, 0x0a, 0x34, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x00, 0x12, 0x04,
    0x9b, 0x09, 0x02, 0x20, 0x1a, 0x26, 0x20, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x20, 0x73, 0x68, 0x6f,
    0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20,
    0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x22, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9b, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x22, 0x02, 0x00, 0x06, 0x12, 0x04, 0x9b, 0x09, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22,
    0x02, 0x00, 0x01, 0x12, 0x04, 0x9b, 0x09, 0x15, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x9b, 0x09, 0x1e, 0x1f, 0x0a, 0xc7, 0x01, 0x0a, 0x04, 0x04, 0x22, 0x02,
    0x01, 0x12, 0x04, 0xa0, 0x09, 0x02, 0x2c, 0x1a, 0xb8, 0x01, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x27,
    0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x27, 0x20, 0x67, 0x65, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x72, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x20,
    0x54, 0x68, 0x69, 0x73, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20,
    0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20, 0x66,
    0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x6d, 0x2c, 0x20,
    0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x69, 0x72, 0x20, 0x63, 0x6f, 0x6d, 0x62,
    0x69, 0x6e, 0x65, 0x64, 0x0a, 0x20, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x20, 0x69, 0x73,
    0x20, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x67, 0x65, 0x74,
    0x68, 0x65, 0x72, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x61, 0x74, 0x65,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa0, 0x09, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa0, 0x09, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa0, 0x09, 0x12, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa0, 0x09, 0x2a, 0x2b, 0x0a, 0x98,
    0x01, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x02, 0x12, 0x04, 0xa4, 0x09, 0x02, 0x31, 0x1a, 0x89, 0x01,
    0x20, 0x41, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65,
    0x64, 0x20, 0x69, 0x6e, 0x20, 0x27, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x27, 0x20, 0x67, 0x65,
    0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x63,
    0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69,
    0x73, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x20, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x20, 0x73, 0x69, 0x6d, 0x69, 0x6c, 0x61, 0x72, 0x20, 0x74, 0x6f, 0x20,
    0x27, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x5f, 0x64, 0x65, 0x66, 0x61, 0x75,
    0x6c, 0x74, 0x5f, 0x71, 0x70, 0x73, 0x27, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xa4, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xa4, 0x09, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xa4, 0x09, 0x12, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xa4, 0x09, 0x2f, 0x30, 0x0a, 0x96, 0x01, 0x0a, 0x02, 0x04, 0x23, 0x12, 0x06, 0xac, 0x09,
    0x00, 0xc6, 0x09, 0x01, 0x1a, 0x87, 0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69,
    0x62, 0x65, 0x20, 0x61, 0x6e, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x20, 0x62, 0x79, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x2e, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x69, 0x74, 0x27, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x0a, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x73, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20,
    0x4d, 0x65, 0x73, 0x6f, 0x73, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x69, 0x7a,
    0x65, 0x72, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x23, 0x01, 0x12, 0x04, 0xac, 0x09, 0x08, 0x0d, 0x0a, 0x0e, 0x0a, 0x04, 0x04,
    0x23, 0x04, 0x00, 0x12, 0x06, 0xad, 0x09, 0x02, 0xaf, 0x09, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x23, 0x04, 0x00, 0x01, 0x12, 0x04, 0xad, 0x09, 0x07, 0x0b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23,
    0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xae, 0x09, 0x04, 0x0d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23,
    0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xae, 0x09, 0x04, 0x08, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x23, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xae, 0x09, 0x0b, 0x0c, 0x0a, 0x7d, 0x0a, 0x04,
    0x04, 0x23, 0x03, 0x00, 0x12, 0x06, 0xb3, 0x09, 0x02, 0xbf, 0x09, 0x03, 0x1a, 0x6d, 0x20, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x73, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x20, 0x41, 0x70, 0x70, 0x63, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x20,
    0x53, 0x65, 0x65, 0x3a, 0x0a, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69,
    0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x61, 0x70, 0x70, 0x63, 0x2f, 0x73, 0x70,
    0x65, 0x63, 0x2f, 0x62, 0x6c, 0x6f, 0x62, 0x2f, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2f, 0x73,
    0x70, 0x65, 0x63, 0x2f, 0x61, 0x63, 0x69, 0x2e, 0x6d, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x23, 0x03, 0x00, 0x01, 0x12, 0x04, 0xb3, 0x09, 0x0a, 0x0e, 0x0a, 0x28, 0x0a, 0x06, 0x04, 0x23,
    0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb5, 0x09, 0x04, 0x1d, 0x1a, 0x18, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6d, 0x61,
    0x67, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xb5, 0x09, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x03, 0x00, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xb5, 0x09, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x03, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xb5, 0x09, 0x14, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x03, 0x00, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xb5, 0x09, 0x1b, 0x1c, 0x0a, 0xdd, 0x01, 0x0a, 0x06, 0x04, 0x23, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xbb, 0x09, 0x04, 0x1b, 0x1a, 0xcc, 0x01, 0x20, 0x41, 0x6e, 0x20,
    0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x49, 0x44, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74,
    0x72, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d,
    0x61, 0x74, 0x20, 0x22, 0x68, 0x61, 0x73, 0x68, 0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x2c,
    0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x0a, 0x20, 0x22, 0x68, 0x61, 0x73, 0x68, 0x22, 0x20, 0x69,
    0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x61, 0x6c, 0x67, 0x6f, 0x72,
    0x69, 0x74, 0x68, 0x6d, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x22, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x22, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x65, 0x78,
    0x0a, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x2e, 0x20,
    0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x6e,
    0x6c, 0x79, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64, 0x0a, 0x20, 0x68, 0x61,
    0x73, 0x68, 0x20, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x20, 0x69, 0x73, 0x20,
    0x73, 0x68, 0x61, 0x35, 0x31, 0x32, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x03, 0x00,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xbb, 0x09, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x03,
    0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbb, 0x09, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23,
    0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbb, 0x09, 0x14, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x23, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbb, 0x09, 0x19, 0x1a, 0x0a, 0x51, 0x0a, 0x06,
    0x04, 0x23, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xbe, 0x09, 0x04, 0x1f, 0x1a, 0x41, 0x20, 0x4f,
    0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x2e, 0x20,
    0x53, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73,
    0x3a, 0x20, 0x22, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x2c, 0x20, 0x22, 0x6f, 0x73,
    0x22, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x22, 0x61, 0x72, 0x63, 0x68, 0x22, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x23, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbe, 0x09, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x03, 0x00, 0x02, 0x02, 0x06, 0x12, 0x04, 0xbe, 0x09, 0x0d,
    0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbe, 0x09,
    0x14, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbe,
    0x09, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x00, 0x12, 0x04, 0xc1, 0x09, 0x02,
    0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc1, 0x09, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc1, 0x09, 0x0b, 0x0f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc1, 0x09, 0x10, 0x14, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc1, 0x09, 0x17, 0x18, 0x0a, 0x5a, 0x0a,
    0x04, 0x04, 0x23, 0x02, 0x01, 0x12, 0x04, 0xc5, 0x09, 0x02, 0x19, 0x1a, 0x4c, 0x20, 0x4f, 0x6e,
    0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f,
    0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65,
    0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x0a, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xc5, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01,
    0x06, 0x12, 0x04, 0xc5, 0x09, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xc5, 0x09, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xc5, 0x09, 0x17, 0x18, 0x0a, 0x91, 0x01, 0x0a, 0x02, 0x04, 0x24, 0x12, 0x06, 0xcd, 0x09,
    0x00, 0xe2, 0x09, 0x01, 0x1a, 0x82, 0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69,
    0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x20, 0x6d, 0x61, 0x70,
    0x70, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d,
    0x20, 0x68, 0x6f, 0x73, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
    0x65, 0x72, 0x20, 0x6f, 0x72, 0x20, 0x76, 0x69, 0x63, 0x65, 0x0a, 0x20, 0x76, 0x65, 0x72, 0x73,
    0x61, 0x2e, 0x20, 0x42, 0x6f, 0x74, 0x68, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x63, 0x61,
    0x6e, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x72, 0x65, 0x66, 0x65, 0x72, 0x20, 0x74,
    0x6f, 0x20, 0x61, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x20, 0x6f, 0x72,
    0x20, 0x61, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x24, 0x01,
    0x12, 0x04, 0xcd, 0x09, 0x08, 0x0e, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x24, 0x04, 0x00, 0x12, 0x06,
    0xce, 0x09, 0x02, 0xd1, 0x09, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x04, 0x00, 0x01, 0x12,
    0x04, 0xce, 0x09, 0x07, 0x0b, 0x0a, 0x1d, 0x0a, 0x06, 0x04, 0x24, 0x04, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xcf, 0x09, 0x04, 0x0b, 0x22, 0x0d, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2d, 0x77, 0x72, 0x69,
    0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xcf, 0x09, 0x04, 0x06, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x04, 0x00, 0x02, 0x00, 0x02,
    0x12, 0x04, 0xcf, 0x09, 0x09, 0x0a, 0x0a, 0x1c, 0x0a, 0x06, 0x04, 0x24, 0x04, 0x00, 0x02, 0x01,
    0x12, 0x04, 0xd0, 0x09, 0x04, 0x0b, 0x22, 0x0c, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2d, 0x6f, 0x6e,
    0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xd0, 0x09, 0x04, 0x06, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x04, 0x00, 0x02, 0x01, 0x02,
    0x12, 0x04, 0xd0, 0x09, 0x09, 0x0a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x24, 0x02, 0x00, 0x12, 0x04,
    0xd3, 0x09, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd3,
    0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd3, 0x09,
    0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd3, 0x09, 0x10,
    0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd3, 0x09, 0x17, 0x18,
    0x0a, 0x4f, 0x0a, 0x04, 0x04, 0x24, 0x02, 0x01, 0x12, 0x04, 0xd6, 0x09, 0x02, 0x25, 0x1a, 0x41,
    0x20, 0x41, 0x62, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x70,
    0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x64, 0x69, 0x72,
    0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x69,
    0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd6, 0x09, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd6, 0x09, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd6, 0x09, 0x12, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x24, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd6, 0x09, 0x23, 0x24, 0x0a, 0x7e, 0x0a,
    0x04, 0x04, 0x24, 0x02, 0x02, 0x12, 0x04, 0xdd, 0x09, 0x02, 0x20, 0x1a, 0x70, 0x20, 0x41, 0x62,
    0x73, 0x6f, 0x6c, 0x75, 0x74, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x70, 0x6f, 0x69, 0x6e,
    0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74,
    0x6f, 0x72, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x0a, 0x20, 0x70, 0x61,
    0x74, 0x68, 0x20, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x77, 0x6f, 0x72,
    0x6b, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x24, 0x02, 0x02, 0x04, 0x12, 0x04, 0xdd, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x24, 0x02, 0x02, 0x05, 0x12, 0x04, 0xdd, 0x09, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x24, 0x02, 0x02, 0x01, 0x12, 0x04, 0xdd, 0x09, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xdd, 0x09, 0x1e, 0x1f, 0x0a, 0x7b, 0x0a, 0x04, 0x04, 0x24, 0x02,
    0x03, 0x12, 0x04, 0xe1, 0x09, 0x02, 0x1b, 0x1a, 0x6d, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x6f, 0x6c, 0x75,
    0x6d, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x77,
    0x68, 0x69, 0x63, 0x68, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61,
    0x20, 0x72, 0x6f, 0x6f, 0x74, 0x0a, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x79, 0x73, 0x74, 0x65,
    0x6d, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20,
    0x70, 0x72, 0x6f, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x4d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xe1, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x03, 0x06, 0x12, 0x04,
    0xe1, 0x09, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x03, 0x01, 0x12, 0x04, 0xe1,
    0x09, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x03, 0x03, 0x12, 0x04, 0xe1, 0x09,
    0x19, 0x1a, 0x0a, 0x84, 0x01, 0x0a, 0x02, 0x04, 0x25, 0x12, 0x06, 0xe9, 0x09, 0x00, 0xa0, 0x0a,
    0x01, 0x1a, 0x76, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20,
    0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x63, 0x6f, 0x6e, 0x66,
    0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x6c,
    0x6c, 0x6f, 0x77, 0x73, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x0a,
    0x20, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x63, 0x6f,
    0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e,
    0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x25, 0x01,
    0x12, 0x04, 0xe9, 0x09, 0x08, 0x15, 0x0a, 0x35, 0x0a, 0x04, 0x04, 0x25, 0x04, 0x00, 0x12, 0x06,
    0xeb, 0x09, 0x02, 0xee, 0x09, 0x03, 0x1a, 0x25, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x63, 0x6f, 0x6e,
    0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x25, 0x04, 0x00, 0x01, 0x12, 0x04, 0xeb, 0x09, 0x07, 0x0b, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x25, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xec, 0x09, 0x04, 0x0f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x25, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xec, 0x09, 0x04, 0x0a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x25, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xec, 0x09, 0x0d, 0x0e, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x25, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xed, 0x09, 0x04, 0x0e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x25, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xed, 0x09, 0x04, 0x09, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x25, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xed, 0x09, 0x0c, 0x0d,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x25, 0x03, 0x00, 0x12, 0x06, 0xf0, 0x09, 0x02, 0x92, 0x0a, 0x03,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x03, 0x00, 0x01, 0x12, 0x04, 0xf0, 0x09, 0x0a, 0x14, 0x0a,
    0x4e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xf2, 0x09, 0x04, 0x1e, 0x1a,
    0x3e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x20, 0x69, 0x6d, 0x61,
    0x67, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x67, 0x6f, 0x69, 0x6e, 0x67,
    0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf2, 0x09, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf2, 0x09, 0x0d,
    0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf2, 0x09,
    0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf2,
    0x09, 0x1c, 0x1d, 0x0a, 0x24, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x04, 0x00, 0x12, 0x06, 0xf5,
    0x09, 0x04, 0xf9, 0x09, 0x05, 0x1a, 0x12, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20,
    0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03,
    0x00, 0x04, 0x00, 0x01, 0x12, 0x04, 0xf5, 0x09, 0x09, 0x10, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x25,
    0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xf6, 0x09, 0x06, 0x0f, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x25, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf6, 0x09, 0x06, 0x0a, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xf6, 0x09,
    0x0d, 0x0e, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x25, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04,
    0xf7, 0x09, 0x06, 0x11, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xf7, 0x09, 0x06, 0x0c, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x04,
    0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xf7, 0x09, 0x0f, 0x10, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x25,
    0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xf8, 0x09, 0x06, 0x0f, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x25, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf8, 0x09, 0x06, 0x0a, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04, 0xf8, 0x09,
    0x0d, 0x0e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xfb, 0x09,
    0x04, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xfb,
    0x09, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x06, 0x12, 0x04,
    0xfb, 0x09, 0x0d, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xfb, 0x09, 0x15, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xfb, 0x09, 0x1f, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01,
    0x08, 0x12, 0x04, 0xfb, 0x09, 0x21, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02,
    0x01, 0x07, 0x12, 0x04, 0xfb, 0x09, 0x2c, 0x30, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00,
    0x03, 0x00, 0x12, 0x06, 0xfd, 0x09, 0x04, 0x82, 0x0a, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25,
    0x03, 0x00, 0x03, 0x00, 0x01, 0x12, 0x04, 0xfd, 0x09, 0x0c, 0x17, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x25, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xfe, 0x09, 0x06, 0x24, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x25, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfe, 0x09, 0x06, 0x0e,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xfe,
    0x09, 0x0f, 0x15, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xfe, 0x09, 0x16, 0x1f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xfe, 0x09, 0x22, 0x23, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x25, 0x03,
    0x00, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xff, 0x09, 0x06, 0x29, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x25, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xff, 0x09, 0x06, 0x0e, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xff, 0x09, 0x0f,
    0x15, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xff, 0x09, 0x16, 0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xff, 0x09, 0x27, 0x28, 0x0a, 0x39, 0x0a, 0x08, 0x04, 0x25, 0x03, 0x00, 0x03,
    0x00, 0x02, 0x02, 0x12, 0x04, 0x81, 0x0a, 0x06, 0x23, 0x1a, 0x27, 0x20, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x74, 0x6f, 0x20, 0x65, 0x78, 0x70, 0x6f, 0x73, 0x65, 0x20, 0x61,
    0x73, 0x20, 0x28, 0x69, 0x65, 0x3a, 0x20, 0x74, 0x63, 0x70, 0x2c, 0x20, 0x75, 0x64, 0x70, 0x29,
    0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12,
    0x04, 0x81, 0x0a, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00, 0x03, 0x00, 0x02,
    0x02, 0x05, 0x12, 0x04, 0x81, 0x0a, 0x0f, 0x15, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x25, 0x03, 0x00,
    0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x81, 0x0a, 0x16, 0x1e, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x25, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0x81, 0x0a, 0x21, 0x22, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0x84, 0x0a, 0x04, 0x2b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0x84, 0x0a, 0x04, 0x0c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x02, 0x06, 0x12, 0x04, 0x84, 0x0a, 0x0d, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x84, 0x0a, 0x19,
    0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0x84, 0x0a,
    0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0x86, 0x0a,
    0x04, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0x86,
    0x0a, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04,
    0x86, 0x0a, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12,
    0x04, 0x86, 0x0a, 0x12, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x03, 0x03,
    0x12, 0x04, 0x86, 0x0a, 0x1f, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x03,
    0x08, 0x12, 0x04, 0x86, 0x0a, 0x21, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02,
    0x03, 0x07, 0x12, 0x04, 0x86, 0x0a, 0x2c, 0x31, 0x0a, 0xd4, 0x01, 0x0a, 0x06, 0x04, 0x25, 0x03,
    0x00, 0x02, 0x04, 0x12, 0x04, 0x8c, 0x0a, 0x04, 0x26, 0x1a, 0xc3, 0x01, 0x20, 0x41, 0x6c, 0x6c,
    0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x72, 0x62, 0x69, 0x74, 0x72, 0x61, 0x72, 0x79, 0x20,
    0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65,
    0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x6f, 0x63, 0x6b, 0x65,
    0x72, 0x20, 0x43, 0x4c, 0x49, 0x2e, 0x0a, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x61, 0x6e, 0x79, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65,
    0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20,
    0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x65,
    0x64, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74,
    0x65, 0x64, 0x20, 0x6d, 0x6f, 0x76, 0x69, 0x6e, 0x67, 0x20, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72,
    0x64, 0x2c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20, 0x6d,
    0x6f, 0x76, 0x65, 0x20, 0x61, 0x77, 0x61, 0x79, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x0a, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x64, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x20, 0x43, 0x4c, 0x49, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0x8c, 0x0a, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x04, 0x06, 0x12, 0x04, 0x8c, 0x0a, 0x0d,
    0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0x8c, 0x0a,
    0x17, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0x8c,
    0x0a, 0x24, 0x25, 0x0a, 0xac, 0x01, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04,
    0x91, 0x0a, 0x04, 0x27, 0x1a, 0x9b, 0x01, 0x20, 0x57, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x72,
    0x75, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x69, 0x7a, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6c,
    0x6c, 0x0a, 0x20, 0x70, 0x75, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x6f, 0x63, 0x6b,
    0x65, 0x72, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x20,
    0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x0a, 0x20, 0x69, 0x73,
    0x20, 0x61, 0x6c, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61,
    0x64, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65,
    0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0x91,
    0x0a, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04,
    0x91, 0x0a, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12,
    0x04, 0x91, 0x0a, 0x12, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x05, 0x03,
    0x12, 0x04, 0x91, 0x0a, 0x25, 0x26, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x25, 0x03, 0x01, 0x12, 0x06,
    0x94, 0x0a, 0x02, 0x96, 0x0a, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x03, 0x01, 0x01, 0x12,
    0x04, 0x94, 0x0a, 0x0a, 0x13, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x01, 0x02, 0x00, 0x12,
    0x04, 0x95, 0x0a, 0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x01, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x95, 0x0a, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x01, 0x02, 0x00,
    0x06, 0x12, 0x04, 0x95, 0x0a, 0x0d, 0x12, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x01, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x95, 0x0a, 0x13, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x01,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x95, 0x0a, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x25, 0x02,
    0x00, 0x12, 0x04, 0x98, 0x0a, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x98, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x06, 0x12,
    0x04, 0x98, 0x0a, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x01, 0x12, 0x04,
    0x98, 0x0a, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x03, 0x12, 0x04, 0x98,
    0x0a, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x25, 0x02, 0x01, 0x12, 0x04, 0x99, 0x0a, 0x02,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x01, 0x04, 0x12, 0x04, 0x99, 0x0a, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x01, 0x06, 0x12, 0x04, 0x99, 0x0a, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x01, 0x01, 0x12, 0x04, 0x99, 0x0a, 0x12, 0x19, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x25, 0x02, 0x01, 0x03, 0x12, 0x04, 0x99, 0x0a, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x25, 0x02, 0x02, 0x12, 0x04, 0x9a, 0x0a, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x25, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9a, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25,
    0x02, 0x02, 0x05, 0x12, 0x04, 0x9a, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02,
    0x02, 0x01, 0x12, 0x04, 0x9a, 0x0a, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x02,
    0x03, 0x12, 0x04, 0x9a, 0x0a, 0x1d, 0x1e, 0x0a, 0x5a, 0x0a, 0x04, 0x04, 0x25, 0x02, 0x03, 0x12,
    0x04, 0x9e, 0x0a, 0x02, 0x21, 0x1a, 0x4c, 0x20, 0x4f, 0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e,
    0x67, 0x20, 0x2a, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73,
    0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74,
    0x6f, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x79, 0x70,
    0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x03, 0x04, 0x12, 0x04, 0x9e, 0x0a,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x03, 0x06, 0x12, 0x04, 0x9e, 0x0a, 0x0b,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9e, 0x0a, 0x16, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x03, 0x03, 0x12, 0x04, 0x9e, 0x0a, 0x1f, 0x20, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x25, 0x02, 0x04, 0x12, 0x04, 0x9f, 0x0a, 0x02, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x25, 0x02, 0x04, 0x04, 0x12, 0x04, 0x9f, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x25, 0x02, 0x04, 0x06, 0x12, 0x04, 0x9f, 0x0a, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x25, 0x02, 0x04, 0x01, 0x12, 0x04, 0x9f, 0x0a, 0x15, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25,
    0x02, 0x04, 0x03, 0x12, 0x04, 0x9f, 0x0a, 0x1d, 0x1e, 0x0a, 0x27, 0x0a, 0x02, 0x04, 0x26, 0x12,
    0x06, 0xa6, 0x0a, 0x00, 0xa8, 0x0a, 0x01, 0x1a, 0x19, 0x2a, 0x0a, 0x20, 0x43, 0x6f, 0x6c, 0x6c,
    0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73,
    0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x26, 0x01, 0x12, 0x04, 0xa6, 0x0a, 0x08, 0x0e, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x26, 0x02, 0x00, 0x12, 0x04, 0xa7, 0x0a, 0x04, 0x1e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x26, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa7, 0x0a, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x26, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa7, 0x0a, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x26, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa7, 0x0a, 0x13, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xa7, 0x0a, 0x1c, 0x1d, 0x0a, 0x44, 0x0a, 0x02, 0x04, 0x27, 0x12,
    0x06, 0xae, 0x0a, 0x00, 0xb1, 0x0a, 0x01, 0x1a, 0x36, 0x2a, 0x0a, 0x20, 0x4b, 0x65, 0x79, 0x2c,
    0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x20, 0x66, 0x72, 0x65, 0x65, 0x20, 0x66,
    0x6f, 0x72, 0x6d, 0x20, 0x75, 0x73, 0x65, 0x72, 0x2d, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x27, 0x01, 0x12, 0x04, 0xae, 0x0a, 0x08, 0x0d, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x27, 0x02, 0x00, 0x12, 0x04, 0xaf, 0x0a, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xaf, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xaf, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xaf, 0x0a, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xaf, 0x0a, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x01, 0x12, 0x04,
    0xb0, 0x0a, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb0,
    0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb0, 0x0a,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb0, 0x0a, 0x12,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb0, 0x0a, 0x1a, 0x1b,
    0x0a, 0x38, 0x0a, 0x02, 0x04, 0x28, 0x12, 0x06, 0xb7, 0x0a, 0x00, 0xbb, 0x0a, 0x01, 0x1a, 0x2a,
    0x2a, 0x0a, 0x20, 0x4e, 0x61, 0x6d, 0x65, 0x64, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x75, 0x73,
    0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x64,
    0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x28,
    0x01, 0x12, 0x04, 0xb7, 0x0a, 0x08, 0x0c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x00, 0x12,
    0x04, 0xb8, 0x0a, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xb8, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb8,
    0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb8, 0x0a,
    0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb8, 0x0a, 0x1b,
    0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x01, 0x12, 0x04, 0xb9, 0x0a, 0x02, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb9, 0x0a, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb9, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x28, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb9, 0x0a, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x28, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb9, 0x0a, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x28, 0x02, 0x02, 0x12, 0x04, 0xba, 0x0a, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xba, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xba, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xba, 0x0a, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xba, 0x0a, 0x1d, 0x1e, 0x0a, 0x26, 0x0a, 0x02, 0x04, 0x29, 0x12, 0x06, 0xc1, 0x0a, 0x00,
    0xc3, 0x0a, 0x01, 0x1a, 0x18, 0x2a, 0x0a, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x29, 0x01, 0x12, 0x04, 0xc1, 0x0a, 0x08, 0x0d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29,
    0x02, 0x00, 0x12, 0x04, 0xc2, 0x0a, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xc2, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x06,
    0x12, 0x04, 0xc2, 0x0a, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xc2, 0x0a, 0x10, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xc2, 0x0a, 0x18, 0x19, 0x0a, 0xdc, 0x04, 0x0a, 0x02, 0x04, 0x2a, 0x12, 0x06, 0xd3, 0x0a, 0x00,
    0xe1, 0x0a, 0x01, 0x1a, 0xcd, 0x04, 0x2a, 0x0a, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
    0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72,
    0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x76, 0x69, 0x73,
    0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x72, 0x65,
    0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x73, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72,
    0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x0a, 0x20, 0x28, 0x46, 0x52, 0x41, 0x4d, 0x45, 0x57, 0x4f, 0x52, 0x4b,
    0x29, 0x2c, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x4d, 0x65, 0x73, 0x6f,
    0x73, 0x20, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x20, 0x28, 0x43, 0x4c, 0x55, 0x53, 0x54,
    0x45, 0x52, 0x29, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x20,
    0x6e, 0x6f, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73,
    0x20, 0x28, 0x45, 0x58, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x29, 0x2e, 0x0a, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x6c,
    0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x76, 0x65, 0x72,
    0x73, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x76,
    0x69, 0x64, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x0a,
    0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x63, 0x6f, 0x6d,
    0x6d, 0x6f, 0x6e, 0x20, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x20, 0x75,
    0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74,
    0x69, 0x61, 0x74, 0x65, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x0a, 0x20, 0x73, 0x69,
    0x6d, 0x69, 0x6c, 0x61, 0x72, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2e, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x20,
    0x6d, 0x61, 0x79, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75,
    0x65, 0x73, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x0a, 0x20, 0x50, 0x52, 0x4f, 0x44,
    0x2f, 0x51, 0x41, 0x2f, 0x44, 0x45, 0x56, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x6f, 0x63,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x6d, 0x61, 0x79, 0x20,
    0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x6c,
    0x69, 0x6b, 0x65, 0x0a, 0x20, 0x45, 0x41, 0x53, 0x54, 0x2d, 0x55, 0x53, 0x2f, 0x57, 0x45, 0x53,
    0x54, 0x2d, 0x55, 0x53, 0x2f, 0x45, 0x55, 0x52, 0x4f, 0x50, 0x45, 0x2f, 0x41, 0x4d, 0x45, 0x41,
    0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
    0x6e, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x72, 0x65, 0x63, 0x65,
    0x69, 0x76, 0x65, 0x0a, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x6c, 0x69, 0x6b, 0x65,
    0x20, 0x76, 0x32, 0x2e, 0x30, 0x2f, 0x76, 0x30, 0x2e, 0x39, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x65, 0x78, 0x61, 0x63, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65,
    0x73, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x69, 0x73, 0x20, 0x75, 0x70, 0x20,
    0x74, 0x6f, 0x20, 0x65, 0x61, 0x63, 0x68, 0x0a, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
    0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65,
    0x6d, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2a, 0x01, 0x12, 0x04, 0xd3, 0x0a, 0x08, 0x15,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x2a, 0x04, 0x00, 0x12, 0x06, 0xd4, 0x0a, 0x02, 0xd8, 0x0a, 0x03,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x04, 0x00, 0x01, 0x12, 0x04, 0xd4, 0x0a, 0x07, 0x11, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x2a, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xd5, 0x0a, 0x04, 0x12, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd5, 0x0a, 0x04, 0x0d,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xd5, 0x0a, 0x10,
    0x11, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2a, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xd6, 0x0a, 0x04,
    0x10, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd6, 0x0a,
    0x04, 0x0b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xd6,
    0x0a, 0x0e, 0x0f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2a, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xd7,
    0x0a, 0x04, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xd7, 0x0a, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12,
    0x04, 0xd7, 0x0a, 0x0f, 0x10, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x00, 0x12, 0x04, 0xda,
    0x0a, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xda, 0x0a,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x06, 0x12, 0x04, 0xda, 0x0a, 0x0b,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xda, 0x0a, 0x16, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xda, 0x0a, 0x23, 0x24, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x01, 0x12, 0x04, 0xdb, 0x0a, 0x02, 0x1b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdb, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2a, 0x02, 0x01, 0x05, 0x12, 0x04, 0xdb, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xdb, 0x0a, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xdb, 0x0a, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2a, 0x02,
    0x02, 0x12, 0x04, 0xdc, 0x0a, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xdc, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xdc, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xdc, 0x0a, 0x12, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x03, 0x12, 0x04, 0xdc,
    0x0a, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x03, 0x12, 0x04, 0xdd, 0x0a, 0x02,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x03, 0x04, 0x12, 0x04, 0xdd, 0x0a, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x03, 0x05, 0x12, 0x04, 0xdd, 0x0a, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x03, 0x01, 0x12, 0x04, 0xdd, 0x0a, 0x12, 0x1a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2a, 0x02, 0x03, 0x03, 0x12, 0x04, 0xdd, 0x0a, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x2a, 0x02, 0x04, 0x12, 0x04, 0xde, 0x0a, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2a, 0x02, 0x04, 0x04, 0x12, 0x04, 0xde, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a,
    0x02, 0x04, 0x05, 0x12, 0x04, 0xde, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xde, 0x0a, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x04,
    0x03, 0x12, 0x04, 0xde, 0x0a, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x05, 0x12,
    0x04, 0xdf, 0x0a, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xdf, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x05, 0x06, 0x12, 0x04, 0xdf,
    0x0a, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x05, 0x01, 0x12, 0x04, 0xdf, 0x0a,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x05, 0x03, 0x12, 0x04, 0xdf, 0x0a, 0x19,
    0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x06, 0x12, 0x04, 0xe0, 0x0a, 0x02, 0x1d, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x06, 0x04, 0x12, 0x04, 0xe0, 0x0a, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2a, 0x02, 0x06, 0x06, 0x12, 0x04, 0xe0, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2a, 0x02, 0x06, 0x01, 0x12, 0x04, 0xe0, 0x0a, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2a, 0x02, 0x06, 0x03, 0x12, 0x04, 0xe0, 0x0a, 0x1b, 0x1c,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
